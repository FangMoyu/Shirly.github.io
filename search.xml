<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo 搭建博客教程</title>
      <link href="/Shirly.github.io/2024/03/04/%E5%B0%8F%E6%96%B9%E7%9A%84%E9%A1%B9%E7%9B%AE/%E5%9F%BA%E4%BA%8EHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/Shirly.github.io/2024/03/04/%E5%B0%8F%E6%96%B9%E7%9A%84%E9%A1%B9%E7%9B%AE/%E5%9F%BA%E4%BA%8EHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="基于Hexo搭建博客（一-）"><a href="#基于Hexo搭建博客（一-）" class="headerlink" title="基于Hexo搭建博客（一 ）"></a>基于Hexo搭建博客（一 ）</h1><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><ol><li>Git，直接网上下载，安装过程直接一键 Next 即可。</li><li>Node.js 同上</li></ol><blockquote><p>此处不需要配置环境变量</p></blockquote><p>下载完成后通过 cmd 键入： git version 和 node version 若出现对应版本即表示安装完成。</p><ol start="3"><li>安装 Hexo</li></ol><p>在控制台下输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g</span><br></pre></td></tr></table></figure><h2 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h2><ol><li>在硬盘的任意位置新建一个文件夹，文件夹名任意。</li></ol><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101035049.png" alt="image-20230328161828718"></p><ol start="2"><li>将控制台地址位于该文件夹目录下</li></ol><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101035050.png" alt="image-20230328161942211"></p><ol start="3"><li>输入下述指令来初始化博客，这里的<code>blog</code> 是文件夹名，你也可以任取其他的名字，并等待安装完成。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog </span><br></pre></td></tr></table></figure><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101035051.png" alt="image-20230328162135133"></p><p>##安装依赖</p><p> 键入下述指令来安装依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101035052.png" alt="image-20230328162210737"></p><h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><ol start="5"><li><p>完成上述工作后博客搭建就完成了，可以输入 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo serve</span><br></pre></td></tr></table></figure><p> 获取连接来尝试访问博客：</p></li></ol><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101035053.png" alt="image-20230328162247268"></p><p>页面如下：</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101035054.png" alt="image-20230328162303724"></p><h2 id="快速搭建Hexo模板"><a href="#快速搭建Hexo模板" class="headerlink" title="快速搭建Hexo模板"></a>快速搭建Hexo模板</h2><p>自动搭建基于 butterfly 主题的 Hexo 博客模板</p><ol><li>安装</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-butterfly-cli -g</span><br></pre></td></tr></table></figure><ol start="2"><li>使用</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">butterfly-cli init &lt;projectname&gt;</span><br></pre></td></tr></table></figure><p>projectname 可任意取名</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101035055.png" alt="image-20230328164512466"></p><p>在这里选择一个模式，默认的模式构建的页面如下：</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101035056.png" alt="image-20230328164533029"></p><p>选择自定义模式，可以自定义一些内容：</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101035057.png" alt="image-20230328165158402"></p><p>效果如下：</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101035058.png" alt="image-20230328165231314"></p><h2 id="将博客发布到-GitHub-上"><a href="#将博客发布到-GitHub-上" class="headerlink" title="将博客发布到 GitHub 上"></a>将博客发布到 GitHub 上</h2><p>###创建仓库</p><ol><li>在 GitHub 创建一个仓库，设置名称。</li></ol><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101035059.png" alt="image-20230328211322974"></p><h3 id="配置Git信息"><a href="#配置Git信息" class="headerlink" title="配置Git信息"></a>配置Git信息</h3><ol><li>在终端输入：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;username&quot; //这里的username最好与github用户名一致。</span><br><span class="line">git config --global email &quot;youremail&quot; // youremail指的是github注册的邮箱账号</span><br></pre></td></tr></table></figure><ol start="2"><li><p>使用 vs 打开已经完成初始化的博客文件夹 blog ，选择 config.yml 文件，拉到最底下有一个 deploy ：</p><p>键入：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span></span><br><span class="line"><span class="attr">repo:</span> <span class="string">&#x27;address&#x27;</span> <span class="comment">#这个地址指的是你在GitHub上创建的仓库后它给你的地址</span></span><br><span class="line"><span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注意冒号” ：”后面有一个空格</p></blockquote><p>​例：</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101035060.png" alt="s"></p><h3 id="上传-GitHub"><a href="#上传-GitHub" class="headerlink" title="上传 GitHub"></a>上传 GitHub</h3><ol><li>安装部署插件</li></ol><p>在终端指定对应 blog 目录下键入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ol start="2"><li><p>将代码上传到 GitHub</p><ol><li><p>清理缓存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure></li><li><p>生成文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure></li><li><p>上传github</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="在GitHub上打开博客"><a href="#在GitHub上打开博客" class="headerlink" title="在GitHub上打开博客"></a>在GitHub上打开博客</h3><p>​可直接通过 GitHub Page 打开页面</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101035061.png" alt="image-20230328212922263"></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li>在键入 hexo d 后终端显示一行，并没有完成上传GitHub</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">validating config</span><br></pre></td></tr></table></figure><p>解决方案：</p><p>​检查 config.yml 文件内容，我出现该问题的原因是在冒号处未加空格：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span> <span class="comment">#不是 type:&#x27;git&#x27;</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">&#x27;https://github.com/FangMoyu/Shirly.github.io.git&#x27;</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><ol start="2"><li>打开页面后发现仅显示 HTML ，并未正确展示 CSS 和 js</li></ol><p>解决方案：</p><p>​我的情况是由于 config.yml 文件中的 url 和 root 的地址错误导致的，对于错误页面按 F12 并刷新后发现错误请求返回404，发现其与正确请求的 url 相比多了一个Shirly.github.io 的地址，因此修改 config.yml 中的 url  和 root 解决：</p><p>root 填写你的仓库名，url 填写前缀。</p><p>之前错误的把 url 地址写成了 ‘<a href="https://github.com/FangMoyu/Shirly.github.io'%EF%BC%8C%E4%BD%BF%E5%85%B6%E5%8A%A0%E4%B8%8A">https://github.com/FangMoyu/Shirly.github.io&#39;，使其加上</a> root 后导致的 url 错误。</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101035062.png" alt="image-20230328213231059"></p><ol start="3"><li>将修改的新内容发布到 Github 上时发现出现了如下的问题：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fatal: unable to access &#x27;https://github.com/FangMoyu/Shirly.github.io.git/&#x27;: Recv failure: Connection </span><br><span class="line">FATAL &#123;</span><br><span class="line">  err: Error: Spawn failed</span><br><span class="line">      at ChildProcess.&lt;anonymous&gt; (D:\Fang\我的博客\blog\node_modules\hexo-util\lib\spawn.js:51:21)   </span><br><span class="line">      at ChildProcess.emit (node:events:513:28)</span><br><span class="line">      at cp.emit (D:\Fang\我的博客\blog\node_modules\cross-spawn\lib\enoent.js:34:29)</span><br><span class="line">      at ChildProcess._handle.onexit (node:internal/child_process:291:12) &#123;</span><br><span class="line">    code: 128</span><br></pre></td></tr></table></figure><p>该问题大多是因为git进行push或者hexo d的时候改变了一些.deploy_git文件下的内容</p><p>解决方案一：</p><ol><li>删除 <code>.deploy_git</code> 文件夹;</li><li>输入 <code>git config --global core.autocrlf false</code></li><li>执行：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>解决方案二：</p><ol><li>进入hexo根目录</li><li>2.直接把箭头指向的<code>.deploy_git</code>和<code>public</code>直接删除！</li><li>执行</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>接口 API 开放平台笔记</title>
      <link href="/Shirly.github.io/2024/03/04/%E5%B0%8F%E6%96%B9%E7%9A%84%E9%A1%B9%E7%9B%AE/%E6%8E%A5%E5%8F%A3API%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0/"/>
      <url>/Shirly.github.io/2024/03/04/%E5%B0%8F%E6%96%B9%E7%9A%84%E9%A1%B9%E7%9B%AE/%E6%8E%A5%E5%8F%A3API%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="接口API开放平台第一期"><a href="#接口API开放平台第一期" class="headerlink" title="接口API开放平台第一期"></a>接口API开放平台第一期</h1><p>背景：</p><ol><li>前端开发需要用到后台接口</li><li>使用现成的系统的功能（<a href="http://api.btstu.cn/%EF%BC%89">http://api.btstu.cn/）</a></li></ol><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>一个提供API接口调用的平台，用户可以注册登录，开通接口调用权限。用户可以使用接口，并且每次调用会进行统计。管理员可以发布接口、下线接口、接入接口，可视化接口的调用情况，数据分析。</p><p>可能的功能：</p><ol><li>防止攻击</li><li>不能被随便调用</li><li>统计调用次数</li><li>计费</li><li>流量保护</li><li>API接入</li></ol><h2 id="项目框架"><a href="#项目框架" class="headerlink" title="项目框架"></a>项目框架</h2><p><img src="/Shirly.github.io/%E6%8E%A5%E5%8F%A3API%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0.assets/image-20231009201849653.png" alt="image-20231009201849653"></p><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>Ant Design Pro</p><p>React </p><p>Ant Design Procomponents</p><p>Umi</p><p>Umi Request (Axios 的封装)</p><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>Java Spring Boot</p><p>Spring Boot Starter (SDK 开发)</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>背景：</p><ol><li>前端开发需要用到后台接口</li><li>使用现成的系统的功能（<a href="http://api.btstu.cn/%EF%BC%89">http://api.btstu.cn/）</a></li></ol><p>做一个 API 接口平台：</p><ol><li>管理员可以对接口信息进行增删改查</li><li>用户可以访问前台，查看接口信息</li></ol><h2 id="前端项目构建"><a href="#前端项目构建" class="headerlink" title="前端项目构建"></a>前端项目构建</h2><p>百度 Ant Design Pro,并根据文档安装Ant Design Pro 脚手架</p><p><a href="https://pro.ant.design/zh-CN/docs/getting-started">开始使用 - Ant Design Pro</a></p><p>按照案例，正常启动一下项目。显示正常即可。</p><h3 id="前端项目瘦身"><a href="#前端项目瘦身" class="headerlink" title="前端项目瘦身"></a>前端项目瘦身</h3><p>脚手架中的代码有些是没必要的，因此可以将它们删除。</p><ol><li>e2e文件夹，这是一个端对端的功能</li><li>locales 国际化功能（在package中寻找i18n-remove命令，直接执行即可删除。最后还得手动删除文件夹）</li><li>.husky 项目检测功能，可删可不删，先不删。</li><li>test目录</li><li>playwright.config</li></ol><p>src目录</p><ol><li>e2e目录</li></ol><p>删除完之后，重新执行yarn  or npm run install 安装依赖，然后再启动项目确定是否没有问题。</p><h3 id="后端项目构建"><a href="#后端项目构建" class="headerlink" title="后端项目构建"></a>后端项目构建</h3><p>使用星球的后台初始化项目Spring Boot init <a href="http://gitlab.code-nav.cn/root/springboot-init-old">1-鱼皮 &#x2F; springboot-init-old · GitLab (code-nav.cn)</a></p><p>下载好之后，配置好数据库以及redis，然后直接启动即可。</p><h2 id="数据库表设计"><a href="#数据库表设计" class="headerlink" title="数据库表设计"></a>数据库表设计</h2><h3 id="接口信息表"><a href="#接口信息表" class="headerlink" title="接口信息表"></a>接口信息表</h3><p>id</p><p>name 接口名称</p><p>description 描述</p><p>url 接口地址</p><p>type 请求类型</p><p>requestHeader 请求头</p><p>responseHeader 响应头</p><p>method</p><p>status 状态</p><p>createTime</p><p>updateTime</p><p>isDelete</p><p>根据视频的类型，去Sql father里直接一键生成。</p><p>将生成好的SQL语句在项目中新建一个db文件，然后复制进去执行。</p><h2 id="项目脚手架"><a href="#项目脚手架" class="headerlink" title="项目脚手架"></a>项目脚手架</h2><h3 id="前端项目脚手架"><a href="#前端项目脚手架" class="headerlink" title="前端项目脚手架"></a>前端项目脚手架</h3><p>ant design pro</p><h3 id="后端脚手架"><a href="#后端脚手架" class="headerlink" title="后端脚手架"></a>后端脚手架</h3><p>星球Spring Boot 代码模块</p><h1 id="学习点"><a href="#学习点" class="headerlink" title="学习点"></a>学习点</h1><h2 id="1-openAPI-自动生成前端接口"><a href="#1-openAPI-自动生成前端接口" class="headerlink" title="1. openAPI 自动生成前端接口"></a>1. openAPI 自动生成前端接口</h2><h3 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h3><p>增删改查、登录等功能，可以直接自动生成</p><p>前端接口调用 oneapi 插件自动生成</p><p>在后端项目中若使用了 swagger ，后端项目就遵循了 openapi 规范，就可以将其 openapi 的代码全部复制到前端项目中</p><p>下图展示了openapi的代码显示结果：</p><p><img src="/Shirly.github.io/%E6%8E%A5%E5%8F%A3API%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0.assets/image-20231010190314331.png" alt="image-20231010190314331"></p><p>打开前端项目中的config.ts文件，找到 openAPI 插件，修改一下项目名为 yuapibackend，并将其中的 schemaPath 改为上图中的 openAPI 代码的地址即可使用。</p><p><img src="/Shirly.github.io/%E6%8E%A5%E5%8F%A3API%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0.assets/image-20231010190354587.png" alt="image-20231010190354587"></p><p>随后我们就可以直接去 package.json 中执行 openapi 的脚本，如果成功完成，就会在 services 目录下找到自动生成的接口。</p><p><img src="/Shirly.github.io/%E6%8E%A5%E5%8F%A3API%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0.assets/image-20231010190810330.png" alt="image-20231010190810330"></p><p>如果未来，我们修改了后端的参数名称，或者添加了参数，前端也可以直接使用 openapi 进行更新，就不需要全部修改了。</p><p>openapi 规范：</p><h2 id="2-全局变量保存"><a href="#2-全局变量保存" class="headerlink" title="2. 全局变量保存"></a>2. 全局变量保存</h2><p>​在登录时，前端脚手架会检查用户登录状态，前端为了能够保持一个全局变量，之前的项目中知道可以使用 vuex、localstorage，sessionstorage 等。我们可以在 app.tsx 里看到前端会对用户登录的全局状态进行检查。</p><p><img src="/Shirly.github.io/%E6%8E%A5%E5%8F%A3API%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0.assets/image-20231010193114943.png" alt="image-20231010193114943"></p><h3 id="自定义全局变量"><a href="#自定义全局变量" class="headerlink" title="自定义全局变量"></a>自定义全局变量</h3><p>​由上面可以知道，我们可以通过自定义全局状态类型来实现存储全局状态变量</p><p>在 typings.d.ts 中，定义一个 interface，叫做 InitialState，然后参数选择我们的登录用户：</p><p><img src="/Shirly.github.io/%E6%8E%A5%E5%8F%A3API%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0.assets/image-20231010193235315.png" alt="image-20231010193235315"></p><p>然后在 app.tsx 中将其中的参数改为 InitialState</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>智能 BI 项目实现记录</title>
      <link href="/Shirly.github.io/2024/03/04/%E5%B0%8F%E6%96%B9%E7%9A%84%E9%A1%B9%E7%9B%AE/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE/"/>
      <url>/Shirly.github.io/2024/03/04/%E5%B0%8F%E6%96%B9%E7%9A%84%E9%A1%B9%E7%9B%AE/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="智能-BI-项目"><a href="#智能-BI-项目" class="headerlink" title="智能 BI 项目"></a>智能 BI 项目</h1><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><h3 id="BI-平台是什么？"><a href="#BI-平台是什么？" class="headerlink" title="BI 平台是什么？"></a>BI 平台是什么？</h3><p>BI 商业智能：数据可视化、报表可视化系统</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240207195639888.png" alt="image-20240207195639888"></p><p>主流 BI 平台：帆软 BI 、小马 BI 、微软 Power BI </p><p>传统 BI 平台：<a href="https://chartcube.alipay.com/">ChartCube - 在线图表制作工具 (alipay.com)</a></p><ol><li>需要人工上传数据</li><li>需要人工拖选分析要用到的数据行和列</li><li>需要人工选择图表类型</li></ol><p>智能 BI 平台：</p><p>区别于传统的 BI ，用户只需要导入最原始的数据集，输入想要进行分析的目标（比如分析一下网站的增长趋势），就能利用 AI 自动生成一个符合要求的图表以及结论</p><p>优点：让不会数据分析的同学也能输入目标快速完成数据分析，大幅节约人力成本。</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li>智能分析：用户输入目标和原始数据，可以自动生成图表和分析结论。</li><li>图表管理</li><li>图表生成的异步化（消息队列）</li></ol><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p>客户端通过输入分析诉求、原始数据给业务后端，业务后端通过调用 AI 服务， AI 服务生成图表和分析结果发送给业务后端，处理用户数据，如果图表和分析结果需要被保存，则可以将其存储在数据库中。</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240210145736425.png" alt="image-20240210145736425"></p><p><strong>优化流程：</strong></p><p>但是要考虑一个情况，当前的用户量如果较大，都去调用 AI 生成报表，那么对于 AI 服务来说压力过大，AI 服务会不堪重负，这里通过一个消息队列，当用户发送一个请求，会先将请求发送到消息队列中，消息队列会实时判断 AI 服务的调用状态，如果 AI 服务的调用情况良好，它就会去调用任务处理模块来调用 AI 服务。</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240207203903342.png" alt="image-20240207203903342"></p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ol><li>React</li><li>Umi + Ant Design Pro</li><li>可视化库 （Echarts + HighCharts + AntV）</li><li>umi openapi 代码生成 （自动生成后端调用代码）</li></ol><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><ol><li>Spring Boot (万用 Java 后端项目模版，快速搭建基础框架，避免重复写代码)</li><li>MySQL 数据库</li><li>Mybatis Plus 数据访问框架</li><li>消息队列 （RabbitMQ）</li><li>AI 能力 （ OpenAI 接口开发）</li><li>Excel 的上传和数据的解析</li><li>Swagger + Knife4j 项目接口文档</li><li>Hutools 工具库</li></ol><h2 id="项目计划"><a href="#项目计划" class="headerlink" title="项目计划"></a>项目计划</h2><p><strong>第一期</strong></p><p>前端项目初始化</p><p>后端项目初始化</p><p>前端开发</p><ul><li>快速开发登录功能</li><li>图表分析页面的开发</li><li>图表管理的开发</li></ul><p>后端开发</p><ul><li>库表设计</li><li>图表管理开发</li><li>文件上传接口开发</li></ul><p>前后端业务流程跑通。</p><h2 id="前端项目初始化"><a href="#前端项目初始化" class="headerlink" title="前端项目初始化"></a>前端项目初始化</h2><p>项目安装依赖过程中如果出现 node 版本不匹配的问题，可以通过直接去官网更新，或者采用：</p><p>nvm 可以自由切换 node 的版本。</p><ol><li>按照官方文档初始化</li><li>项目试运行</li><li>代码托管（方便还原）</li><li>移除不必要的能力 （比如国际化）</li></ol><h2 id="脚手架项目-bug-解决方案"><a href="#脚手架项目-bug-解决方案" class="headerlink" title="脚手架项目 bug 解决方案"></a>脚手架项目 bug 解决方案</h2><p>项目配置的 bug ，比如删除国际化的时候，报下图错误：</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240208103902221.png" alt="image-20240208103902221"></p><p>可以尝试去官方 github 下的 issue 下去查找解决方案：</p><p><a href="https://github.com/ant-design/ant-design-pro">ant-design&#x2F;ant-design-pro: 👨🏻‍💻👩🏻‍💻 Use Ant Design like a Pro! (github.com)</a></p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240208104101917.png" alt="image-20240208104101917"></p><p>路由不显示名称：</p><p>要想让页面的导航栏显示要跳转的页面，可以给路由设置一个 name 属性。</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240208105459994.png" alt="image-20240208105459994"></p><h2 id="后端项目初始化"><a href="#后端项目初始化" class="headerlink" title="后端项目初始化"></a>后端项目初始化</h2><p>使用 Spring Boot 万用后端项目模版</p><h2 id="bug-解决"><a href="#bug-解决" class="headerlink" title="bug 解决"></a>bug 解决</h2><p>出现项目端口被占用的情况</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240208111348570.png" alt="image-20240208111348570"></p><p>可能是开启了 Hyper - V ，一个 Windows 10 上的虚拟机功能：</p><p><a href="https://learn.microsoft.com/zh-cn/virtualization/hyper-v-on-windows/about/">Windows 10 上的 Hyper-V 简介 | Microsoft Learn</a></p><h2 id="库表设计"><a href="#库表设计" class="headerlink" title="库表设计"></a>库表设计</h2><p><strong>图表表 ： chart</strong></p><p>id 采用雪花算法产生的随机 id </p><p>userId 创建图表的用户 id</p><p>goal ：分析目标 text</p><p>chartData ： 图标数据 text</p><p>chartType ： 图标类型</p><p>genChart ：text 生成的图标数据</p><p>genResult  text 生成的分析结论</p><p>createTime </p><p>updateTime</p><p>isDelete</p><p>用 @TableId 注解的属性 idType 来设置 id 字段的值为随机数，确保用户 id 的安全性：</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240208141332794.png" alt="image-20240208141332794"></p><p><a href="https://baomidou.com/pages/223848/#idtype">注解 | MyBatis-Plus (baomidou.com)</a></p><h2 id="前端调用后端"><a href="#前端调用后端" class="headerlink" title="前端调用后端"></a>前端调用后端</h2><p>前端更改对应的请求路径地址：在 app.tsx 里修改 request. baseURL</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240208143821395.png" alt="image-20240208143821395"></p><h1 id="第二期"><a href="#第二期" class="headerlink" title="第二期"></a>第二期</h1><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ol><li>前置准备</li><li>开发登录、注册页面</li><li>学习使用 AI 生成 BI 图表的完整流程（梳理功能点和工作）</li><li>开发智能分析功能<ul><li>文件上传（前后端）</li><li>Excel 处理</li></ul></li><li>图表管理功能</li></ol><blockquote><p>项目的开发需要提前先写出项目的核心步骤、流程，便于后续的具体开发。</p></blockquote><h2 id="继续初始化项目"><a href="#继续初始化项目" class="headerlink" title="继续初始化项目"></a>继续初始化项目</h2><h3 id="后端启动项目端口冲突问题解决："><a href="#后端启动项目端口冲突问题解决：" class="headerlink" title="后端启动项目端口冲突问题解决："></a>后端启动项目端口冲突问题解决：</h3><p>原因： Windows Hyper-V 虚拟化平台占用了端口。</p><p><strong>方案一</strong></p><ol><li>查询哪些端口号被占用了：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface ipv4 show excludedportrange protocol=tcp</span><br></pre></td></tr></table></figure><ol start="2"><li>启动项目时，避开这些端口：</li></ol><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240208222009951.png" alt="image-20240208222009951"></p><p><strong>方案二</strong></p><p>禁用 Hype-V</p><h2 id="前端项目初始化-1"><a href="#前端项目初始化-1" class="headerlink" title="前端项目初始化"></a>前端项目初始化</h2><ol><li>修改端口</li><li>删除 mock 数据</li><li>修改 favicon.ico 替换 Logo，这个是网站上的图标，通过网上的在线 png 转 favicon.ico 转换器 ，你可以用自己的图片，去生成自己想要的 favicon.ico。</li><li>删除国际化 locales 目录</li><li>删除 test 测试相关目录</li><li>mainfest.json 文件是用来开发 app 的时候，指定不同的配置，可以删除。</li><li>prettier、eslint、editorConfig、stylelint ，想要开启 prettier 美化配置</li><li>替换标题名称 通过 ctrl + shift + r 全局替换所有的 Ant Design Pro 和 Ant Design 为 智能 BI</li></ol><h3 id="开发登录注册页面"><a href="#开发登录注册页面" class="headerlink" title="开发登录注册页面"></a>开发登录注册页面</h3><p>先删掉不需要的，再根据后端去做调整。</p><p>如果出现 Cookie 没有发送给后端，就按照之前两个项目的方法解决。</p><p>统一去 RequestConfig 下去做配置。</p><h3 id="智能分析业务开发"><a href="#智能分析业务开发" class="headerlink" title="智能分析业务开发"></a>智能分析业务开发</h3><h4 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h4><ol><li><p>用户输入</p><p>a . 分析目标</p><p>b . 上传原始数据 （excel）</p><p>c . 更精细化地控制图表，比如图表类型、图表名称等</p></li><li><p>后端校验</p><p>a . 校验用户的输入是否合法</p><p>b . 成本控制（次数统计和校验、鉴权）</p></li><li><p>把处理后的数据输入给 AI 模型 （调用 AI 接口）</p></li><li><p>图表信息、结论文本在前端进行展示</p></li></ol><h4 id="开发接口"><a href="#开发接口" class="headerlink" title="开发接口"></a>开发接口</h4><p>根据用户输入的文本和文件，最后返回图表信息和结论文本</p><p>给 chart 表补充 name 字段</p><h2 id="AI-提词小技巧"><a href="#AI-提词小技巧" class="headerlink" title="AI 提词小技巧"></a>AI 提词小技巧</h2><p><strong>原始数据压缩</strong></p><p>AI 接口普遍都有输入字数限制，尽可能压缩数据，能够允许多传一些数据。</p><p>如何向 AI 提词 ？</p><p>AI 提词技巧 1：<strong>持续输入，持续优化</strong></p><p>AI 提词技巧 2 ： <strong>数据压缩 <strong>（内容压缩：比如把很长的内容提取关键词，</strong>关键词也可以让 AI 来做</strong>。）</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240209234022920.png" alt="image-20240209234022920"></p><h2 id="文件上传请求"><a href="#文件上传请求" class="headerlink" title="文件上传请求"></a>文件上传请求</h2><p>利用 @RequestPart 去实现文件上传</p><p><a href="https://blog.csdn.net/yhj198927/article/details/135750505?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-135750505-blog-79727061.235%5Ev43%5Epc_blog_bottom_relevance_base8&spm=1001.2101.3001.4242.1&utm_relevant_index=3">@RequestPart 和@RequestParam的区别_requestparam 和 requestpart-CSDN博客</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestPart(&quot;file&quot;)</span> MultipartFile</span><br></pre></td></tr></table></figure><p>用上述注解即可实现文件上传。</p><h2 id="EasyExcel-读取数据并按照顺序返回"><a href="#EasyExcel-读取数据并按照顺序返回" class="headerlink" title="EasyExcel 读取数据并按照顺序返回"></a>EasyExcel 读取数据并按照顺序返回</h2><p>EasyExcel 读取 Excel 文件返回的结果是一个 List ，而这个 List 中的元素是 Excel 文件中每一行的数据，我们可以通过 List.get( i ) 去获取第 i 行数据。</p><p>获取某一行的结果是一个 Map，它的键是从 0 开始的，一个键对应该行的一个单元格的值，并且如果 Excel 文件并未完全清理脏数据，可能会出现值为 null 的情况。 </p><p>而默认的 HashMap 是无序的，所以我们如果需要按照表格原来的顺序返回，就需要通过 LionkedHashMap 来实现：<img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240210102514007.png" alt="image-20240210102514007"></p><p><strong>过滤其中为空的值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">headerMap.values().stream().filter(ObjectUtils::isNotEmpty).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240210102802031.png" alt="image-20240210102802031"></p><h2 id="调用-AI"><a href="#调用-AI" class="headerlink" title="调用 AI"></a>调用 AI</h2><p>AI 需要一个预设，便于更加精准地得到我们需要的结果。</p><p>比如你去给一个调整了推荐歌曲预设的 ai 发送歌手，它就会根据这个歌手推荐他的歌曲，而如果你给其他的 ai 发送相同名字的歌手，那么 ai 可能返回的是歌手的信息：</p><p><strong>预设过的 ai：</strong></p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240210104333578.png" alt="image-20240210104333578"></p><p><strong>其他 ai：</strong></p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240210104320251.png" alt="image-20240210104320251"></p><p>输入：</p><p>系统预设（提前告诉它职责、功能、回复格式要求） + 分析目标 + 压缩后的数据</p><p>由于 openAi 是一个无状态的系统，如果需要保留之前发送的信息，需要将整个信息打包，一起发送给 openAI</p><p>最简单的系统预设：</p><ul><li>你是一个数据分析师，接下来我会给你我的分析目标和原始数据，请给我分析结论。</li></ul><p>可以从下图中看出来，没有预设下得出的结果是不一样的：</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240210104925032.png" alt="image-20240210104925032"></p><h2 id="启动后端模板"><a href="#启动后端模板" class="headerlink" title="启动后端模板"></a>启动后端模板</h2><p>使用鱼皮的新版后端模板：</p><p><a href="https://wx.zsxq.com/dweb2/index/topic_detail/212528442245281">知识星球 | 深度连接铁杆粉丝，运营高品质社群，知识变现的工具 (zsxq.com)</a></p><p>配置相应的 Redis 和本地数据库信息之后，启动项目，访问项目接口文档地址：</p><p><a href="http://localhost:8101/api/doc.html#/home">接口文档</a></p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240210182633582.png" alt="image-20240210182633582"></p><h3 id="后端项目模板学习"><a href="#后端项目模板学习" class="headerlink" title="后端项目模板学习"></a>后端项目模板学习</h3><p><strong>自定义注解</strong></p><p><a href="https://zhuanlan.zhihu.com/p/364505627">自定义注解 详细解释以及使用 - 知乎 (zhihu.com)</a></p><p>通过自定义注解，实现用户必须满足某种角色才能访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span> <span class="comment">// 注解的范围</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 注解的生命周期</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AuthCheck &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 必须有某个角色</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">mustRole</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 AOP 切面，让所有被加上了上述注解的方法都会执行下面的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行拦截</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> authCheck</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(authCheck)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">doInterceptor</span><span class="params">(ProceedingJoinPoint joinPoint, AuthCheck authCheck)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">mustRole</span> <span class="operator">=</span> authCheck.mustRole();</span><br><span class="line">        <span class="type">RequestAttributes</span> <span class="variable">requestAttributes</span> <span class="operator">=</span> RequestContextHolder.currentRequestAttributes();</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> ((ServletRequestAttributes) requestAttributes).getRequest();</span><br><span class="line">        <span class="comment">// 当前登录用户</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">loginUser</span> <span class="operator">=</span> userService.getLoginUser(request);</span><br><span class="line">        <span class="comment">// 必须有该权限才通过</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(mustRole)) &#123;</span><br><span class="line">            <span class="type">UserRoleEnum</span> <span class="variable">mustUserRoleEnum</span> <span class="operator">=</span> UserRoleEnum.getEnumByValue(mustRole);</span><br><span class="line">            <span class="keyword">if</span> (mustUserRoleEnum == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.NO_AUTH_ERROR);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">userRole</span> <span class="operator">=</span> loginUser.getUserRole();</span><br><span class="line">            <span class="comment">// 如果被封号，直接拒绝</span></span><br><span class="line">            <span class="keyword">if</span> (UserRoleEnum.BAN.equals(mustUserRoleEnum)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.NO_AUTH_ERROR);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 必须有管理员权限</span></span><br><span class="line">            <span class="keyword">if</span> (UserRoleEnum.ADMIN.equals(mustUserRoleEnum)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mustRole.equals(userRole)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.NO_AUTH_ERROR);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过权限校验，放行</span></span><br><span class="line">        <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>定义工具类方便开发</strong></p><p>之前的项目中需要校验条件抛出的异常很多，可以通过编写一个统一的抛出异常工具类来统一实现校验和执行抛出异常操作，让代码更加优雅。</p><p><strong>实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抛异常工具类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航知识星球&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThrowUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 条件成立则抛异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> condition</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> runtimeException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">throwIf</span><span class="params">(<span class="type">boolean</span> condition, RuntimeException runtimeException)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">            <span class="keyword">throw</span> runtimeException;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 条件成立则抛异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> condition</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> errorCode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">throwIf</span><span class="params">(<span class="type">boolean</span> condition, ErrorCode errorCode)</span> &#123;</span><br><span class="line">        throwIf(condition, <span class="keyword">new</span> <span class="title class_">BusinessException</span>(errorCode));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 条件成立则抛异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> condition</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> errorCode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">throwIf</span><span class="params">(<span class="type">boolean</span> condition, ErrorCode errorCode, String message)</span> &#123;</span><br><span class="line">        throwIf(condition, <span class="keyword">new</span> <span class="title class_">BusinessException</span>(errorCode, message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一旦目标为空，就直接抛出异常。无法根据空目标产生内容</span></span><br><span class="line">ThrowUtils.throwIf(StringUtils.isBlank(goal),ErrorCode.PARAMS_ERROR,<span class="string">&quot;目标为空&quot;</span>);</span><br><span class="line"><span class="comment">// 如果名称不为空，并且名称长度大于100，就抛出异常，并给出提示</span></span><br><span class="line">ThrowUtils.throwIf(StringUtils.isNotBlank(name) &amp;&amp; name.length() &gt; <span class="number">100</span>, ErrorCode.PARAMS_ERROR, <span class="string">&quot;名称过长&quot;</span>);</span><br></pre></td></tr></table></figure><p>同理可以根据这种思路定义更多的工具类便于开发</p><h2 id="Excel-实现读取数据"><a href="#Excel-实现读取数据" class="headerlink" title="Excel 实现读取数据"></a>Excel 实现读取数据</h2><p><strong>同步读</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步读，不用写监听器</span></span><br><span class="line">List&lt;Map&lt;Integer, String&gt;&gt; list = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    list = EasyExcel.read(multipartFile.getInputStream())</span><br><span class="line">            .excelType(ExcelTypeEnum.XLSX)</span><br><span class="line">            .sheet()</span><br><span class="line">            .headRowNumber(<span class="number">0</span>)</span><br><span class="line">            .doReadSync();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;表格处理错误&quot;</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取表头以及真实数据：</p><p>利用 Stream 流，实现读取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取表头(第一行)</span></span><br><span class="line">LinkedHashMap&lt;Integer, String&gt; headerMap =(LinkedHashMap&lt;Integer, String&gt;) list.get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 过滤出其中不为空的内容</span></span><br><span class="line">List&lt;String&gt; headerList = headerMap.values().stream().filter(ObjectUtils::isNotEmpty).collect(Collectors.toList());</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">stringBuilder.append(StringUtils.join(headerList,<span class="string">&quot;,&quot;</span>)).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="comment">// 将真实数据过滤空值后输出。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">    Map&lt;Integer, String&gt; dataMap = list.get(i);</span><br><span class="line">    List&lt;String&gt; dataList = dataMap.values()</span><br><span class="line">            .stream()</span><br><span class="line">            .filter(ObjectUtils::isNotEmpty)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    stringBuilder.append(StringUtils.join(dataList,<span class="string">&quot;,&quot;</span>)).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第三期"><a href="#第三期" class="headerlink" title="第三期"></a>第三期</h1><p>计划：</p><ol><li>跑通整个智能分析功能的业务流程<ol><li>后端</li><li>前端</li></ol></li><li>开发图表管理功能</li><li>系统优化</li></ol><h3 id="生成图表"><a href="#生成图表" class="headerlink" title="生成图表"></a><strong>生成图表</strong></h3><p>我们的期望是让 AI 生成图表，但是 AI 无法直接生成现成的图表，但是可以生成图表代码 &#x3D; &gt; 可以把代码利用前端的组件库（echarts）在网页进行展示。</p><h4 id="给-AI-添加新的描述"><a href="#给-AI-添加新的描述" class="headerlink" title="给 AI 添加新的描述"></a>给 AI 添加新的描述</h4><p>通过上述的思路，我们可以给 AI 更多的描述来实现生成图表代码，然后将生成的代码用于我们的前端页面，但是直接按照如下提问：</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240212215510016.png" alt="image-20240212215510016"></p><p>生成的结果：</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240212215702701.png" alt="image-20240212215702701"></p><h4 id="通过预设实现更加细致的回答"><a href="#通过预设实现更加细致的回答" class="headerlink" title="通过预设实现更加细致的回答"></a>通过预设实现更加细致的回答</h4><p>显然 ，AI 生成了一段整个网页的代码，这不能直接插入到我们的项目前端代码中。</p><p>我们需要更加细致的加入预设来让 AI 生成的结果符合要求：</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240212220013833.png" alt="image-20240212220013833"></p><p>我们可以对 AI 进行更加细致的<strong>系统预设</strong>，让它知道应该回答什么内容之后，我们只需要通过简洁的提问，它可以生成按照我们需要的内容：</p><h3 id="AI-提问技巧"><a href="#AI-提问技巧" class="headerlink" title="AI 提问技巧"></a>AI 提问技巧</h3><p>如果想让 AI 更好地理解我们的输出，给我们预期的、精确格式的输出，我们就需要严格控制咋们的提问词。</p><ul><li>使用系统预设</li><li>控制输入格式（让 AI 更精确地理解我们的需求）</li></ul><p>比如：</p><p>你是一个数据分析师和前端开发专家，接下来我会按照以下固定格式给你提供内容：</p><p>分析需求：</p><p>（数据分析的需求或者目标）</p><p>原始数据：</p><p>{csv 格式的原始数据，用 , 作为分隔符}</p><p>请根据以上内容，帮我分析数据分析结论和可视化图表代码</p><ul><li>控制输出格式（让 AI 按照我们预期的结果返回）</li></ul><p>咋们先来看一下前端 echarts 的实例代码：</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240212220915561.png" alt="image-20240212220915561"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">option = &#123;</span><br><span class="line">  <span class="attr">xAxis</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;category&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: [<span class="string">&#x27;Mon&#x27;</span>, <span class="string">&#x27;Tue&#x27;</span>, <span class="string">&#x27;Wed&#x27;</span>, <span class="string">&#x27;Thu&#x27;</span>, <span class="string">&#x27;Fri&#x27;</span>, <span class="string">&#x27;Sat&#x27;</span>, <span class="string">&#x27;Sun&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">yAxis</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;value&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">series</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">data</span>: [<span class="number">150</span>, <span class="number">230</span>, <span class="number">224</span>, <span class="number">218</span>, <span class="number">135</span>, <span class="number">147</span>, <span class="number">260</span>],</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;line&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>继续完善提问</strong></p><p>你是一个数据分析师和前端开发专家，接下来我会按照以下固定格式给你提供内容：</p><p>分析需求：</p><p>（数据分析的需求或者目标）</p><p>原始数据：</p><p>{csv 格式的原始数据，用 , 作为分隔符}</p><p>请根据以上内容，帮我按照指定格式生成内容（此外不要输出多余的开头、结尾、注释等内容）</p><p>【【【【【</p><p>{前端 Echarts V5 的 option 配置对象 js 代码，合理地将数据进行可视化}</p><p>【【【【【</p><p>{图表的描述，以及明确的数据分析结论、越详细越好}</p><p>通过上述的提示词， AI 就会按照我们的格式返回结果了，但是也可能存在一些随机性，不一定绝对能按照我们的需要返回，如果仍然存在随机性，那么我们就需要更多地去优化提示词。</p><ul><li>直接指定一个示例回答，one-shot 或者 few-shot</li></ul><h3 id="Java三种调用-AI-的方式"><a href="#Java三种调用-AI-的方式" class="headerlink" title="Java三种调用 AI 的方式"></a>Java三种调用 AI 的方式</h3><ol><li>直接调用 OpenAI 或者其他 AI 原始大模型官网接口</li></ol><p>官网：</p><p><a href="https://platform.openai.com/docs/guides/text-generation/chat-completions-api">文本生成 - OpenAI API</a></p><p>优点：不经封装、最灵活、最原始</p><p>缺点：要钱、要魔法</p><h4 id="通过发送-HTTP-请求调用"><a href="#通过发送-HTTP-请求调用" class="headerlink" title="通过发送 HTTP 请求调用"></a>通过发送 HTTP 请求调用</h4><p>本质上 OpenAI 就是提供了 HTTP 接口，我们可以用任何语言去调用。</p><p>看官方文档的 curl 语言实现， curl 是一个用于请求 Web 服务器的命令行工具。</p><p><a href="https://platform.openai.com/docs/quickstart?context=curl">Text generation - OpenAI API</a></p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240212223855563.png" alt="image-20240212223855563"></p><p>可以看到，要调用 AI 只需要调用下图的地址，并在请求头中加入用户的密钥 API KEY，然后按照下图的请求体发送内容：</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240212223918833.png" alt="image-20240212223918833"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">curl https://api.openai.com/v1/chat/completions   -H &quot;Content-Type: application/json&quot;   -H &quot;Authorization: Bearer $OPENAI_API_KEY&quot;   -d &#x27;&#123;</span><br><span class="line">    &quot;model&quot;: &quot;gpt-3.5-turbo&quot;,</span><br><span class="line">    &quot;messages&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;role&quot;: &quot;system&quot;,</span><br><span class="line">        &quot;content&quot;: &quot;You are a poetic assistant, skilled in explaining complex programming concepts with creative flair.&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;role&quot;: &quot;user&quot;,</span><br><span class="line">        &quot;content&quot;: &quot;Compose a poem that explains the concept of recursion in programming.&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;&#x27;</span><br></pre></td></tr></table></figure><ol><li>在请求头中指定 OPENAI_API_KEY</li><li>找到你需要的 OpenAI 接口</li><li>使用 Java 的 HTTP 请求调用库去调用 OpenAI 的接口</li></ol><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240212224343475.png" alt="image-20240212224343475"></p><h4 id="2-使用云服务商提供的、封装后的-AI-接口"><a href="#2-使用云服务商提供的、封装后的-AI-接口" class="headerlink" title="2. 使用云服务商提供的、封装后的 AI 接口"></a>2. 使用云服务商提供的、封装后的 AI 接口</h4><p>比如 Azure 云</p><p>优点：本地都能用</p><p>缺点：依然要钱，而且可能比之前调用原始的接口更贵</p><h4 id="3-利用鱼聪明-AI-提供的开发-SDK"><a href="#3-利用鱼聪明-AI-提供的开发-SDK" class="headerlink" title="3. 利用鱼聪明 AI 提供的开发 SDK"></a>3. 利用鱼聪明 AI 提供的开发 SDK</h4><blockquote><p>这里值得学习一下这个 SDK 实现，利用了 API 开放平台的功能去做的。</p></blockquote><p>优点：目前不要钱。而且有很多线程的模型（prompt 系统预设）给大家用</p><p>缺点：不完全灵活，但是可以定义自己的模型</p><p><strong>使用鱼聪明 SDK ：</strong></p><p>下载安装 maven 依赖</p><p><a href="https://github.com/liyupi/yucongming-java-sdk">liyupi&#x2F;yucongming-java-sdk: 鱼聪明 AI 的 Java SDK，几行代码使用 AI 助手能力！ (github.com)</a></p><p>在 yml 配置文件中配置相应的 accessKey 和 SecretKey</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240214171602770.png" alt="image-20240214171602770"></p><p>选择鱼聪明上的某一个模型：</p><p>对应的模型 id 在链接上：</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240213192040888.png" alt="image-20240213192040888"></p><p>调用鱼聪明 ai java sdk 的方法，调用鱼聪明接口。</p><p>通过这种方式不需要自己提前在代码中去写相应的 prompt 去告诉 ai 需要返回的信息内容了。因为模型已经设定好了。</p><p>调用方法：</p><p><strong>初始化 YuCongMingClient 对象</strong></p><p>方法 1：自主 new 对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String accessKey = &quot;你的 accessKey&quot;;</span><br><span class="line">String secretKey = &quot;你的 secretKey&quot;;</span><br><span class="line">YuCongMingClient client = new YuCongMingClient(accessKey, secretKey);</span><br></pre></td></tr></table></figure><p>方法 2：通过配置注入对象</p><p>修改配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yuapi:</span><br><span class="line">  client:</span><br><span class="line">    access-key: 你的 access-key</span><br><span class="line">    secret-key: 你的 secret-key</span><br></pre></td></tr></table></figure><p>使用客户端对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Resource</span><br><span class="line">private YuCongMingClient client;</span><br></pre></td></tr></table></figure><h4 id="3、构造请求参数"><a href="#3、构造请求参数" class="headerlink" title="3、构造请求参数"></a>3、构造请求参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DevChatRequest devChatRequest = new DevChatRequest();</span><br><span class="line">devChatRequest.setModelId(1651468516836098050L);</span><br><span class="line">devChatRequest.setMessage(&quot;鱼皮&quot;);</span><br></pre></td></tr></table></figure><h4 id="4、获取响应结果"><a href="#4、获取响应结果" class="headerlink" title="4、获取响应结果"></a>4、获取响应结果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BaseResponse&lt;DevChatResponse&gt; response = client.doChat(devChatRequest);</span><br><span class="line">System.out.println(response.getData());</span><br></pre></td></tr></table></figure><h4 id="调用-AI-1"><a href="#调用-AI-1" class="headerlink" title="调用 AI"></a>调用 AI</h4><p>使用 SDK 调用鱼聪明的方法可以抽象成一个方法，因此可以选择新建一个类，用来编写一些调用 AI 接口的方法。</p><p>然后封装一个 AI <strong>返回结果 BiResponse</strong>，因为模型的返回结果已经被我们提前定义好了，因此不用担心 AI 会返回一些不符合条件的回答。</p><p>BiResponse 要有两个字段：</p><ol><li>genChart</li><li>genResult</li></ol><p>分别是生成的图表和生成的结果</p><p>用户会发送一些需求 goal 和 图表类型 chartType ，可以将其加入到用户输入的内容中来确保用户的输入得到正确的结果。</p><p>生成数据后，将对应的图表插入到数据库中：</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240213194905712.png" alt="image-20240213194905712"></p><h4 id="小插曲：研究鱼皮的鱼聪明-SDK"><a href="#小插曲：研究鱼皮的鱼聪明-SDK" class="headerlink" title="小插曲：研究鱼皮的鱼聪明 SDK"></a>小插曲：研究鱼皮的鱼聪明 SDK</h4><p>基本是和 API 项目类似的，先来看一下它的配置实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;yuapi.client&quot;)</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YuCongMingClientConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String accessKey;</span><br><span class="line">    <span class="keyword">private</span> String secretKey;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> YuCongMingClient <span class="title function_">yuApiClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">YuCongMingClient</span>(<span class="built_in">this</span>.accessKey, <span class="built_in">this</span>.secretKey);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>非常简单的配置实现，就是通过组件扫描和注解实现对 accessKey 和 secretKey 的配置，同时它会将一个 yuApiClient 对象存储在 IOC 容器中管理，并将用户在 yml 绑定的 accessKey 和 secretKey 作为属性绑定在这个对象中。</p><p>配置好之后，我们会通过调用 IOC 容器中的 yuCongMingClient 对象，调用其 doChat 方法来向鱼聪明 AI 发送请求。</p><p>这里我们来看一下这个 doChat 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BaseResponse&lt;DevChatResponse&gt; <span class="title function_">doChat</span><span class="params">(DevChatRequest devChatRequest)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://www.yucongming.com/api/dev/chat&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSONUtil.toJsonStr(devChatRequest);</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> ((HttpRequest)HttpRequest.post(url).addHeaders(<span class="built_in">this</span>.getHeaderMap(json))).body(json).execute().body();</span><br><span class="line">    TypeReference&lt;BaseResponse&lt;DevChatResponse&gt;&gt; typeRef = <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;BaseResponse&lt;DevChatResponse&gt;&gt;() &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> (BaseResponse)JSONUtil.toBean(result, typeRef, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是一顿 HTTP 请求实现调用接口。</p><p>其对应的加密方法也是和 API 项目一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, String&gt; <span class="title function_">getHeaderMap</span><span class="params">(String body)</span> &#123;</span><br><span class="line">    Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    hashMap.put(<span class="string">&quot;accessKey&quot;</span>, <span class="built_in">this</span>.accessKey);</span><br><span class="line">    hashMap.put(<span class="string">&quot;nonce&quot;</span>, RandomUtil.randomNumbers(<span class="number">4</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">encodedBody</span> <span class="operator">=</span> SecureUtil.md5(body);</span><br><span class="line">    hashMap.put(<span class="string">&quot;body&quot;</span>, encodedBody);</span><br><span class="line">    hashMap.put(<span class="string">&quot;timestamp&quot;</span>, String.valueOf(System.currentTimeMillis() / <span class="number">1000L</span>));</span><br><span class="line">    hashMap.put(<span class="string">&quot;sign&quot;</span>, SignUtils.genSign(encodedBody, <span class="built_in">this</span>.secretKey));</span><br><span class="line">    <span class="keyword">return</span> hashMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DevChatRequest 对象的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DevChatRequest</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long modelId;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>需要确定一个 modelId ，即调用的模型 id，和用户的需求 message。</p><p>将该对象放入到 doChat 方法的参数中，即可对相应的模型进行对话</p><p>message 信息提供：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">分析需求：</span><br><span class="line">分析网站用户的增长情况</span><br><span class="line">原始数据：</span><br><span class="line">日期,用户数</span><br><span class="line">1号,10</span><br><span class="line">2号,20</span><br><span class="line">3号,30</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">【【【【【</span><br><span class="line">&#123;</span><br><span class="line">  xAxis: &#123;</span><br><span class="line">    type: &#x27;category&#x27;,</span><br><span class="line">    data: [&#x27;1号&#x27;, &#x27;2号&#x27;, &#x27;3号&#x27;]</span><br><span class="line">  &#125;,</span><br><span class="line">  yAxis: &#123;</span><br><span class="line">    type: &#x27;value&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  series: [&#123;</span><br><span class="line">    data: [10, 20, 30],</span><br><span class="line">    type: &#x27;line&#x27;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br><span class="line">【【【【【</span><br><span class="line">根据数据分析可得出以下结论：</span><br><span class="line">1. 网站用户数在3天内逐渐增长。</span><br><span class="line">2. 用户增长速度较快，呈现线性增长趋势。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>得到生成的结果之后，可以通过<strong>分割字符串的方式</strong>来获取各个模块的内容。</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240214181235798.png" alt="image-20240214181235798"></p><h4 id="doChat-方法的请求和响应"><a href="#doChat-方法的请求和响应" class="headerlink" title="doChat 方法的请求和响应"></a>doChat 方法的请求和响应</h4><p>方法名：doChat</p><p>请求参数：</p><ul><li>modelId：使用的会话模型（助手）id</li><li>message：要发送的消息，不超过 1024 字</li></ul><p>响应结果：</p><ul><li>code：响应状态码</li><li>data：<ul><li>content：对话结果内容</li></ul></li><li>message：响应信息</li></ul><h2 id="智能接口实现"><a href="#智能接口实现" class="headerlink" title="智能接口实现"></a>智能接口实现</h2><ol><li>构造用户请求</li><li>调用鱼聪明 sdk，得到 AI 响应数据</li><li>从 AI 响应结果中，找到需要的信息</li><li>保存图表到数据库</li></ol><p>返回结果保存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BiResponse</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String genChart;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String genResult;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long chartId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的后端请求 ai 生成图表方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件上传</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> multipartFile</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> genChartByAiRequest</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/gen&quot;)</span></span><br><span class="line"><span class="keyword">public</span> BaseResponse&lt;BiResponse&gt; <span class="title function_">uploadFile</span><span class="params">(<span class="meta">@RequestPart(&quot;file&quot;)</span> MultipartFile multipartFile,</span></span><br><span class="line"><span class="params">                                       GenChartByAiRequest genChartByAiRequest, HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="comment">// 只有登录了才能去调用接口</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">loginUser</span> <span class="operator">=</span> userService.getLoginUser(request);</span><br><span class="line">    <span class="type">String</span> <span class="variable">chartType</span> <span class="operator">=</span> genChartByAiRequest.getChartType();</span><br><span class="line">    <span class="type">String</span> <span class="variable">goal</span> <span class="operator">=</span> genChartByAiRequest.getGoal();</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> genChartByAiRequest.getName();</span><br><span class="line">    <span class="comment">// 一旦目标为空，就直接抛出异常。无法根据空目标产生内容</span></span><br><span class="line">    ThrowUtils.throwIf(StringUtils.isBlank(goal),ErrorCode.PARAMS_ERROR,<span class="string">&quot;目标为空&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果名称不为空，并且名称长度大于100，就抛出异常，并给出提示</span></span><br><span class="line">    ThrowUtils.throwIf(StringUtils.isNotBlank(name) &amp;&amp; name.length() &gt; <span class="number">100</span>, ErrorCode.PARAMS_ERROR, <span class="string">&quot;名称过长&quot;</span>);</span><br><span class="line">    <span class="comment">// 设计 message，将用户发送的信息向 ai 提问</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">userInput</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    userInput.append(<span class="string">&quot;分析需求:&quot;</span>).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">userGoal</span> <span class="operator">=</span> goal;</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotBlank(chartType))&#123;</span><br><span class="line">        userGoal += <span class="string">&quot;，请使用&quot;</span> + chartType;</span><br><span class="line">    &#125;</span><br><span class="line">    userInput.append(userGoal).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    userInput.append(<span class="string">&quot;原始数据:&quot;</span>).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">csvData</span> <span class="operator">=</span> ExcelUtils.excelToCsv(multipartFile);</span><br><span class="line">    ThrowUtils.throwIf(StringUtils.isBlank(csvData),ErrorCode.SYSTEM_ERROR,<span class="string">&quot;数据压缩失败&quot;</span>);</span><br><span class="line">    userInput.append(csvData).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 调用 Ai 接口,得到返回结果</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> aiManager.doChat(AiModelIdEnum.BI_MODEL_ID.getModelId(), userInput.toString());</span><br><span class="line">    <span class="comment">// 将返回结果进行分割赋值</span></span><br><span class="line">    String[] splits = result.split(<span class="string">&quot;【【【【【&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(splits.length &lt; <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.SYSTEM_ERROR,<span class="string">&quot;AI 生成错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">genChart</span> <span class="operator">=</span> splits[<span class="number">1</span>].trim();</span><br><span class="line">    <span class="type">String</span> <span class="variable">genResult</span> <span class="operator">=</span> splits[<span class="number">2</span>].trim();</span><br><span class="line">    <span class="comment">// 插入到数据库</span></span><br><span class="line">    <span class="type">Chart</span> <span class="variable">chart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chart</span>();</span><br><span class="line">    chart.setName(name);</span><br><span class="line">    chart.setGoal(goal);</span><br><span class="line">    chart.setChartData(csvData);</span><br><span class="line">    chart.setChartType(chartType);</span><br><span class="line">    chart.setGenChart(genChart);</span><br><span class="line">    chart.setGenResult(genResult);</span><br><span class="line">    chart.setUserId(loginUser.getId());</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">saveResult</span> <span class="operator">=</span> chartService.save(chart);</span><br><span class="line">    <span class="comment">// 校验插入是否成功</span></span><br><span class="line">    ThrowUtils.throwIf(!saveResult,ErrorCode.SYSTEM_ERROR, <span class="string">&quot;图表保存失败&quot;</span>);</span><br><span class="line">    <span class="comment">// 将生成的结果返回给前端</span></span><br><span class="line">    <span class="type">BiResponse</span> <span class="variable">biResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BiResponse</span>();</span><br><span class="line">    biResponse.setGenChart(genChart);</span><br><span class="line">    biResponse.setGenResult(genResult);</span><br><span class="line">    <span class="keyword">return</span> ResultUtils.success(biResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 Swagger 发送请求得到返回结果：</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240214184050115.png" alt="image-20240214184050115"></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;genChart&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;\n  xAxis: &#123;\n    type: &#x27;category&#x27;,\n    data: [&#x27;1号&#x27;, &#x27;2号&#x27;, &#x27;3号&#x27;]\n  &#125;,\n  yAxis: &#123;\n    type: &#x27;value&#x27;\n  &#125;,\n  series: [&#123;\n    data: [10, 20, 30],\n    type: &#x27;bar&#x27;\n  &#125;]\n&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;genResult&quot;</span><span class="punctuation">:</span> <span class="string">&quot;根据提供的数据，可以看出网站的用户数在过去三天呈现逐渐增长的趋势。具体分析如下：\n- 1号当天，网站的用户数为10人。\n- 2号当天，网站的用户数较前一天增加了10人，达到20人。\n- 3号当天，网站的用户数较前一天增加了10人，达到30人。\n因此，可以看出网站的用户数在过去三天内保持了一个较为稳定的增长趋势。&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;chartId&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ok&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>前端只需要将其中的 genChart 放到 echarts 的代码块中，并把 genResult 给展示出来即可。</p><h2 id="前端智能生成页面开发"><a href="#前端智能生成页面开发" class="headerlink" title="前端智能生成页面开发"></a>前端智能生成页面开发</h2><ol><li>通过表单组件来实现用户数据填写和发送请求（调用 oneAPI 接口，注意封装的文件上传请求体，要找到最原始的文件上传内容。）</li><li>展示 AI 生成结果页面，通过接收 AI 生成的返回代码和生成的描述内容，代码将其转成 Json 显示： Json.parse(chartCode);</li></ol><h4 id="前端发送请求时的展开语法…"><a href="#前端发送请求时的展开语法…" class="headerlink" title="前端发送请求时的展开语法…"></a>前端发送请求时的展开语法…</h4><p>在鱼皮哥的前端代码中，传值时常会直接使用 … 变量的形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const params = &#123;</span><br><span class="line">      ...values,</span><br><span class="line">      file:undefined</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这是 JS 的一个展开运算符，可以将一个可迭代对象（如数组，对象）拆分成单独的值。让它可以方便地在其他地方引用这些值。</p><p>对于对象，<code>...values</code> 操作符会将对象 <code>values</code> 中的所有属性展开，以便可以将这些属性直接插入到另一个对象中。这样做可以简化代码，避免重复编写属性。</p><p>例如，假设有一个对象 <code>values</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVASCRIPT复制const values = &#123;   name: &#x27;Alice&#x27;,  age: 30 &#125;; </span><br></pre></td></tr></table></figure><p>如果我们需要创建另一个对象，并将 <code>values</code> 对象中的属性复制到这个新对象中，可以使用展开语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVASCRIPT复制const newObject = &#123;  ...values,  address: &#x27;123 Main St&#x27; &#125;; </span><br></pre></td></tr></table></figure><p>在这里，<code>...values</code> 将会将 <code>values</code> 对象中的 <code>name</code> 和 <code>age</code> 属性展开，然后将其复制到 <code>newObject</code> 中。最终，<code>newObject</code> 将包含 <code>name</code>、<code>age</code> 和 <code>address</code> 三个属性。</p><p>这就回答了为什么我们调用 ai 生成接口时，对于 body 的参数，可以直接将 …values 传入了。</p><h3 id="前端-onFinish-实现"><a href="#前端-onFinish-实现" class="headerlink" title="前端 onFinish 实现"></a>前端 onFinish 实现</h3><p>前端代码中，核心的实现就是这个 onFinish，它调用了后端的 gen 接口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">const onFinish = async (values: any) =&gt; &#123;</span><br><span class="line">    // 如果已经是提交中的状态，直接返回，避免重复提交</span><br><span class="line">    if(submitting)&#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    setSubmitting(true);</span><br><span class="line">    // 第一个参数需要一个完整对象</span><br><span class="line">    const params = &#123;</span><br><span class="line">      ...values,</span><br><span class="line">      file:undefined</span><br><span class="line">    &#125;</span><br><span class="line">    // 将请求发送包裹在一个 try - catch 块中，当请求发生异常时，给用户一个默认的响应</span><br><span class="line">    try&#123;</span><br><span class="line">      // 发送请求</span><br><span class="line">      const res = await</span><br><span class="line">        genChartByAiUsingPost(params,&#123;&#125;,values.file.file.originFileObj);</span><br><span class="line">      if(!res?.data)&#123;</span><br><span class="line">        message.error(&quot;分析失败&quot;);</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        message.success(&quot;分析成功&quot;);</span><br><span class="line">        // 将返回的 genChart 转成 JSON 类型</span><br><span class="line">        console.log(res.data.genChart);</span><br><span class="line">        const chartOption = JSON.parse(res.data.genChart ?? &#x27;&#x27;);</span><br><span class="line">        // 如果为空，则抛出异常，并提示:&quot;图表代码解析错误&quot;</span><br><span class="line">        if(!chartOption)&#123;</span><br><span class="line">          throw new Error(&quot;图表代码解析错误&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">          setChart(res.data);</span><br><span class="line">          setOption(chartOption);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (e: any)&#123;</span><br><span class="line">      message.error(&quot;分析失败&quot; + e.message);</span><br><span class="line">    &#125;</span><br><span class="line">    setSubmitting(false);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>该 onFinish 调用时，有一个容易出现的 bug：<br>我们返回的代码并不是 json 格式的，而调用</p><p> <code>JSON.parse(res.data.genChart ?? &#39;&#39;);</code></p><p>时，会出现 JSON 转换错误。</p><p>我们需要给 AI 充足的预设，保证让它能够返回 JSON 格式的字符串，这样才能被方法解析。</p><p>当然，这种调试 AI 的方法不够稳定，需要反复测试直到确保稳定才能供于直接使用。</p><h2 id="本章思考"><a href="#本章思考" class="headerlink" title="本章思考"></a>本章思考</h2><ol><li>现在的网站足够安全吗？ （不够安全，接口没有做限制，可能会被刷量，或者大文件上传导致数据库存储过大字符串）<ol><li>如果用户上传一个超大的文件怎么办？ （分批次，将大文件分成多个小文件上传，在内存中去拼接字符串）</li><li>如果用户用科技疯狂点击生成提交，怎么办？(做限流)</li><li>如果 AI 的生成太慢，又有很多用户要同时生成，给系统造成了很大的压力，怎么兼顾用户体验和系统的可用性？（分布式？）</li></ol></li></ol><h1 id="第四期"><a href="#第四期" class="headerlink" title="第四期"></a>第四期</h1><h2 id="计划-1"><a href="#计划-1" class="headerlink" title="计划"></a>计划</h2><ol><li>开发图表管理功能</li><li><strong>优化系统</strong></li></ol><p>开发图表管理功能(CRUD)</p><p>后端：复用之前写好的 增删改查 代码。核心：获取个人创建的图表列表 listMyChartByPage</p><p>前端：</p><ol><li>开发一个列表页</li><li>支持按照图表名称搜索</li></ol><p>步骤：</p><ol><li>创建路由和页面</li><li>获取需要的数据，定义 state 变量来存储数据，用于给页面展示</li><li>先用最简单的格式显示数据，再去慢慢调样式</li><li>引入 Ant Design 的 list 组件，复制示例代码，调整数据。</li><li>针对样式，对数据做一些处理，比如统一图表自身的 title</li><li>增加分页</li><li>增加搜索框</li><li>其他优化： 比如 loading 效果</li></ol><p>小知识：</p><ol><li><p>原子化 CSS</p></li><li><p>利用 F12 控制台进行弱网测试</p></li></ol><p>拓展：</p><ol><li>支持查看原始数据</li><li>支持跳转到图表编辑页，去编辑图表</li></ol><h2 id="前端部分表示"><a href="#前端部分表示" class="headerlink" title="前端部分表示"></a>前端部分表示</h2><p><strong>取出登录用户信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const &#123; setInitialState &#125; = useModel(&#x27;@@initialState&#x27;);</span><br><span class="line">const &#123; currentUser &#125; = initialState ?? &#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="系统优化（重点，分库分表思想、限流思路）"><a href="#系统优化（重点，分库分表思想、限流思路）" class="headerlink" title="系统优化（重点，分库分表思想、限流思路）"></a>系统优化（重点，分库分表思想、限流思路）</h2><p>现在的网站足够安全吗？ （不够安全，接口没有做限制，可能会被刷量，或者大文件上传导致数据库存储过大字符串）</p><ol><li>如果用户上传一个超大的文件怎么办？ （分批次，将大文件分成多个小文件上传，在内存中去拼接字符串）</li><li>如果用户用科技疯狂点击生成提交，怎么办？(做限流)</li><li>如果 AI 的生成太慢，又有很多用户要同时生成，给系统造成了很大的压力，怎么兼顾用户体验和系统的可用性？（分布式？）</li></ol><p><strong>只要涉及到用户自主上传的操作，一定要校验文件</strong></p><ul><li>文件的大小</li><li>文件的后缀</li><li>文件的内容</li><li>文件的合规性 （比如敏感内容）</li></ul><p><strong>文件的大小限制</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multipartFile.getSize();</span><br></pre></td></tr></table></figure><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240215091801590.png" alt="image-20240215091801590"></p><p><strong>文件的后缀限制</strong></p><p>获取文件名，利用 hutool 工具去对后缀做判断。</p><p>扩展点：接入腾讯云的图片万象数据审核（COS 对象存储的审核功能）</p><h3 id="todo-自主拓展"><a href="#todo-自主拓展" class="headerlink" title="todo 自主拓展"></a>todo 自主拓展</h3><p><strong>数据存储</strong></p><p>问题：</p><ol><li>我们把每个图表的原始数据全部存放在了同一个数据表（chart 表） 的字段里，如果用户上传的原始数据量很大、图标数日益增多，查询 Chart 表就会很慢。</li><li>对于一个 BI 平台，用户对于原始数据有一些简单查询的需求。现在如果把所有数据存放在一个字段中，查询时，只能把整个字段查出来然后通过代码去做过滤。</li></ol><p>解决方案：</p><p><strong>分开存储：</strong></p><p>把每个图表对应的原始数据单独保存为一个新的数据表 ：</p><p>比如 id &#x3D; 1 的图表，将其属性单独保存一个新的表：</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240215094248584.png" alt="image-20240215093432519"></p><p>通过这种方式，可以让用户在查询自己的数据（查的是数据，因为只查自己的数据，所以只需要走 chart 表的 id 和 userId,不需要走chartData）时，<strong>不会被其他用户上传的大文件所影响。</strong></p><p>我们利用查询到的图表 id ，再去查询相应 chart_ id 表中数据，即可给用户返回原始数据。而且也避免了 chartData 数据量大的问题，在 chart 表中就不需要这个字段了。</p><blockquote><p>在数据库查询时，如果只查询某一行的某列，而其他列的数据量非常大（比如 100GB），一般情况下不会直接影响到查询效率。数据库系统通常会优化查询，只返回您需要的列数据，而不会在内存中加载其他列数据。</p><p>数据库系统通常会使用索引来快速定位到需要查询的行，然后只检索您指定的列数据，而不会加载整行的所有列数据。这种优化可以有效地减少查询时间和内存消耗。</p></blockquote><p>优点：</p><ol><li>将原始数据和图表信息分离开，避免部分用户上传大文件造成整个数据库查询效率降低</li><li>原始数据单独存储，对于用户需要查询原始数据的需求，可以更轻松地满足，无需在代码层面上对原始数据字符串做分割。也更方便实现对用户查询条件。</li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>分开存储：</strong></p><p>存储图表信息时，不把数据存储为 chart 表的字段，而是新建一个 chart_{图表 id} 的数据表（利用动态 SQL 实现）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> chart_&#123;id&#125;</span><br><span class="line">&#123;</span><br><span class="line">日期 <span class="type">varchar</span> <span class="keyword">null</span>,</span><br><span class="line">    用户数 <span class="type">int</span> <span class="keyword">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的日期和用户数，我的思路是获取表头之后，通过字符串分割的方式获取（每个字段的类型可以通过 apache POI 的类型判断实现），然后通过循环的方式传入 。</p><p><strong>分开查询：</strong></p><ol><li>以前直接查询图表，取 chartData 字段，现在改为读取 chart_{图表 id} 的数据表：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> chart_&#123;id&#125;</span><br></pre></td></tr></table></figure><p>由于用户的原始数据互不相同，创建的数据表也各不相同，因此不能写死 SQL 语句查询。需要使用 Mybatis 的动态 SQL。</p><p>如果要实现最自由的动态 SQL ，可以按照下面的思路实现：</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240215102507502.png" alt="image-20240215102507502"></p><p>但是太过自由也会有问题，这个实现要防止造成 SQL 注入问题。</p><p>解决 SQL 注入的方案：</p><ol><li><p><strong>在业务层写逻辑代码校验</strong></p></li><li><p>通过完善上述的 SQL 语句，限制用户使用 SQL 的自由度。</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  </span></span><br><span class="line"><span class="comment">queryChartData唯一标识符;parameterType查询语句的参数类型,类型为字符串;</span></span><br><span class="line"><span class="comment">resultType查询结果的返回类型,类型为map类型;</span></span><br><span class="line"><span class="comment">$&#123;querySql&#125;是SQL查询语句的占位符;</span></span><br><span class="line"><span class="comment">select * from chart_#&#123;chartId&#125; 不够灵活,$&#123;querySql&#125;是最灵活的方式，</span></span><br><span class="line"><span class="comment">就是把sql语句完全交给程序去传递，有一定的风险;</span></span><br><span class="line"><span class="comment">一旦使用$符号，就有sql注入的风险。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryChartData&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">  $&#123;querySql&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">可以在程序里面去做校验。只要保证这个SQL是通过你的后端生成的，</span></span><br><span class="line"><span class="comment">在生成的过程中做了校验，就不会有这种漏洞的风险。 </span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChartMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Chart&gt; &#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 方法的返回类型是 List&lt;Map&lt;String, Object&gt;&gt;,</span></span><br><span class="line"><span class="comment">    * 表示返回的是一个由多个 map 组成的集合,每个map代表了一行查询结果，</span></span><br><span class="line"><span class="comment">    * 并将其封装成了一组键值对形式的对象。其中,String类型代表了键的类型为字符串，</span></span><br><span class="line"><span class="comment">    * Object 类型代表了值的类型为任意对象,使得这个方法可以适应不同类型的数据查询。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">queryChartData</span><span class="params">(String querySql)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>水平分表：将同一个表中的不同行分到不同的表中，例如每一万行分一张表。</p><p>垂直分表：将同一个表中的某列分到不同的表中，就如我们上面的项目的思路。可以考虑用在某一列存储的数据可以再分，或者存储量过大的情况。</p><p>垂直分库：将同一个表中的不同列分到不同的数据库中。</p><p>水平分库：相当于把数据库水平切割，原来一个表中的数据可能会分配到不同的数据库中，这就是水平分库。</p><blockquote><p>咋们的项目上面的思路叫做<strong>垂直分表</strong></p></blockquote><p><strong>水平分表的优点：</strong></p><ul><li>单个表的数据量减少，查询效率提高。</li><li>可以通过增加节点，提高系统的扩展性和容错性。</li></ul><p><strong>水平分表的缺点：</strong></p><ul><li>事务并发处理复杂度增加，需要增加分布式事务的管理，性能和复杂度都有所牺牲。</li><li>跨节点查询困难，需要设计跨节点的查询模块。</li></ul><p>2 <strong>垂直分库</strong>（Vertical Partitioning） 垂直分库，指的是根据业务模块的不同，将不同的字段或表分到不同的数据库中。垂直分库基于数</p><p>据库内核支持，对应用透明，无需额外的开发代码，易于维护升级。</p><p><strong>垂直分库的优点：</strong></p><ul><li>减少单个数据库的数据量，提高系统的查询效率。</li><li>增加了系统的可扩展性，比水平分表更容易实现。</li></ul><p><strong>垂直分库的缺点：</strong></p><ul><li>不同数据库之间的维护和同步成本较高。</li><li>现有系统的改造存在一定的难度。</li><li>系统的性能会受到数据库之间互相影响的影响。</li></ul><h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p><strong>涉及到收费，销量的服务，一定要做限流！！！</strong></p><p>现在的问题：使用系统是需要消耗成本的，所以<strong>用户有可能疯狂刷量，让你破产</strong></p><p>解决问题：</p><ol><li>限制用户调用总次数，控制成本</li><li>用户在短时间内疯狂使用，导致服务器资源被占满，其他用户无法使用 &#x3D;&#x3D; 》 限流</li></ol><p>思考限流阈值多大合适？比如限制单个用户在每秒只能使用 1 次。</p><h3 id="限流的几种算法"><a href="#限流的几种算法" class="headerlink" title="限流的几种算法"></a>限流的几种算法</h3><p>参考文章：</p><p><a href="https://juejin.cn/post/7209504489010430010">面试必备：四种经典限流算法讲解 - 掘金 (juejin.cn)</a></p><p><strong>1）固定窗口限流</strong></p><p>单位时间内允许部分操作：</p><p>比如 1 小时只允许 10 个用户操作</p><p>优点：实现最简单</p><p>缺点：可能出现流量突刺</p><p>比如：前 59 分钟没有一个操作，第 59 分钟来了 10 个操作， 第 1 小时 01 分钟又来了 10 个操作。相当于两分钟内执行了 20 个操作，服务器仍然有高峰危险。</p><p><strong>2）滑动窗口限流</strong></p><p>单位时间内允许部分操作，但是这个单位时间是滑动的，需要指定一个滑动单位</p><p>滑动单位 1 min</p><p>0s 1h 2h</p><p>一分钟后：</p><p>1 min 1h1min 2h2min</p><blockquote><p>啥意思呢？</p></blockquote><p> 就是解决上面固定窗口的问题的，我们将原本固定每 1 h 允许做 10 次操作，变成了每 1h 时间段允许做 10 次操作。 原本 59 分做的 10 个操作，下次只允许 59 分后 1h 才能在做 10 次操作。而不是固定的刷新。它是做完操作之后才开始计时 1h ，达到 1h 的时间了才会去让用户做操作。</p><p>优点：</p><p>解决上述流量突刺的问题，因为第 59 分时，限流窗口是 59 分 ~ 1 小时 59 分，这个时间段内只能接收 10 次请求，只要还在这个窗口内，更多的操作就会被拒绝。</p><p>缺点： 实现相对复杂，限流效果和你的滑动单位有关，滑动单位越小，限流效果越好，但往往很难选取到一个特别合适的滑动单位。</p><p><strong>3）漏桶限流</strong></p><p>以固定的速率处理请求，当请求桶满了后，拒绝请求。</p><p>比如：每秒处理 10 个请求，每 0.1 秒固定处理一次请求，如果 1 秒内来了 10 个请求，都可以处理，但如果 1 秒内来了 11 个请求，最后那个请求会被溢出桶，被拒绝。</p><p>优点：能够一定程度上应对流量突刺</p><p>缺点：没有办法迅速处理一批请求，只能一个一个按顺序处理。（固定速率的缺点，不支持并发）</p><p>4）令牌桶限流</p><p>管理员先生成一批令牌，每秒生成 10 个令牌；当用户要操作前，先去拿到一个令牌，有令牌的人就有资格执行操作、能够同时执行操作。拿不到令牌就等着</p><p>优点：能够并发处理同时的请求，并发性能会更高</p><p>需要考虑的问题：拿不到令牌的用户需要等到下次生成令牌时才能执行操作，存在时间单位选取的问题。（令牌的再次生成时间）</p><h3 id="限流的实现"><a href="#限流的实现" class="headerlink" title="限流的实现"></a>限流的实现</h3><ol><li><p>本地限流（单机限流）</p><p>每个服务器单独的限流，一般适用于单体项目</p><p><strong>Google Guava RateLimiter 库</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimiterDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 每秒最多允许2个请求通过</span></span><br><span class="line">        <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟多个请求</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rateLimiter.tryAcquire()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Request &quot;</span> + i + <span class="string">&quot; allowed at &quot;</span> + System.currentTimeMillis());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Request &quot;</span> + i + <span class="string">&quot; blocked at &quot;</span> + System.currentTimeMillis());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>分布式限流（多机限流）</p></li></ol><p>如果项目有多个服务器，比如微服务，建议使用分布式限流。</p><p><strong>gateWay 实现限流</strong>（来源 GPT ）：</p><p>在 Spring Cloud 中，Spring Cloud Gateway 是一个基于 Spring Framework 5、Project Reactor 和 Spring Boot 2 的网关服务，提供了路由、过滤和限流等功能。Spring Cloud Gateway 可以方便地实现请求的路由、转发和过滤，同时也支持限流功能。</p><p>在 Spring Cloud Gateway 中，可以通过配置限流过滤器来实现限流功能。下面是一个简单的示例，演示如何在 Spring Cloud Gateway 中实现请求限流：</p><ol><li>首先，添加 Spring Cloud Gateway 的依赖到你的项目中。在 Maven 项目中，可以添加以下依赖：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在 Spring Boot 应用的配置文件中，配置 Spring Cloud Gateway 的路由和限流规则。例如，下面是一个简单的配置示例：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">my_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://example.com</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/myroute</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">RequestRateLimiter</span></span><br><span class="line">              <span class="attr">args:</span></span><br><span class="line">                <span class="attr">key-resolver:</span> <span class="string">&quot;#&#123;@ipAddressKeyResolver&#125;&quot;</span></span><br><span class="line">                <span class="attr">redis-rate-limiter.replenishRate:</span> <span class="number">10</span></span><br><span class="line">                <span class="attr">redis-rate-limiter.burstCapacity:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>在上面的配置中，我们定义了一个名为 <code>my_route</code> 的路由，当请求路径为 <code>/myroute</code> 时，会应用限流过滤器 <code>RequestRateLimiter</code>。这个过滤器会使用 Redis 进行限流，限制请求每秒不超过 10 个，突发容量不超过 20 个。</p><ol start="3"><li>创建限流 KeyResolver，用于从请求中提取限流的 key。例如，下面是一个提取 IP 地址作为 key 的 KeyResolver 实现：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.ratelimit.KeyResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IpAddressKeyResolver</span> <span class="keyword">implements</span> <span class="title class_">KeyResolver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;String&gt; <span class="title function_">resolve</span><span class="params">(ServerWebExchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Mono.just(exchange.getRequest().getRemoteAddress().getAddress().getHostAddress());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>在 Spring Boot 应用的配置类中注册 KeyResolver：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.ratelimit.KeyResolver;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimitConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> KeyResolver <span class="title function_">ipAddressKeyResolver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IpAddressKeyResolver</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上步骤，你就可以在 Spring Cloud Gateway 中实现基于 Redis 的请求限流功能。当用户请求 <code>/myroute</code> 路径时，限流过滤器会根据 IP 地址对请求进行限流。</p><h3 id="Redisson-限流实现"><a href="#Redisson-限流实现" class="headerlink" title="Redisson 限流实现"></a>Redisson 限流实现</h3><p>Redisson 内置了一个限流工具类，可以帮助你利用 Redis 实现限流功能。</p><blockquote><p>Redisson 限流操作是项目的一个通用能力，可以将其抽象出来作为一个能够在不同项目中复用的功能。</p></blockquote><p>可以在 Redisson 配置中读取原来 Redis 的配置，直接在上面加上 @ConfigurationProperties 标注 yml 的配置前缀即可。</p><p>但是这种方式不够规范，最好还是自己再写一个 Redisson 配置，然后引用。</p><p><strong>Redisson 配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;spring.redis&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer database;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// redisson 配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="comment">// 使用单机配置</span></span><br><span class="line">        config.useSingleServer()</span><br><span class="line">                <span class="comment">// 设置地址</span></span><br><span class="line">                .setAddress(<span class="string">&quot;redis://&quot;</span> + host + <span class="string">&quot;:&quot;</span> + port)</span><br><span class="line">                <span class="comment">// 设置密码</span></span><br><span class="line">                .setPassword(password)</span><br><span class="line">                <span class="comment">// 设置数据库</span></span><br><span class="line">                .setDatabase(database);</span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redissonClient</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line">        <span class="keyword">return</span> redissonClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redisson 的代码参数被压缩过了，没有显示完整的参数名称：</p><p>没办法看懂参数含义，怎么办？</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240215151655363.png" alt="image-20240215151655363"></p><ol><li>看官方文档</li><li>下载源码（点击任意一个包里的代码，点击右上角的下载源码。）</li></ol><p>实现步骤：</p><ol><li>创建一个名称为 *** 的限流器（可以选择用 userId 来作为名称，这样就可以针对不同的用户做独立的限流。），每秒最多访问 2（实际情况自己选择） 次</li><li>每当一个操作来了后，请求一个令牌</li><li>一旦令牌为空，就抛出异常</li><li>如果获取到令牌，那么就正常执行后续逻辑</li></ol><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240215153435648.png" alt="image-20240215153435648"></p><p><strong>限流管理器实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redis 限流管理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisLimiterManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doRateLimit</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个名称为 key 的限流器，初始化时设置最大访问速率是 2 次/秒</span></span><br><span class="line">        <span class="type">RRateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> redissonClient.getRateLimiter(key);</span><br><span class="line">        rateLimiter.trySetRate(RateType.OVERALL, <span class="number">2</span>, <span class="number">1</span>, RateIntervalUnit.SECONDS);</span><br><span class="line">        <span class="comment">// 每当一个操作来了，就请求一个令牌</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">canOp</span> <span class="operator">=</span> rateLimiter.tryAcquire(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 如果拿不到令牌，就抛出异常</span></span><br><span class="line">        <span class="keyword">if</span>(!canOp)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.TOO_MANY_REQUEST);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisLimiterManagerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisLimiterManager redisLimiterManager;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doRateLimit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">2</span> ;i++)&#123;</span><br><span class="line">            redisLimiterManager.doRateLimit(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">5</span> ;i++)&#123;</span><br><span class="line">            redisLimiterManager.doRateLimit(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="限流粒度"><a href="#限流粒度" class="headerlink" title="限流粒度"></a>限流粒度</h3><ol><li>针对某个方法限流，即单位时间内最多允许同时 XX 个操作使用这个方法</li><li>针对某个用户限流，即单位时间内最多允许用户使用 XX 个操作</li><li>针对某个用户的某个方法限流。比如单个用户单位时间内最多执行 X 个方法</li></ol><h1 id="第五期"><a href="#第五期" class="headerlink" title="第五期"></a>第五期</h1><h2 id="计划-2"><a href="#计划-2" class="headerlink" title="计划"></a>计划</h2><ol><li>系统优化 - 异步化</li><li>异步化思路</li><li>线程池理论和实战</li><li>前端后端的异步化改造</li></ol><h2 id="系统问题分析"><a href="#系统问题分析" class="headerlink" title="系统问题分析"></a>系统问题分析</h2><ol><li>用户等待时间有点长（要等 AI 生成）</li><li>业务服务器可能会有很多请求在处理，导致系统图资源紧张，严重时导致服务器宕机或者无法处理新的请求</li><li>调用第三方服务时（AI 服务） 的处理能力是有限的，比如每 3 秒只能处理 1 哥请求，如果请求很多，会导致 AI 处理不过来，严重时， AI 可能会对咋们的后台系统拒绝服务</li></ol><h2 id="异步化"><a href="#异步化" class="headerlink" title="异步化"></a>异步化</h2><p><strong>概念介绍</strong></p><p>同步：一件事情做完，再做另外一件事。</p><p>异步：不用等一件事做完，就可以做另外一件事情，等第一件事完成时，可以收到一个通知，告诉你这件事做好了，你可以再进行后续处理。</p><h3 id="业务流程分析"><a href="#业务流程分析" class="headerlink" title="业务流程分析"></a>业务流程分析</h3><p><strong>标准异步化的业务流程</strong></p><ol><li><p>当用户要进行耗时很长的操作时，点击提交后，不需要在界面傻等。而是应该把这个任务保存到数据库中记录下来</p></li><li><p>把用户执行的操作（任务）放到一个<strong>任务队列</strong>中，让程序（线程）从任务队列中取出任务去执行。</p><p><strong>任务队列没有满的情况：</strong></p><ol><li>如果我们的程序还有多余的空闲线程，可以立刻去做这个任务</li><li>如果我们的程序的线程都在繁忙，无法继续处理，那就放到等待队列里。</li></ol><p><strong>我们的所有线程都在忙，任务队列满了</strong>：</p><ol><li>拒绝掉这个任务，再也不去执行</li><li>通过保存到数据库中的记录来看到提交失败的任务，并且在程序闲的时候，可以把任务从数据库中捞到程序里，再去执行。</li></ol></li><li><p>我们的程序（线程） 从任务队列中取出任务依次执行，每完成一件事情就要修改一下任务的状态。</p></li><li><p>用户可以查询任务的执行状态，或者在任务执行成功或失败时能得到通知（发邮件、系统消息提示、短信），从而优化体验。</p></li><li><p>如果我们要执行的任务非常复杂，包含很多环节，在每一个小人物完成时，要在程序记录一下任务的执行状态。 （因为异步化是一个非常复杂的过程，容易出现问题，需要准确把握任务的执行情况。）</p></li></ol><h4 id="标准异步化的业务流程"><a href="#标准异步化的业务流程" class="headerlink" title="标准异步化的业务流程"></a>标准异步化的业务流程</h4><ol><li>用户点击智能分析页的提交按钮时，先把图表立即保存到数据库中（作为一个任务）</li><li>用户可以在图表管理页面查看所有图表（已生成的、生成中的、生成失败）的信息和状态。</li></ol><p>问题：</p><p>1.任务队列的最大容量应该设置成多少？</p><p>程序怎么从任务队列中取出任务去执行？这个任务的流程怎么实现？怎么保证程序最多同时执行多少个任务？</p><p>相当于有多个线程，同时去一个任务队列中去取出任务，然后执行。</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240216085257554.png" alt="image-20240216085257554"></p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>为什么需要线程池？</p><ol><li>线程的管理比较复杂（比如什么时候新增线程，什么时候减少空闲线程）</li><li>任务存取比较复杂（什么时候接受任务、什么时候拒绝任务）</li></ol><p><strong>线程池的实现</strong></p><ol><li>不用自己写，如果是 Spring 中，可以用 ThreadPoolTaskExecutor 配合 @Async 注解实现。（不太建议）</li></ol><p><a href="https://blog.csdn.net/zzhongcy/article/details/120487060">springboot之线程池ThreadPoolTaskExecutor以及@Async异步注解_springboot threadpooltaskexecutor-CSDN博客</a></p><ol start="2"><li>如果是在 java 中，可以使用 JUC 并发变成包中的 ThreadPoolExecutor 来自由地实现线程池。</li></ol><h4 id="怎么确定线程池参数呢？"><a href="#怎么确定线程池参数呢？" class="headerlink" title="怎么确定线程池参数呢？"></a>怎么确定线程池参数呢？</h4><p><strong>结合实际情况（实际业务场景和系统资源）来测试调整，不断优化。</strong></p><p><strong>要考虑系统最脆弱的环节（系统的瓶颈） 在哪里？</strong></p><p>现有条件 ：比如 AI 生成能力的并发是只允许 4  个线程同时去执行。AI 能力允许 20 个任务排队。</p><p>corePoolSize （核心线程数 &#x3D;&gt; 正式员工数）：正常情况下，我们的系统应该能工作的线程数。</p><p>maximumPoolSize 设置为极限情况。（最大线程数 &#x3D; &gt; 哪怕任务再多，你也最多招这些人） ： 极限情况下，我们的线程池最多有多少个线程？</p><p>keepAliveTime（空闲线程存活时间）：非核心线程在没有任务的情况下，过多久要删除（理解为开除临时工）从而释放无用的线程资源。</p><p>TimeUnit （空现场存活时间的单位）：分钟、秒</p><p>workQueue（工作队列）：用于存放给线程执行的任务，存在一个队列的长度（一定要设置，不要说队列长度无限，因为也会占用资源） （结合实际情况去设置）</p><p>threadFactory（线程工厂）：控制每个线程的生成。</p><h4 id="线程池分配策略："><a href="#线程池分配策略：" class="headerlink" title="线程池分配策略："></a>线程池分配策略：</h4><p>一般情况下，任务分为 IO 密集型和计算密集型两种。</p><p><strong>计算密集型</strong>：吃 CPU， 比如音视频处理、图像处理、数学计算等，一般是设置 corePoolSize 为 CPU 的核心数 + 1 （空余线程），可以让每个线程都能利用好 CPU 的每个核，而且线程之间不用频繁切换（减少开销）</p><p><strong>IO 密集型：</strong> 吃宽带&#x2F;内存&#x2F;硬盘的读写资源，corePoolSize 可以设置大一点，一般是 2n 左右，但是建议以 IO 的能力为主。</p><h4 id="todo自主实现"><a href="#todo自主实现" class="headerlink" title="todo自主实现"></a>todo自主实现</h4><blockquote><p>资源隔离策略：比如重要的任务（VIP 任务）一个任务队列，普通任务一个任务队列，保证这两个队列互不干扰</p></blockquote><h3 id="线程池执行任务流程"><a href="#线程池执行任务流程" class="headerlink" title="线程池执行任务流程"></a>线程池执行任务流程</h3><p>开始时，一个任务和线程都没有。一旦来了一个任务，发现此时繁忙的线程还没有达到核心线程数目（ Threadnum &lt; corePoolSize ） ，直接让一个线程处理这个任务。</p><p>此时又来了一个任务，就再让一个线程去处理这个任务。后来又来了一个任务，但是此时当前线程数已经达到 corePoolSize ，此时任务放到队列里等待，而不是再加新线程。任务放到队列中等待。</p><p>一旦任务多到导致任务队列也满了，那么就突破 corePoolSize 限制，<strong>新增线程来处理新的任务（不是丢弃任务）</strong>，<strong>这些新增的线程执行的是新来的任务，而不是任务队列中的任务</strong>。直到线程数达到 maxmumPoolSize 。</p><p>线程数达到 maxmumPoolSize ，同时任务队列也满了，那么这个新任务就无法执行，那么就会调用拒绝策略来处理多余任务：RejectedExecutionHandler</p><p>如果当前线程数超过 corePoolSize (正式员工数) 有没有新的任务给它，那么等 keepAliveTime 时间达到后，就可以把这个线程释放。</p><p> 4.3 线程池的工作机制(时间点 01:14:42-01:25:26) </p><p>刚开始，没有任何的线程和任务：</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/1686143173765-d7c5a389-502e-4ab1-8f65-215ebf603a17.png" alt="img"></p><p>当有新任务进来，发现当前员工数量还未达到设定的正式员工数(corePoolSize &#x3D; 2)，则会直接增聘一名新员工来处理这个任务：</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/1686143402613-f0ecb859-fb26-423b-b47f-a3598c597419.png" alt="img"></p><p>又来一个新任务，发现当前员工数量还未达到设定的正式员工数(corePoolSize &#x3D; 2)，则会再次增聘一名新员工来处理这个任务：</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/1686143443206-1c6371ac-a334-4177-9049-64b13226c279.png" alt="img"></p><p>又来了一个新任务，但是正式员工数已经达到上限(当前线程数 &#x3D; corePoolSize &#x3D; 2)，这个新任务将被放到等待队列中(最大长度 workQueue.size 是 2) ，而不是立即增聘新员工：</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/1686143701965-02167f12-e7e0-4a86-99c9-a3dc575967af.png" alt="img"></p><p>又来了一个新任务，但是我们的任务队列已经满了(当前线程数 &gt; corePoolSize &#x3D; 2，已有任务数 &#x3D; 最大长度 workQueue.size &#x3D; 2)，我们将增设新线程(最大线程数 maximumPoolSize &#x3D; 4)来处理任务，而不是选择丢弃这个任务：</p><p>任务2</p><p>任务1</p><p>线程小李</p><p>任务4</p><p>大</p><p>任务3</p><p>任务队列(备忘录)</p><p>临时工小皮</p><p>线程小王</p><p>任务5</p><p>线程池(公司)</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/1686580374546-1930c16e-644c-41a6-ad89-bae7b1ebd8be.png" alt="image.png"></p><p>当达到七个任务时，由于我们的任务队列已经满了、临时工也招满了(当前线程数 &#x3D; maximumPoolSize &#x3D; 4，已有任务数 &#x3D; 最大长度 workQueue.size &#x3D; 2)，此时我们会采用 RejectedExecutionHandler(拒绝策略)来处理多余的任务：</p><p>任务1</p><p>任务2</p><p>临时工小A</p><p>任务7</p><p>线程小李</p><p>任务4</p><p>任务3</p><p>(拒绝)</p><p>任务队列(备忘录)</p><p>临时工小皮</p><p>线程小王</p><p>任务5</p><p>任务6</p><p>线程池(公司)</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/1686580389962-16ca277b-d6a9-4df8-93ec-8e7f23b7ec2d.png" alt="image.png"></p><p>如果当前线程数超过 corePoolSize (正式员工数)，并且这些额外的线程没有新的任务可执行，那么在 keepAliveTime 时间达到后，这些额外的线程将会被释放。</p><h3 id="线程池实现"><a href="#线程池实现" class="headerlink" title="线程池实现"></a>线程池实现</h3><ol><li>写一个线程池配置，放入到 IOC 容器中</li><li>在业务中使用 IOC 容器的线程池</li><li>编写测试接口调用线程执行任务（注意：<strong>这些接口不能暴露到生产环境，所以要加上 @Profile 注解，标注 dev 和 local 才生效</strong>）</li></ol><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><p><strong>实现工作流程</strong></p><ol><li>给 chart 表新增任务状态字段（比如排队中、执行中、已完成、失败），任务执行信息字段（用于记录任务执行中、或者失败的一些信息）（因为 chart 表是通过 AI 调用之后才会完整填充一行，所以这里可以预先填写信息）</li><li>用户点击智能分析页的提交按钮时，先把图表立刻保存到数据库中，然后提交任务</li><li>任务：先修改图表任务状态为：“执行中”，等执行成功后，修改为 “已完成”、保存执行结果；执行筛败后，状态修改为 “失败”，记录任务失败信息。</li><li>用户可以在图表管理页面查看所有图表（已生成的、生产中的、生成失败）的信息和状态</li><li>用户可以修改生成失败的图表信息，点击重新生成。</li></ol><h3 id="编写和复用错误处理"><a href="#编写和复用错误处理" class="headerlink" title="编写和复用错误处理"></a>编写和复用错误处理</h3><p>对于很多个类似的处理异常情况：  </p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240216113539007.png" alt="image-20240216113539007"></p><p>可以编写一个通用的错误处理：</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240216113624315.png" alt="image-20240216113624315"></p><p>然后直接改成调用这个方法，而不是直接抛出异常。</p><p>这里的话就选择执行相应方法之后直接 return 返回。</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240216122317774.png" alt="image-20240216122317774"></p><p><strong>todo</strong></p><p>然后我们可以将错误的图表，通过重试机制再去生成图表，在限定重试次数内重试成功返回给用户，否则抛出异常。</p><h4 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h4><ol><li><p><strong>guava Retrying 重试机制</strong> 解决 AI 生成多余、错误内容时，重新生成</p></li><li><p>**如果说任务根本没提交到队列中（或者队列满了），是不是可以用个定时任务把它放到队列中 **(补偿机制)</p></li><li><p>建议给任务的执行添加一个<strong>超时时间，超时自动标记为失败</strong></p></li><li><p>提前考虑 AI 生成错误的情况，在后端进行异常处理</p></li><li><p>反向压力<a href="https://www.zhihu.com/column/c_1300384793457553408">编程干货 - 知乎 (zhihu.com)</a> 通过调用的服务状态来选择当前系统的策略（比如根据 AI 服务的当前任务队列数来控制咋们系统的核心线程数），<strong>从而最大化利用系统资源</strong></p></li><li><p>我的图表页面增加一个刷新、定时自动刷新的按钮，保证获取到图表的最新状态（前端轮询）</p></li><li><p>任务执行成功或失败，给用户发送实时消息通知（websocket、 server size event）</p></li></ol><h3 id="给用户发送发送实时消息的一个可行实现："><a href="#给用户发送发送实时消息的一个可行实现：" class="headerlink" title="给用户发送发送实时消息的一个可行实现："></a>给用户发送发送实时消息的一个可行实现：</h3><p>前端接收消息并提示给用户可以通过 WebSocket 实时通信来实现。以下是一个简单的示例代码，演示如何使用 JavaScript 和 WebSocket 接收来自后端的消息并在页面上展示给用户。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Real-time Notification<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;notification&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://localhost:8080/notification&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        socket.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket connection opened&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        socket.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> message = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(event.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">displayNotification</span>(message);</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">displayNotification</span>(<span class="params">message</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> notificationDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;notification&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> notificationMessage = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            notificationMessage.<span class="property">textContent</span> = message;</span></span><br><span class="line"><span class="language-javascript">            notificationDiv.<span class="title function_">appendChild</span>(notificationMessage);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个示例中，前端页面通过 WebSocket 连接到后端的 WebSocket 服务器（假设后端已经实现了 WebSocket 服务器的逻辑）。当后端发送消息给前端时，前端通过监听 <code>socket.onmessage</code> 事件来接收消息，并调用 <code>displayNotification</code> 方法将消息展示在页面上。</p><p>需要注意的是，实际生产环境中，需要根据具体的业务需求和消息格式来解析和展示消息。前端页面也可以根据业务需求定制更丰富的消息提示样式和交互效果。</p><h3 id="异步化生成图表的结果"><a href="#异步化生成图表的结果" class="headerlink" title="异步化生成图表的结果"></a>异步化生成图表的结果</h3><ol><li><strong>提高安全性，避免大量调用 AI 接口：</strong></li></ol><p>我们通过图表生成的异步化操作，利用线程池，可以保证系统的安全性，避免大量请求进入导致 AI 调用系统崩溃。</p><ol start="2"><li><strong>提高单个用户生成图表的效率：</strong></li></ol><p>之前调用生成图表接口，需要等待图表生成完毕后才能再次调用接口。需要花费挺多时间。</p><p>利用异步化操作，可以让<strong>调用图表生成过程和 AI 调用过程分离开</strong>，开辟新的线程去调用 AI ，而调用图表生成的接口 gen 可以更快返回结果，这个结果是一个临时结果，可以表示此时 AI 生成的状态（待完成、正在执行、已完成、失败的），而这个 gen 接口的调用已经结束了，用户可以立即再次调用接口去生成新的图表，无需等待之前的图表生成完毕才能调用。</p><ol start="3"><li>用户调用接口后，<strong>可以去我的图表下查看生成的图表</strong></li></ol><h1 id="第六期"><a href="#第六期" class="headerlink" title="第六期"></a>第六期</h1><ol><li>分析系统现在的不足</li><li>分布式消息队列</li><li>分布式消息队列 RabbitMQ 入门实战</li><li>项目拓展</li></ol><h2 id="分析系统现状不足"><a href="#分析系统现状不足" class="headerlink" title="分析系统现状不足"></a>分析系统现状不足</h2><p>已经经过了同步到异步的改造？</p><p>现状：目前的异步是通过 <strong>本地</strong> 的线程池实现的</p><ol><li><strong>无法集中限制，只能单机限制</strong></li></ol><p>假如 AI 服务限制只能有两个用户同时使用，单个线程池可以限制最大核心线程数为 2 来实现。</p><p>假设系统用量增大，改为分布式、多台服务器，每个服务器都要有两个线程，就可能有 2N 哥线程，超过了 AI 服务的限制</p><p>解决方案：在一个集中的地方去管理下发任务（比如集中存储当前正在执行的任务数）</p><ol start="2"><li>任务由于是放在内存中执行的，可能会丢失</li></ol><blockquote><p>虽然可以人工从数据库捞出来再重试，但是其实需要额外开发（比如定时任务），这种重试的场景是非常典型的，其实是不需要我们开发者过于关心、或者自己实现的。</p></blockquote><p>解决方案：把任务放在一个可以持久化存储的硬盘</p><ol start="3"><li>优化：如果你的系统功能越来越多，长耗时任务越来越多，系统会越来越复杂（比如要开多个线程池、资源可能会出现项目抢占） ，其实我们可以把长耗时，消耗很多的任务把它单独抽成一个程序，不要影响主业务。</li></ol><p>解决方案：可以有一个中间人，让中间人帮我们去连接两个系统（比如核心系统和智能生成业务）</p><h2 id="分布式消息队列（学习方式：完整地去看官方文档的教程，讲的很详细，也很好理解，英文看不懂就先用浏览器翻译，如果还是看不懂就用-GPT-翻译）"><a href="#分布式消息队列（学习方式：完整地去看官方文档的教程，讲的很详细，也很好理解，英文看不懂就先用浏览器翻译，如果还是看不懂就用-GPT-翻译）" class="headerlink" title="分布式消息队列（学习方式：完整地去看官方文档的教程，讲的很详细，也很好理解，英文看不懂就先用浏览器翻译，如果还是看不懂就用 GPT 翻译）"></a>分布式消息队列（学习方式：完整地去看官方文档的教程，讲的很详细，也很好理解，英文看不懂就先用浏览器翻译，如果还是看不懂就用 GPT 翻译）</h2><p>中间件：</p><p>Redis、消息队列、分布式存储 Etcd</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217093650439.png" alt="image-20240217093650439"></p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>存放消息的队列。</p><p>队列特点：先进先出</p><p>消息：某种数据结构，比如字符串、对象、二进制数据、 json 等等</p><p>存储：存数据</p><p>消息队列相较于 Feign 接口的区别：</p><p>消息队列可以存储数据，而 Feign 接口就相当于一个 HTTP 请求，发送完就消失了。</p><p>应用场景：在多个不同的系统、应用之间进行数据的传输。</p><h4 id="消息队列的模型"><a href="#消息队列的模型" class="headerlink" title="消息队列的模型"></a>消息队列的模型</h4><p>生产者： Producer</p><p>消费者： Consumer</p><p>消息： Message</p><p>消息队列： Queue</p><p><strong>为什么要用消息队列？</strong></p><ol><li><p>异步处理</p><p>生产者发送完消息之后，可以继续去忙别的，消费者想什么时候消费都可以，不会产生阻塞。</p></li><li><p>削峰填谷</p><p>先把用户的请求放到消息队列中，消费者可以按照自己的需求，慢慢去取。</p></li></ol><p><strong>分布式消息队列的优势</strong></p><ol><li>数据持久化：它可以把消息集中存储到硬盘里，服务器重启就不会丢失</li><li>可拓展性：可以根据需求，随时增加或减少节点，继续保持稳定的服务</li><li>应用解耦：可以连接各个不同语言、框架开发的系统，让这些系统能够灵活传输读取数据</li></ol><p><a href="https://developer.aliyun.com/article/769883">超详细的RabbitMQ入门，看这篇就够了！-阿里云开发者社区 (aliyun.com)</a></p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217100111155.png" alt="image-20240217100111155"></p><ol start="4"><li><p>发布订阅</p><p>如果一个非常大的系统要给其他子系统发送通知，最简单直接的方式是大系统直接依次调用小系统。</p></li></ol><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217101137550.png" alt="image-20240217101137550"></p><h4 id="消息队列的应用场景"><a href="#消息队列的应用场景" class="headerlink" title="消息队列的应用场景"></a>消息队列的应用场景</h4><ol><li>耗时的场景（异步）</li><li>高并发场景（异步、削峰填谷）</li><li>分布式系统协作（尤其是跨团队、跨业务协作、应用解耦）</li><li>强稳定性的场景（比如金融业务、持久化、可靠性、削峰填谷）</li></ol><h4 id="消息队列的缺点"><a href="#消息队列的缺点" class="headerlink" title="消息队列的缺点"></a>消息队列的缺点</h4><p>要给系统引入额外的中间件，系统会更复杂、额外维护中间件、额外的费用成本</p><p>消息队列：消息丢失、顺序性、重复消息、数据的一致性（分布式系统就要考虑）</p><blockquote><p>也可以教分布式场景需要考虑的问题</p></blockquote><h3 id="主流分布式消息队列选型"><a href="#主流分布式消息队列选型" class="headerlink" title="主流分布式消息队列选型"></a>主流分布式消息队列选型</h3><ol><li>activemq</li><li>rabbitmq</li><li>kafka</li><li>rocketmq</li><li>zeromq</li><li>pulsar</li><li>Tube（Apache InLong）</li></ol><p><strong>技术对比</strong></p><p>技术选型指标：</p><ul><li>吞吐量： IO 、并发</li><li>时效性：类似延迟、消息的发送、到达时间</li><li>可用性：系统可用的比率（比如一年 365 天宕机 1s）</li><li>可靠性：消息不丢失（比如不丢失订单）</li></ul><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217103217497.png" alt="image-20240217103217497"></p><h3 id="RabbitMQ-入门实战"><a href="#RabbitMQ-入门实战" class="headerlink" title="RabbitMQ 入门实战"></a>RabbitMQ 入门实战</h3><p>特点：生态好，好学习，易于理解，时效性强，支持多种不同语言的客户端。</p><p>生产者：发消息的</p><p>消费者：收消息的</p><p>交换机（Exchange） ：负责把消息转发到对应的队列</p><p>队列 （Queue）：存储消息的</p><p>路由 (Routes) ：转发，就是把消息从一个地方转到领域给地方，比如从生产者转发到某个队列。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p><a href="https://www.rabbitmq.com/install-windows.html">在 Windows 上安装 — 兔子MQ (rabbitmq.com)</a></p><p>安装 erlang（必须先安装好了，才能安装 rabbitMQ）</p><p> [Otp 25.3.2 - Erlang&#x2F;OTP</p><p><a href="https://www.erlang.org/patches/otp-25.3.2"></a></p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217202213399.png" alt="image-20240217202213399"></p><p>安装 rabbitmq</p><p>[在 Windows 上安装 — 兔子MQ (rabbitmq.com)</p><p><a href="https://www.rabbitmq.com/install-windows.html"></a></p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217202226668.png" alt="image-20240217202226668"></p><p>安装完成后，它会自动启动 rabbitMQ，我们可以通过服务管理器来查看：</p><p>直接在搜索框搜索服务即可找到：</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217203052055.png" alt="image-20240217203052055"></p><p>安装rabbitmq 监控面板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure><p>管理页面的默认的账号密码是 guest</p><p>如果想要在远程服务安装访问 rabbitmq 的管理面板，需要自己创建一个管理员账号，不能用默认的 guest ，否则会被拦截。（官方出于安全考虑）</p><p>如果被拦截，可以添加一个用户 User</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217110125109.png" alt="image-20240217110125109"></p><p><strong>Java 客户端</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.rabbitmq/amqp-client --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.17.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>标准端口：</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217113532455.png" alt="image-20240217113532455"></p><p>使用教程：</p><p><a href="https://www.rabbitmq.com/tutorials/tutorial-one-java.html">RabbitMQ 教程 - “Hello World！” — 兔子MQ</a></p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217211813567.png" alt="image-20240217211813567"></p><h5 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h5><p>发送消息的教程十分简单，只需要创建一个连接，设置消息队列的 Host</p><p>创建频道，声明队列，发送消息即可。</p><p>详细看官方文档：</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217112806177.png" alt="image-20240217112806177"></p><p>声明队列的四个参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 参数介绍</span></span><br><span class="line"><span class="comment">  * 1.队列名称 QueueName</span></span><br><span class="line"><span class="comment">  * 2.是否持久化 durable</span></span><br><span class="line"><span class="comment">  * 3.是否是排他性队列 (只允许首次声明它的连接 (Connection) 可见，其他用户都不可访问) exclusive</span></span><br><span class="line"><span class="comment">  * 4.是否自动删除 (当没有生产者或者消费者使用此队列，该队列会自动删除) autoDelete</span></span><br><span class="line"><span class="comment">  * 5.队列的其他参数 arguments</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleProducer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 创建连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 设置 rabbitMQ 的服务地址</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取连接对象</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">// 创建通道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数介绍</span></span><br><span class="line"><span class="comment">         * 1.队列名称</span></span><br><span class="line"><span class="comment">         * 2.是否持久化</span></span><br><span class="line"><span class="comment">         * 3.是否是排他性队列 (只允许首次声明它的连接 (Connection) 可见，其他用户都不可访问)</span></span><br><span class="line"><span class="comment">         * 4.是否自动删除 (当没有生产者或者消费者使用此队列，该队列会自动删除)</span></span><br><span class="line"><span class="comment">         * 5.队列的其他参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 任意字符串作为 message</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">        <span class="comment">// 发布消息</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动该 main 方法后，可以在管理界面看到队列的生产和相应的消息：</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217210145799.png" alt="image-20240217210145799"></p><p>接收消息：</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217112651892.png" alt="image-20240217112651892"></p><p>接收消息的实现也非常简单，参照官方文档即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleConsumer</span> &#123;</span><br><span class="line">    <span class="comment">// 队列名称和要接收的队列名称一致</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 设置 RabbitMQ 的 Host</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">// 创建通道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列,要和发布者的队列声明一致。</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 接收消息</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Received &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数表示</span></span><br><span class="line"><span class="comment">         * 1. 队列名称</span></span><br><span class="line"><span class="comment">         * 2. 是否自动 ACK</span></span><br><span class="line"><span class="comment">         * 3. 消息回调参数，指定了接收到的消息的具体执行方案</span></span><br><span class="line"><span class="comment">         * 4， 空的一个 Lambda 表达式</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, deliverCallback,  consumerTag -&gt; &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中比较重要的一个点：</p><p>让消费者被阻塞（线程不会结束），这样能够持续地消费消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br></pre></td></tr></table></figure><p>一旦又接收到消息，就再去调用 deliverCallback 消息回调。</p><h4 id="消息队列的一些配置"><a href="#消息队列的一些配置" class="headerlink" title="消息队列的一些配置"></a>消息队列的一些配置</h4><p><strong>队列持久化</strong></p><p>durable 参数设置为 true ，服务器重启后队列不丢失：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(TASK_QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p><strong>消息持久化</strong></p><p>指定  MessageProperties.PERSISTENT_TEXT_PLAIN,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, TASK_QUEUE_NAME,</span><br><span class="line">        MessageProperties.PERSISTENT_TEXT_PLAIN,</span><br><span class="line">        message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="WorkQueue"><a href="#WorkQueue" class="headerlink" title="WorkQueue"></a>WorkQueue</h3><p>上面的演示是一对一的模式，现在来看一下一对多：</p><p><a href="https://www.rabbitmq.com/tutorials/tutorial-two-java.html">RabbitMQ 教程 - 工作队列 — 兔子MQ</a></p><h4 id="多消费者"><a href="#多消费者" class="headerlink" title="多消费者"></a>多消费者</h4><p>若单个消费者处理速度慢，会导致消息积压在消息队列中，我们要如何处理？</p><p><strong>可以通过加入更多的消费者</strong></p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217211722274.png" alt="image-20240217211722274"></p><p> 控制单个消费者的处理任务积压数：</p><p>下述代码表示每个 channel 最多同时处理 1 个任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicQos(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>可以通过 for 循环，定义多个 channel ，实现对同一个队列的消费。</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217165418974.png" alt="image-20240217165418974"></p><p>这里的 Thread.sleep 会让每个消费者在执行回调时，睡 20s ，但是这并不影响 for 循环的运行，因为这相当于开了一个新线程，让新线程去睡 20s 而原来的主线程仍然在运行。</p><p>仍然运行的主线程会创建新的channel，并声明相同的队列，就可以同时消费同一个队列。</p><p><strong>多消费者代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mulConsumer</span> &#123;</span><br><span class="line">    <span class="comment">// 队列名称和要接收的队列名称一致</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 设置 RabbitMQ 的 Host</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">// 创建通道</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">            <span class="comment">// 让消费者消费完一个消息后才能消费下一个</span></span><br><span class="line">            channel.basicQos(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 声明队列,要和发布者的队列声明一致。</span></span><br><span class="line">            channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 接收消息，这其实相当于开辟了新线程去执行 deliverCallback 的处理</span></span><br><span class="line">            <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">                <span class="comment">// 测试多消费者情况，加入休眠,模拟消费任务繁忙的情况</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot; [x] Received &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">20000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// ack 消息</span></span><br><span class="line">                channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 参数表示</span></span><br><span class="line"><span class="comment">             * 1. 队列名称</span></span><br><span class="line"><span class="comment">             * 2. 是否自动 ACK</span></span><br><span class="line"><span class="comment">             * 3. 消息回调参数，指定了接收到的消息的具体执行方案</span></span><br><span class="line"><span class="comment">             * 4， 空的一个 Lambda 表达式</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicConsume(QUEUE_NAME, <span class="literal">false</span>, deliverCallback,  consumerTag -&gt; &#123; &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过向消费者快速发送 2 个消息，可以看到两个消息都被成功接收并执行回调，而后续在 20s 内再发送的消息就无法立刻被接收了，说明两个消费者都现在都在 Thread.sleep(20000) 的状态，无法处理新的消息。</p><h5 id="消息确认机制"><a href="#消息确认机制" class="headerlink" title="消息确认机制"></a>消息确认机制</h5><p>为了保证消息成功被消费（快递成功被取走），rabbitmq 提供了消息确认机制，当消费者接收到消息后，比如要给一个反馈：</p><ol><li>ack：消费成功</li><li>nack：消费失败</li><li>reject：拒绝</li></ol><p>如果告诉 rabbitmq 服务器消费成功，服务器才会放心地移除消息</p><p>支持配置 autoack，会自动执行 ack 命令，即一旦接收到消息就立刻 ack ，一般不建议设置为 true， 因为虽然消息接收成功了，也可能在其他业务流程中会出现失败，可能需要重试消息。</p><p>channel.basicConsume(TASK_QUEUE_NAME, false, deliverCallback, consumerTag -&gt;{}) </p><p>建议 autoack 为 false， 根据实际情况再去做手动确认。</p><p>指定确认某条消息：</p><p>第二个参数 multiple 是指是否要一次性确认所有的历史消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>指定拒绝某条消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicReject(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>两个小技巧：</p><ol><li>使用 Scanner 接收用户输入，便于快速发送消息</li><li>使用 for 循环实现多个消费者，便于快速验证队列模型工作机制</li></ol><h3 id="交换机-Exchanges"><a href="#交换机-Exchanges" class="headerlink" title="交换机 Exchanges"></a>交换机 Exchanges</h3><p>一个生产者给 **多个 ** 队列发消息， 1 个生产者对多个队列。</p><p>交换机的作用：类似于网络路由器，提供转发功能。</p><p>解决问题：怎么把消息转发到不同的队列上，好让消费者从不同的队列消费。</p><p>交换机有多种类别：</p><ol><li>fanout</li><li>direct</li><li>topic</li><li>headers</li></ol><h4 id="发布订阅场景"><a href="#发布订阅场景" class="headerlink" title="发布订阅场景"></a>发布订阅场景</h4><p><a href="https://www.rabbitmq.com/tutorials/tutorial-three-java.html">RabbitMQ 教程 - 发布&#x2F;订阅 — 兔子MQ</a></p><p>顾名思义，就如我们平时在视频网站上关注 up 主的情况类似， up 主发布了视频（相当于发布消息），所有关注了这个 up 主的用户都会接收到视频推送（消费者接收消息）。</p><p><strong>fanout</strong></p><p>扇出、广播</p><p>特点：消息会被发送到每个绑定了这个交换机的队列</p><p>场景：很适用于发布订阅的场景，比如发布日志。 </p><p>场景示例：</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217172803517.png" alt="image-20240217172803517"></p><p><strong>生产消息：</strong></p><p>现在生产者只需要向交换机发送消息，交换机会自动将消息发送到所有绑定了这个交换机的队列：</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217172657926.png" alt="image-20240217172657926"></p><p>上图代码可以看出来，就是对着交换机发送消息的。</p><p><strong>fanout 生产者的代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutProducer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;fanout_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 创建连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 设置 RabbitMQ 的 Host</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="comment">// 生成连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">// 创建通道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 创建 扇出 fanout 交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            <span class="comment">// 发送消息到交换机</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 参数介绍</span></span><br><span class="line"><span class="comment">             * 1，交换机名称</span></span><br><span class="line"><span class="comment">             * 2.routingKey，只有绑定了相同的 routingKey 的队列才能接收到该消息，不设置就表明任何的队列都可以接收到消息</span></span><br><span class="line"><span class="comment">             * 3.props，消息的属性</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;&quot;</span>, <span class="literal">null</span>, message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费消息：</strong></p><p>让消费者绑定同一个交换机</p><p>注意，下述代码缺失了创建队列的内容，<strong>要提前先声明队列</strong></p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217172823596.png" alt="image-20240217172823596"> </p><p>基于命名的队列和随机命名的队列的 Java 代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConsumer</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;fanout_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME , <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">// 随机生成队列名称并声明队列,fanout 的发布订阅模式对于具体的某一个消费者情况是可以不在乎的，因此随机的名称也是可以的</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 绑定交换机</span></span><br><span class="line"><span class="comment">         * 参数介绍</span></span><br><span class="line"><span class="comment">         * 1.队列名称</span></span><br><span class="line"><span class="comment">         * 2.交换机名称</span></span><br><span class="line"><span class="comment">         * 3.routingKey，路由键,如果设置为空字符串，则任何发送到该交换机的消息都会被路由到该队列</span></span><br><span class="line"><span class="comment">         * 如果设置成其他的字符串，那么发送到该交换机的消息，只有routingKey与该字符串相匹配的消息才会被路由到该队列</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// 当然，你也可以指定一个队列名称，便于生产者和消费者进行管理</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;小方的专属消息队列&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 绑定第二个队列到相同的交换机-</span></span><br><span class="line">        channel.queueBind(<span class="string">&quot;小方的专属消息队列&quot;</span>, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消息回调1</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback1</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; [随机名称队列] Received &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 消息回调2</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback2</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; [小方队列] Received &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback1, consumerTag -&gt; &#123;&#125;);</span><br><span class="line">        channel.basicConsume(<span class="string">&quot;小方的专属消息队列&quot;</span>, <span class="literal">true</span>, deliverCallback2, consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以执行上述两个代码，从消费者控制台中看到，所有绑定了相同交换机的队列都会接收到消息</p><h1 id="第七期"><a href="#第七期" class="headerlink" title="第七期"></a>第七期</h1><blockquote><p>鱼哥这一期讲的 rabbitMQ 的 demo 部分并没有阅读完整 官方文档，要再看一遍。</p></blockquote><h3 id="路由绑定"><a href="#路由绑定" class="headerlink" title="路由绑定"></a>路由绑定</h3><p><a href="https://www.rabbitmq.com/tutorials/tutorial-four-java.html">RabbitMQ 教程 - 路由 — 兔子MQ</a></p><h4 id="Direct-交换机"><a href="#Direct-交换机" class="headerlink" title="Direct 交换机"></a>Direct 交换机</h4><p>绑定：可以让交换机和队列进行关联，可以指定让交换机把什么样的消息发送机给哪个队列。</p><p>routingKey ： 路由键，控制消息要转发给哪个队列的（IP 地址）</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240219085131288.png" alt="image-20240219085131288"></p><p>也就是说，咋们通过利用 Direct 交换机，并且在发布消息时，指定相应的 routingKey，就可以让只订阅了相同 routingKey 的队列的消费者收到消息。</p><p><strong>这个路由键是可以绑定多个队列的</strong></p><p>即：一个路由键，可以绑定多个绑定了同样路由键的队列。</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240219090659270.png" alt="image-20240219090659270"></p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240219090846330.png" alt="image-20240219090846330"></p><p>可以看的出来，只要指定相应的 routingKey，相应的队列就只会接受这个 routingKey 的消息。</p><h5 id="小尝试："><a href="#小尝试：" class="headerlink" title="小尝试："></a>小尝试：</h5><ol><li>试试看让消费者的 routingKey 设置为 “” ，然后生产者指定一个 routingKey 来发送消息，看看结果如何？</li></ol><h4 id="Direct-交换机-Demo-实现"><a href="#Direct-交换机-Demo-实现" class="headerlink" title="Direct 交换机 Demo 实现"></a>Direct 交换机 Demo 实现</h4><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">    <span class="comment">// 从工厂创建连接</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">         <span class="comment">// 创建通道</span></span><br><span class="line">         <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel()) &#123;</span><br><span class="line">        <span class="comment">// 声明交换机类型为 direct</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;xiaofang&quot;</span>, <span class="literal">null</span>,</span><br><span class="line">                    message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] 发送给小方的消息&quot;</span> + message + <span class="string">&quot;:&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">    <span class="comment">// 声明交换机</span></span><br><span class="line">    channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">    <span class="comment">// 随机声明队列名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">    <span class="comment">// 队列绑定交换机,第三个参数声明 routingKey，确定路由</span></span><br><span class="line">    channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;xiaofang&quot;</span>);</span><br><span class="line">    <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; [x] 小方收到了 &#x27;&quot;</span> +</span><br><span class="line">            delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;&#x27;:&#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Topic-交换机"><a href="#Topic-交换机" class="headerlink" title="Topic 交换机"></a>Topic 交换机</h3><blockquote><p>需求引入：我们之前给消费者的消息的 routingKey 是不可再分的，但是对于一类消息，消费者可能有更细致的需求，比如买东西，有的人需要买家电，有的人需要买果蔬，在情况少的时候，我们可以指定更多的 routingKey 来囊括所有的情况，但是倘若类别太多了，就无法一一地创建 routingKey 了，那么我们就希望有一个能够只固定父级类别，但能区分更多细分情况的消息发送机制。</p></blockquote><p>以路由键集合的方式发送消息。</p><p>特点：消息会根据一个 <strong>模糊的</strong> 路由键转发到指定的队列</p><p>场景：特定的一类消息可以交给特定的一类系统（程序）来处理</p><p>绑定关系：可以模糊匹配多个绑定</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240219092838467.png" alt="image-20240219092838467"></p><p>图表标识含义：</p><ol><li><code>*</code> (星号) ：可以任意匹配一个单词， 不如 *. orange , 那么 a.orange ， b.roange 都能匹配</li><li><code>#</code> （井号）：可以匹配任意长度的字符。</li></ol><p><strong>点号是用来分割字符的，比如上面的 orange ，它就只能包含两个任意单词和固定单词orange，不能出现四个单词以上的组合。</strong></p><p>参考官方文档的说明：<img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240219222803795.png" alt="image-20240219222803795"></p><p>注意：上面的图的示例中都带了一个 <code>.</code>  （点），这是用来分割字符的，是消息队列用来区分通配符还是固定字符的。所以我们在使用 #通配符的时候，要注意加上 <code>.</code> （点），<strong>不能用别的符号来区分字符。</strong> （不能直接用 #lazy，而要用 lazy.#）</p><h4 id="Topic-Demo-实现"><a href="#Topic-Demo-实现" class="headerlink" title="Topic Demo 实现"></a>Topic Demo 实现</h4><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopicProducer</span> &#123;</span><br><span class="line">    <span class="comment">// 定义交换机名称为&quot;direct-exchange&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic-exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建连接工厂对象</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 设置消息队列的主机地址为本地主机</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建连接和通道，并确保资源自动关闭</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">             <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel()) &#123;</span><br><span class="line">            <span class="comment">// 声明使用主题交换机，并指定交换机名称和类型</span></span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line">            <span class="comment">// 创建一个扫描器对象，从控制台读取用户输入</span></span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">                <span class="comment">// 读取用户输入的一行文本</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">userInput</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                <span class="comment">// 使用空格分隔用户输入的文本</span></span><br><span class="line">                String[] strings = userInput.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="comment">// 如果分隔后的文本长度小于2，则跳过当前循环</span></span><br><span class="line">                <span class="keyword">if</span> (strings.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 获取用户输入的消息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> strings[<span class="number">0</span>];</span><br><span class="line">                <span class="comment">// 获取用户输入的路由键</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> strings[<span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 发布消息到指定的交换机和路由键</span></span><br><span class="line">                channel.basicPublish(EXCHANGE_NAME, routingKey, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                <span class="comment">// 打印消息发送的提示信息，包含消息内容和路由键</span></span><br><span class="line">                System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot; with routing:&quot;</span> + routingKey + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopicConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic-exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;frontend_queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;#.frontend.#&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;收到前端消息&quot;</span> + message);</span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">false</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h5><p>支持用消息队列来模拟 RPC 的调用。但是一般没必要，用 Dubbo、GRPC 等 RPC 框架就好。</p><h3 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h3><p><strong>消息过期机制</strong></p><p>可以给每条消息指定一个有效期，一段时间内未被消费者处理，就过期了。</p><p>示例场景：用户下单后，长时间未付款，消息自动取消。</p><p>适用场景：清理过期数据、模拟延迟队列的实现。</p><p>不过有一些细节：</p><p>消息队列的发送的过期消息如果已经被消费者接收，但是消费者在执行过程中长时间未 ACK ，这种情况消息是不会受到过期时间影响而继续计时的。直到消息真正被消费者 ACK 为止。</p><p>但是，需要注意的是，如果消息处于待消费状态（即未被消费者消费中），并且过期时间到达后，消息将被标记为过期。</p><h3 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h3><p>为了保证消息的可靠性，比如每条消息都成功消费，需要提供一个容错机制，即：失败的消息怎么处理？</p><p>死信：过期的消息、拒收的消息，消息队列满了，处理失败的消息的统称。</p><p>死信队列：专门处理死信的队列（注意：它就是一个普通队列，只不过是专门用来处理死信的，你可以理解成这个队列的名称叫做 “死信队列”）</p><p>死信交换机：专门给死信队列转发消息的交换机（它也是一个普通交换机，但是它是给） 死信交换机可以根据情况将消息发送到不同的死信队列。</p><p>对于一些消费者无法处理的消息，它拒绝之后不需要把这个消息丢到垃圾桶不要了，可以拿一个死信队列来装这些消息。<img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240219103354336.png" alt="image-20240219103354336"></p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><ol><li><p>创建死信交换机和死信队列</p></li><li><p>给失败之后需要容错处理的队列绑定死信交换机</p></li><li><p>可以给要容错的队列指定死信之后的转发规则，死信应该再转发到哪个死信队列？</p></li><li><p>可以通过程序来读取死信队列中的信息，来做一些后续的容错处理。（即同样采取和消费普通队列的方式来消费在死信队列中的消息。）</p></li></ol><h3 id="RabbitMQ-的重要特性"><a href="#RabbitMQ-的重要特性" class="headerlink" title="RabbitMQ 的重要特性"></a>RabbitMQ 的重要特性</h3><blockquote><p>面试考点</p></blockquote><ol><li><p>消息队列的概念、模型、应用场景</p></li><li><p>交换机的类别、路由绑定的关系</p></li><li><p><strong>消息可靠性</strong></p><ol><li>消息确认机制 （ack，nack，reject）</li><li>消息持久化（durable）</li><li>消息过期机制</li><li>死信队列</li></ol></li><li><p>延迟队列（类似死信队列）</p></li><li><p>顺序消费、消费幂等性</p></li><li><p>可拓展性 （仅做了解）</p><ol><li>集群</li><li>故障的恢复机制</li><li>镜像</li></ol></li><li><p>运维监控告警（仅做了解）</p></li></ol><h2 id="RabbitMQ-小测试"><a href="#RabbitMQ-小测试" class="headerlink" title="RabbitMQ 小测试"></a>RabbitMQ 小测试</h2><ol><li>在百万级数据量的情况下向交换机发送消息，消息队列的每秒处理平均速度为 25000 条消息，可以据此情况来设定单轮向 MQ 发送的消息数目，来控制并发量。</li></ol><h3 id="RPC-实现"><a href="#RPC-实现" class="headerlink" title="RPC 实现"></a>RPC 实现</h3><p>requestQueueName ：提供服务调用者发送参数的队列，是调用服务的初始使用队列</p><p>回调队列：由服务调用者生成，供服务提供者返回服务调用结果给服务调用者的队列</p><p>CorrId ：用来判断是哪个服务调用者消息。将其发送到对应的回调队列</p><p>生产者和消费者不再固定，而是变化的，服务的调用者先发送消息（相当于将请求参数传递给远程方法），服务的提供者接收到消息，在回调中调用服务方法，然后在作为生产者发送消息 (方法调用的结果)  给服务调用者。</p><p><strong>关键代码</strong></p><p>回调队列的生成</p><ol><li>回调队列名称。（可以唯一 ，也就是让同一个客户端的所有的 RPC 请求都使用同一个回调队列 ）</li><li>生成随机的 corrId ，用来判断 RPC 请求是否匹配当前的请求(因为一个客户端可能在短时间内发送多条 RPC 请求，如果都是发送到同一个回调队列，那么就需要有一个唯一值来判断请求的归属)，如果匹配，那么就接收调用结果。</li></ol><p>corrId 的设置可以让客户端只使用单独的回调队列实现 RPC，不必为每个请求都创建 RPC ，可以提高客户端调用请求的效率。</p><p><strong>生产者代码（服务提供者）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RPC 实现原理</span></span><br><span class="line"><span class="comment"> * 没有完全固定的消费者和生产者，服务提供者既是消费者又是生产者</span></span><br><span class="line"><span class="comment"> * 生产者发送请求消息，消费者接收请求消息并处理，然后将结果返回给请求方</span></span><br><span class="line"><span class="comment"> * 请求方等待接收结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RPCServer</span> &#123;</span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RPC_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;rpc_queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 定义斐波那契函数，提供服务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        channel.queueDeclare(RPC_QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        channel.queuePurge(RPC_QUEUE_NAME);</span><br><span class="line"></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot; [x] Awaiting RPC requests&quot;</span>);</span><br><span class="line">        <span class="comment">// 从客户端(消费者)处收到调用方法的消息，编写回调函数，处理消费者请求，目标是调用斐波那契函数返回结果</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 回调参数,从客户端设置好的回调参数中取出响应的 corrId(是唯一的，因为客户端调用的每个方法都统一使用同一个回调队列)</span></span><br><span class="line">            AMQP.<span class="type">BasicProperties</span> <span class="variable">replyProps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties</span><br><span class="line">                    .Builder()</span><br><span class="line">                    .correlationId(delivery.getProperties().getCorrelationId())</span><br><span class="line">                    .build();</span><br><span class="line">            <span class="comment">// 响应结果</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取客户端的消息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(message);</span><br><span class="line">                <span class="comment">// 调用函数</span></span><br><span class="line">                System.out.println(<span class="string">&quot; [.] fib(&quot;</span> + message + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">                response += fib(n);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot; [.] &quot;</span> + e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 发送消息到回调队列,这个 routingKey 参数实际上是队列名称参数</span></span><br><span class="line">                channel.basicPublish(<span class="string">&quot;&quot;</span>, delivery.getProperties().getReplyTo(), replyProps, response.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        channel.basicConsume(RPC_QUEUE_NAME, <span class="literal">false</span>, deliverCallback, (consumerTag -&gt; &#123;&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RPCClient</span> <span class="keyword">implements</span> <span class="title class_">AutoCloseable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Connection connection;</span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">requestQueueName</span> <span class="operator">=</span> <span class="string">&quot;rpc_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RPCClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line"></span><br><span class="line">        connection = factory.newConnection();</span><br><span class="line">        channel = connection.createChannel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">RPCClient</span> <span class="variable">fibonacciRpc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RPCClient</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">i_str</span> <span class="operator">=</span> Integer.toString(i);</span><br><span class="line">                System.out.println(<span class="string">&quot; [x] Requesting fib(&quot;</span> + i_str + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> fibonacciRpc.call(i_str);</span><br><span class="line">                System.out.println(<span class="string">&quot; [.] Got &#x27;&quot;</span> + response + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | TimeoutException | InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">(String message)</span> <span class="keyword">throws</span> IOException, InterruptedException, ExecutionException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">corrId</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">replyQueueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">        AMQP.<span class="type">BasicProperties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties</span><br><span class="line">                .Builder()</span><br><span class="line">                .correlationId(corrId)</span><br><span class="line">                .replyTo(replyQueueName)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, requestQueueName, props, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> CompletableFuture&lt;String&gt; response = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (delivery.getProperties().getCorrelationId().equals(corrId)) &#123;</span><br><span class="line">                response.complete(<span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">ctag</span> <span class="operator">=</span> channel.basicConsume(replyQueueName, <span class="literal">true</span>, deliverCallback , consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> response.get();</span><br><span class="line">        channel.basicCancel(ctag);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的 RabbitMQ 的特性可以看官方文档：</p><blockquote><p>说实话，我感觉 RabbitMQ 的官方文档是真的比别的文档好读多了。</p></blockquote><p><a href="https://www.rabbitmq.com/documentation.html">Documentation: Table of Contents — RabbitMQ</a></p><p>这个部分值得一看，更多的特性，比如死信、惰性队列等。</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240220104510159.png" alt="image-20240220104510159"></p><h3 id="RabbitMQ-项目实战"><a href="#RabbitMQ-项目实战" class="headerlink" title="RabbitMQ 项目实战"></a>RabbitMQ 项目实战</h3><p>怎么在项目中使用 RabbitMQ </p><ol><li><strong>使用官方的客户端。</strong>（推荐）</li></ol><p>优点：兼容性好，换语言成本低，比较灵活</p><p>缺点：太灵活，要自己去处理一些事情，比如要自己维护管理链接，很麻烦。</p><ol start="2"><li><strong>使用封装好的客户端，比如 Spring Boot RabbitMQ Starter</strong></li></ol><p>优点：简单易用，直接配置直接用</p><p>缺点：封装的太好了，不去学习不知道怎么使用</p><p><strong>引用的注意点</strong></p><p>引用的依赖版本要和 Spring Boot 版本对应。 非常重要！！！ 比如 Spring Boot 是 2.7.12 ，那么依赖也要是  2.7.12 或者是接近的。或者查看官方的版本依赖参照。</p><p>文档在此，没错，我的英语水平很高😭：</p><p><a href="https://spring.io/guides/gs/messaging-rabbitmq">入门 |使用 RabbitMQ 进行消息传递 (spring.io)</a></p><p>官方文档里的发送消息的测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.messagingrabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.CommandLineRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runner</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Runner</span><span class="params">(Receiver receiver, RabbitTemplate rabbitTemplate)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line">    <span class="built_in">this</span>.rabbitTemplate = rabbitTemplate;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Sending message...&quot;</span>);</span><br><span class="line">   <span class="comment">// 关键点在下一行，这是发送消息的主要代码:</span></span><br><span class="line">    rabbitTemplate.convertAndSend(MessagingRabbitmqApplication.topicExchangeName, <span class="string">&quot;foo.bar.baz&quot;</span>, <span class="string">&quot;Hello from RabbitMQ!&quot;</span>);</span><br><span class="line">    receiver.getLatch().await(<span class="number">10000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基础使用（先使用-SpringBoot-的客户端写一个测试方法）"><a href="#基础使用（先使用-SpringBoot-的客户端写一个测试方法）" class="headerlink" title="基础使用（先使用 SpringBoot 的客户端写一个测试方法）"></a>基础使用（先使用 SpringBoot 的客户端写一个测试方法）</h4><ol><li>引入依赖 （ SpringBoot 的配置）</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!--  Spring 的消息队列启动器   --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-amqp --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>编写配置</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置 rabbitmq</span></span><br><span class="line"> <span class="attr">rabbitmq:</span></span><br><span class="line">   <span class="attr">port:</span>  <span class="number">5672</span></span><br><span class="line">   <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">   <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">   <span class="attr">host:</span> <span class="string">localhost</span></span><br></pre></td></tr></table></figure><ol start="3"><li>编写生产者代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMessageProducer</span> &#123;</span><br><span class="line">    <span class="comment">// 使用启动器自带的 rabbitTemplate，进行消息发送</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息，指定交换机，路由key，消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange 交换机名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> routingKey 路由键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 具体发送的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String exchange, String routingKey, String message)</span> &#123;</span><br><span class="line">        <span class="comment">// 外部做参数校验</span></span><br><span class="line">        rabbitTemplate.convertAndSend(exchange, routingKey, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>编写消费者代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">// 使用@Slf4j注解生成日志记录器</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMessageConsumer</span> &#123;</span><br><span class="line">    <span class="comment">// @SneakThrows 注解简化异常处理，</span></span><br><span class="line">    <span class="comment">// 底层实际上是给需要抛出检查型异常的方法加上了 try-catch，使用这个注解可以让代码更加简洁</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// rabbitMQ 消息监听注解，可以用来接收消息</span></span><br><span class="line">    <span class="comment">// 设置队列名称和消息确认模式为手动确认</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;code_queue&quot;&#125;, ackMode = &quot;MANUAL&quot;)</span></span><br><span class="line">    <span class="comment">// 在RabbitMQ中,每条消息都会被分配一个唯一的投递标签，用于标识该消息在通道中的投递状态和顺序。</span></span><br><span class="line">    <span class="comment">// 通过使用@Header(AmqpHeaders.DELIVERY_TAG)注解,</span></span><br><span class="line">    <span class="comment">// 可以从消息头中提取出该投递标签,并将其赋值给long deliveryTag参数。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMessage</span><span class="params">(String message, Channel channel, <span class="meta">@Header(AmqpHeaders.DELIVERY_TAG)</span> <span class="type">long</span> deliveryTag)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;receiveMessage message = &#123;&#125;&quot;</span>, message);</span><br><span class="line">        channel.basicAck(deliveryTag, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要调用上面的方法，还需要提前先把队列创建好：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化 MQ ，创建相应的测试队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqInitMain</span> &#123;</span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">            factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">            <span class="comment">// 队列名称</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;code_exchange&quot;</span>;</span><br><span class="line">            <span class="comment">// 声明交换机,指定交换机名称和类型</span></span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;code_queue&quot;</span>;</span><br><span class="line">            <span class="comment">// 声明队列</span></span><br><span class="line">            channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 绑定交换机</span></span><br><span class="line">            channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;my_routingKey&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;初始化 MQ 失败:&#123;&#125;&quot;</span> , e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写一个测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMessageProducerTest</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MyMessageProducer myMessageProducer;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">exchange</span> <span class="operator">=</span> <span class="string">&quot;code_exchange&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> <span class="string">&quot;my_routingKey&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;你好呀！&quot;</span>;</span><br><span class="line">        myMessageProducer.sendMessage(exchange, routingKey, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 Spring Boot 项目后，会显示连接到 RabbitMQ 的连接：</p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240220115116513.png" alt="image-20240220115116513"></p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240220115157736.png" alt="image-20240220115157736"></p><h2 id="BI-项目改造"><a href="#BI-项目改造" class="headerlink" title="BI 项目改造"></a>BI 项目改造</h2><p>以前是把任务提交到线程池，然后再线程池提交中编写处理程序的代码，线程池内排队。</p><p>如果程序中断了，任务就没了，就丢了。</p><p>改造后的流程：</p><ol><li>把任务提交改为向队列发送消息</li><li>写一个专门的接受消息的程序，处理任务</li><li>如果程序中断了，消息未被确认，还会重发吗？</li></ol><p>验证发现：如果程序中断了，没有 ack、也没有 nack ，那么这条消息会被重新放到消息队列中，从而实现了每个任务都会执行。</p><h1 id="Bug-汇总和解决"><a href="#Bug-汇总和解决" class="headerlink" title="Bug 汇总和解决"></a>Bug 汇总和解决</h1><h2 id="修改前端布局导致项目无法正常启动："><a href="#修改前端布局导致项目无法正常启动：" class="headerlink" title="修改前端布局导致项目无法正常启动："></a>修改前端布局导致项目无法正常启动：</h2><ol><li>在调整管理界面的布局时，将修改好后的布局代码复制到 defaultSettings ，要先复制到空白区域，然后对原来的配置一一修改。不能直接去把原来的内容全部替换：</li></ol><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240210162954276.png" alt="image-20240210162954276"></p><ol start="2"><li><p><strong>跨域</strong></p><p>在相应的 Controller 加上注解：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin(origins = &quot;http://localhost:8000&quot;, allowCredentials = &quot;true&quot;)</span></span><br></pre></td></tr></table></figure><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240210194817986.png" alt="image-20240210194817986"></p><ol start="3"><li>设置 @EnableWebMvc 后出现 swagger 接口文档显示 404 问题</li></ol><p>由于定义了这个注解，导致接管了整个 Mvc 的环境，因此导致自动配置失效，进而导致静态页面无法访问。</p><p><a href="https://blog.csdn.net/weixin_46411355/article/details/128888427">@EnableWebMvc注解让swagger-ui.html无法打开404报错问题及其解决方案（史上最全最详细）-CSDN博客</a></p><h2 id="编写线程池测试接口时，-get-请求得到的响应返回问号："><a href="#编写线程池测试接口时，-get-请求得到的响应返回问号：" class="headerlink" title="编写线程池测试接口时， get 请求得到的响应返回问号："></a>编写线程池测试接口时， get 请求得到的响应返回问号：</h2><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240216201629687.png" alt="image-20240216201629687"></p><p>解决方案：</p><p>在 RequestMapping 处加上 produces &#x3D; “application&#x2F;json”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/queue&quot;,produces = &quot;application/json&quot; )</span></span><br></pre></td></tr></table></figure><h1 id="小工具"><a href="#小工具" class="headerlink" title="小工具"></a>小工具</h1><p>注解 @SneakyThrows</p><p>可以为检查型异常（需要抛出的异常） 在底层加上 try-catch ，让代码更加简介。</p><p>未加注解的情况：<strong>出现异常爆红</strong></p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240220111643723.png" alt="image-20240220111643723"></p><p>加了注解的情况：<strong>异常不爆红：</strong></p><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240220111714991.png" alt="image-20240220111714991"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>常见限流算法</title>
      <link href="/Shirly.github.io/2024/03/04/%E9%80%9A%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/"/>
      <url>/Shirly.github.io/2024/03/04/%E9%80%9A%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h3><p><a href="https://juejin.cn/post/7075137592265539614">5种限流算法，7种限流方式，挡住突发流量？ - 掘金 (juejin.cn)</a></p><p><strong>阈值</strong></p><p>​在一个单位时间内允许的请求量。如 QPS 限制为10，说明 1 秒内最多接受 10 次请求。</p><p><strong>拒绝策略</strong></p><p>​超过阈值的请求的拒绝策略，常见的拒绝策略有直接拒绝、排队等待等。</p><h4 id="固定窗口算法"><a href="#固定窗口算法" class="headerlink" title="固定窗口算法"></a><strong>固定窗口算法</strong></h4><p>又称计数器算法，设定一个固定的限流周期，通过一个支持原子操作的计数器计算在该周期下的请求次数，如果在该周期下计数器达到了限流阈值时触发拒绝策略。每过一个周期，这个计数器就被重置为 0 重新计数。</p><p>算法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> https://www.wdbyte.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimiterSimpleWindow</span> &#123;</span><br><span class="line">    <span class="comment">// 阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">QPS</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 时间窗口（毫秒）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">TIME_WINDOWS</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">// 计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">REQ_COUNT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">START_TIME</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((System.currentTimeMillis() - START_TIME) &gt; TIME_WINDOWS) &#123;</span><br><span class="line">            REQ_COUNT.set(<span class="number">0</span>);</span><br><span class="line">            START_TIME = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> REQ_COUNT.incrementAndGet() &lt;= QPS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">250</span>);</span><br><span class="line">            <span class="type">LocalTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">            <span class="keyword">if</span> (!tryAcquire()) &#123;</span><br><span class="line">                System.out.println(now + <span class="string">&quot; 被限流&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(now + <span class="string">&quot; 做点什么&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题：</p><p><strong>临界突变</strong></p><p>如果我们在周期刷新的临界时段进行大量请求，仍然会导致短时间内请求大量进入而导致限流失效。</p><p>比如，我设定了一个小时为一个周期，每个周期允许 100 个请求进入，但是如果用户在前 59 分钟都没有请求，而第 59 分钟的时候请求了 100 次，此时并不会触发请求的限流，然后在下一个周期时，即第 60 分钟的时候再来了 100 个请求，就相当于我们的系统在两分钟内接收了 200 个请求，这远远超出了我们设定的 1 小时接收 100 个请求的 QPS。</p><p><img src="/Shirly.github.io/%E8%80%81%E6%96%B9%E8%81%9A%E5%90%88%20AI%20%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8.assets/image-20240303085256909.png" alt="image-20240303085256909"></p><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p><strong>固定窗口存在临界突变问题，</strong>因此需要考虑一个新的算法来解决：</p><p>滑动窗口类似于固定窗口，只不过它将周期变成可以变动的情况，比如我们之前设定的 1 小时内允许 100 个请求，它是固定死的，比如我在 7 点启动服务，那么到 8 点前还是只有 100 次请求可以允许通过，而滑动窗口可以解决这个问题，我们以一个滑动窗口频率来不停变化我们的周期窗口，比如此时是 7 点启动服务，然后有 5 个请求调用了服务，服务器允许它们请求，到达 7 时 1 分的时候，我们修改窗口的覆盖，变为覆盖 7 点 1 分到 8 点 1 分的区间内允许 100 次请求。</p><p><img src="/Shirly.github.io/%E8%80%81%E6%96%B9%E8%81%9A%E5%90%88%20AI%20%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8.assets/image-20240303090043899.png" alt="image-20240303090043899"></p><p>将滑动的时间段越短越能解决临界突变的问题。也就说明它仍然存在临界突变，但是能有一定的改善</p><h4 id="滑动日志算法"><a href="#滑动日志算法" class="headerlink" title="滑动日志算法"></a>滑动日志算法</h4><p>记录下所有的请求时间点，当新的请求进来时，判断在它最近指定时间范围内的请求数目是否超过了指定的阈值。由此来确定是否达到限流，它不存在临界突变的问题。限流比较准确，但是<strong>占用内存</strong></p><h4 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h4><p>它相当于一个队列，它会根据固定的速率不断地移除掉里面的内容。消费的速率等于限流阈值，比如 QPS &#x3D; 2，它就是 1s &#x2F; 2 &#x3D; 500 ms 移除一次，是串行化的过程。桶本身是有大小的，它仅允许一定数额的请求堆积，但是如果在短时间内，比如 500ms 以内，一次发送了2 次以上的请求，那么多余的请求会被限流，触发拒绝策略。而内部则是每隔 500ms 就移除 1 个。</p><p><img src="/Shirly.github.io/%E8%80%81%E6%96%B9%E8%81%9A%E5%90%88%20AI%20%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8.assets/image-20240303093814408.png" alt="image-20240303093814408"></p><p>漏桶算法的消费处理总是以恒定的速率进行的，因此可以很好<strong>的保护自身系统</strong>不被突如其来的流量冲垮。</p><p>问题：串行的执行方式，会导致一些需要并行处理的请求无法同时进行。比如我请求登录功能的同时，还请求了获取个人信息的情况，就无法在短时间内返回。</p><h4 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h4><p>系统根据固定的频率向桶中添加令牌，比如 QPS &#x3D; 2，就相当于每秒给桶中添加 2 个令牌，每 500ms 添加一个令牌，如果桶中令牌数达到阈值，就不再添加。</p><p>请求执行作为消费者，在执行请求前都必须要去取出一个令牌，只有取到令牌才能继续执行，如果桶中没有令牌可以获取，就触发拒绝策略，可以直接拒绝，也可以超时等待。来达到实现限流的目的。</p><p><img src="/Shirly.github.io/%E8%80%81%E6%96%B9%E8%81%9A%E5%90%88%20AI%20%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8.assets/image-20240303095636990.png" alt="image-20240303095636990"></p><p>实现方案：</p><ul><li><p>Google 的 Java 开发工具包 Guava 中的限流工具类 RateLimiter </p></li><li><p>Redis 的分布式限流</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>缓解游戏画面卡死，显卡掉驱动问题</title>
      <link href="/Shirly.github.io/2024/02/16/%E6%97%A5%E5%B8%B8%E5%B0%8F%E8%AE%B0/%E6%B8%B8%E6%88%8F%E7%94%BB%E9%9D%A2%E5%8D%A1%E6%AD%BB%20Nvddmkm%200%20%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/Shirly.github.io/2024/02/16/%E6%97%A5%E5%B8%B8%E5%B0%8F%E8%AE%B0/%E6%B8%B8%E6%88%8F%E7%94%BB%E9%9D%A2%E5%8D%A1%E6%AD%BB%20Nvddmkm%200%20%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="游戏画面卡死-Nvlddmkm-0-问题解决方案"><a href="#游戏画面卡死-Nvlddmkm-0-问题解决方案" class="headerlink" title="游戏画面卡死 Nvlddmkm 0 问题解决方案"></a>游戏画面卡死 Nvlddmkm 0 问题解决方案</h1><h2 id="情况说明"><a href="#情况说明" class="headerlink" title="情况说明"></a>情况说明</h2><p>我的笔记本是拯救者 y7000p 2020 款，近半年来玩游戏从最开始个别游戏时不时画面卡死但是鼠标点击仍有声音到后面各种游戏都出现卡死闪退，甚至有的游戏直接打开就闪退，通过查看事件查看器，可以发现每当出现上述情况都会有 nvlddmkm 事件 0，采取了各种方法，现已解决。</p><p><strong>情况描述：</strong></p><ol><li>游戏画面卡死，但鼠标点击仍然有声音</li><li>游戏直接闪退，查看事件查看器发现报错 nvlddmkm 事件 0</li></ol><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202402202330341.png" alt="image-20240220231446517"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>尝试过各种网上的方法，包括但不限于升级驱动、重新安装旧版驱动、修改电源配置等，全都无效。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p><strong>使用微星小飞机降低核心频率</strong></p><p><a href="https://msi-afterburner.en.softonic.com/">MSI Afterburner - Download (softonic.com)</a></p><p>​有一定的效果，但效果一般，甚至用久了感觉效果越来越差。</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202402202330342.png" alt="image-20240220231738624"></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p><strong>降低游戏画质</strong></p><p>显卡频率过高就会导致卡死闪退情况，可以选择降低画质来解决。</p><blockquote><p> 挺影响游戏体验，我买了游戏本就是为了爽的，结果还得降画质</p></blockquote><h3 id="方法三-（成功解决我的情况）"><a href="#方法三-（成功解决我的情况）" class="headerlink" title="方法三 （成功解决我的情况）"></a>方法三 （成功解决我的情况）</h3><p><strong>清灰</strong> ，没错，就是清灰，我在游戏时通过联想电脑管家观察到，每当我游戏闪退的一瞬间，我的 CPU 温度和显卡温度都会突然飙增到 90 摄氏度以上。同时 CPU 和显卡的占用率总有一个瞬间就 100%，然后游戏闪退之后又会突然 0%，</p><blockquote><p>我通过在游戏时监测 CPU 和显卡的温度和占用情况：</p></blockquote><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202402202330343.png" alt="image-20240220232701031"></p><p>于是我想起来我这两年多都没清灰的电脑，会不会显卡驱动有啥保护机制，过热就会导致掉驱动。于是我就直接背着包去联想店里清灰了。</p><p>清灰回来之后，打游戏显卡基本稳定在 70 度以下了，而 CPU 也能保持在 70 度左右变动。亲测我在游玩帕鲁、怪猎、大表哥 等游戏 2h 内都没有再闪退，至于 2h 以上我目前还未测试。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>循环依赖和 IOC 生命周期</title>
      <link href="/Shirly.github.io/2023/12/08/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Spring%E5%8E%9F%E7%90%86%E4%B9%8B%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%92%8CIOC%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/Shirly.github.io/2023/12/08/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Spring%E5%8E%9F%E7%90%86%E4%B9%8B%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%92%8CIOC%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring原理之循环依赖和IOC生命周期"><a href="#Spring原理之循环依赖和IOC生命周期" class="headerlink" title="Spring原理之循环依赖和IOC生命周期"></a>Spring原理之循环依赖和IOC生命周期</h1><h2 id="重点：Spring如何解决循环依赖问题"><a href="#重点：Spring如何解决循环依赖问题" class="headerlink" title="重点：Spring如何解决循环依赖问题"></a>重点：Spring如何解决循环依赖问题</h2><blockquote><p>首先我们需要说明，Spring只是解决了单例模式下属性依赖的循环问题；Spring为了解决单例的循环依赖问题，使用了三级缓存。</p></blockquote><h3 id="Spring单例模式下的属性依赖"><a href="#Spring单例模式下的属性依赖" class="headerlink" title="# Spring单例模式下的属性依赖"></a><a href="#spring%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E4%BE%9D%E8%B5%96">#</a> Spring单例模式下的属性依赖</h3><p>先来看下这三级缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Object&gt;(<span class="number">256</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name --&gt; ObjectFactory */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, ObjectFactory&lt;?&gt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><ul><li><p><strong>第一层缓存（singletonObjects）</strong>：单例对象缓存池，已经实例化并且属性赋值，这里的对象是<strong>成熟对象</strong>；</p></li><li><p><strong>第二层缓存（earlySingletonObjects）</strong>：单例对象缓存池，已经实例化但尚未属性赋值，这里的对象是<strong>半成品对象</strong>；</p></li><li><p><strong>第三层缓存（singletonFactories）</strong>: 单例工厂的缓存</p></li></ul><p>如下是获取单例中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">  <span class="comment">// Spring首先从singletonObjects（一级缓存）中尝试获取</span></span><br><span class="line">  <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">  <span class="comment">// 若是获取不到而且对象在建立中，则尝试从earlySingletonObjects(二级缓存)中获取</span></span><br><span class="line">  <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">        singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">          ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">          <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//若是仍是获取不到而且容许从singletonFactories经过getObject获取，则经过singletonFactory.getObject()(三级缓存)获取</span></span><br><span class="line">              singletonObject = singletonFactory.getObject();</span><br><span class="line">              <span class="comment">//若是获取到了则将singletonObject放入到earlySingletonObjects,也就是将三级缓存提高到二级缓存中</span></span><br><span class="line">              <span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">              <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充一些方法和参数</p><ul><li><p><code>isSingletonCurrentlyInCreation()</code>：判断当前单例bean是否正在建立中，也就是没有初始化完成(好比A的构造器依赖了B对象因此得先去建立B对象， 或则在A的populateBean过程当中依赖了B对象，得先去建立B对象，这时的A就是处于建立中的状态。)</p></li><li><p><code>allowEarlyReference</code> ：是否容许从singletonFactories中经过getObject拿到对象</p></li></ul><p>分析getSingleton()的整个过程，Spring首先从一级缓存singletonObjects中获取。若是获取不到，而且对象正在建立中，就再从二级缓存earlySingletonObjects中获取。若是仍是获取不到且容许singletonFactories经过getObject()获取，就从三级缓存singletonFactory.getObject()(三级缓存)获取，若是获取到了则从三级缓存移动到了二级缓存。</p><p>从上面三级缓存的分析，咱们能够知道，Spring解决循环依赖的诀窍就在于singletonFactories这个三级cache。这个cache的类型是ObjectFactory，定义以下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ObjectFactory</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在bean建立过程当中，有两处比较重要的匿名内部类实现了该接口。一处是Spring利用其建立bean的时候，另外一处就是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addSingletonFactory(beanName, <span class="keyword">new</span> <span class="title class_">ObjectFactory</span>&lt;Object&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span>   <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">      <span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">   &#125;&#125;);</span><br></pre></td></tr></table></figure><p>此处就是解决循环依赖的关键，这段代码发生在createBeanInstance以后，也就是说单例对象此时已经被建立出来的。这个对象已经被生产出来了，虽然还不完美（尚未进行初始化的第二步和第三步），可是已经能被人认出来了（根据对象引用能定位到堆中的对象），因此Spring此时将这个对象提早曝光出来让你们认识，让你们使用。</p><p>好比“A对象setter依赖B对象，B对象setter依赖A对象”，A首先完成了初始化的第一步，而且将本身提早曝光到singletonFactories中，此时进行初始化的第二步，发现本身依赖对象B，此时就尝试去get(B)，发现B尚未被create，因此走create流程，B在初始化第一步的时候发现本身依赖了对象A，因而尝试get(A)，尝试一级缓存singletonObjects(确定没有，由于A还没初始化彻底)，尝试二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，因为A经过ObjectFactory将本身提早曝光了，因此B可以经过ObjectFactory.getObject拿到A对象(半成品)，B拿到A对象后顺利完成了初始化阶段一、二、三，彻底初始化以后将本身放入到一级缓存singletonObjects中。此时返回A中，A此时能拿到B的对象顺利完成本身的初始化阶段二、三，最终A也完成了初始化，进去了一级缓存singletonObjects中，并且更加幸运的是，因为B拿到了A的对象引用，因此B如今hold住的A对象完成了初始化。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Transient 的作用</title>
      <link href="/Shirly.github.io/2023/11/04/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Transient%20%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
      <url>/Shirly.github.io/2023/11/04/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Transient%20%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Transient-的作用"><a href="#Transient-的作用" class="headerlink" title="Transient 的作用"></a>Transient 的作用</h1><p>来自：<a href="https://zhuanlan.zhihu.com/p/624897752">被遗忘的Java关键字：transient - 知乎 (zhihu.com)</a></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 全局开关</span><br><span class="line">     */</span><br><span class="line">    public static transient boolean running = true;</span><br></pre></td></tr></table></figure><h3 id="transient-是什么？"><a href="#transient-是什么？" class="headerlink" title="transient 是什么？"></a><strong>transient 是什么？</strong></h3><p>在 Java 中，transient 是一个关键字，用于指定一个类的字段（成员变量）在序列化时应该被忽略。在 Java 对象序列化期间，对象的状态被转换为字节流，以便在网络上传输或持久保存到磁盘。如果一个字段被标记为 transient，那么它的值不会被序列化，在反序列化时会被恢复其默认值。</p><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a><strong>简单示例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Example</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Example&#123;name=&#x27;&quot;</span> + name + <span class="string">&quot;&#x27;, age=&quot;</span> + age + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="string">&quot;/Users/ryan/Desktop/&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个Example对象并序列化到文件</span></span><br><span class="line">        <span class="type">Example</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Example</span>(<span class="string">&quot;Ryan&quot;</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Before serialization: &quot;</span> + obj);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> Files.newOutputStream(Paths.get(dir + <span class="string">&quot;example.ser&quot;</span>));</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(outputStream)) &#123;</span><br><span class="line">            out.writeObject(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从文件中反序列化Example对象</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Files.newInputStream(Paths.get(dir + <span class="string">&quot;example.ser&quot;</span>));</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(inputStream)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;After deserialization: &quot;</span> + in.readObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Before serialization: Example&#123;name=<span class="string">&#x27;Ryan&#x27;</span>, age=<span class="number">20</span>&#125;</span><br><span class="line">After deserialization: Example&#123;name=<span class="string">&#x27;Ryan&#x27;</span>, age=<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们创建了一个名为 <code>Example</code> 的类，并在其中定义了两个字段 <code>name</code> 和 <code>age</code>，其中 <code>age</code> 被标记为 <code>transient</code>。然后，我们创建了一个 <code>Example</code> 对象并将其序列化到名为 <code>example.ser</code> 的文件中。</p><p>接着，我们从文件中反序列化了刚刚序列化的 <code>Example</code> 对象，并将其赋值给一个新的对象 <code>newObj</code>。然后，我们打印出了原始对象和反序列化后的对象。可以看到，在反序列化后，<code>age</code> 字段的值被恢复为其默认值 0。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h3><h3 id="序列化敏感数据"><a href="#序列化敏感数据" class="headerlink" title="序列化敏感数据"></a><strong>序列化敏感数据</strong></h3><p>有些对象包含一些敏感信息，如密码、访问令牌等，这些信息在对象序列化时需要被保护，以防被未授权的用户访问和泄露。</p><h3 id="提高序列化性能"><a href="#提高序列化性能" class="headerlink" title="提高序列化性能"></a><strong>提高序列化性能</strong></h3><p>有些对象中的字段可能会影响序列化和反序列化的性能，如包含大量数据的对象，这些数据可能会在网络传输或磁盘存储期间增加延迟和负载，使用 transient 关键字可以排除这些字段，提高序列化性能。</p><h3 id="临时数据"><a href="#临时数据" class="headerlink" title="临时数据"></a><strong>临时数据</strong></h3><p>有些字段仅用于对象的内部计算或临时存储数据，这些数据在序列化时无需保留，因此可以使用 transient 关键字来忽略这些字段，从而减少序列化后对象的大小。</p><h3 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a><strong>需要注意的点</strong></h3><ul><li>transient关键字只能修饰变量，而不能修饰方法和类。</li><li>transient标记的变量所在的类必须实现Serializable接口。</li><li>transient标记的变量在反序列化时会被初始化为默认值，需要在程序中手动进行初始化操作。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>transient 关键字只是暂时地在序列化过程中忽略了该字段，而不是永久性地从对象中删除该字段。在反序列化时，该字段将被恢复为其默认值。因此，如果需要永久地从对象中删除一个字段，直接将其从类中完全删除</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC学习笔记</title>
      <link href="/Shirly.github.io/2023/08/04/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SpringMVC%E7%AC%94%E8%AE%B0/"/>
      <url>/Shirly.github.io/2023/08/04/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SpringMVC%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC笔记"><a href="#SpringMVC笔记" class="headerlink" title="SpringMVC笔记"></a>SpringMVC笔记</h1><p>SpringMVC<strong>基于原生的Servlet</strong>，通过了功能强大的<strong>前端控制器DispatcherServlet</strong>，对请求和响应进行统一处理</p><blockquote><p>不多说，直接开始操作正题</p><p>视频直接贴上<a href="https://www.bilibili.com/video/BV1Ry4y1574R?p=7&vd_source=74f3e6444b028a3f47fe089ba260b104">06_尚硅谷_SpringMVC_HelloWorld：创建maven工程_哔哩哔哩_bilibili</a></p><p>源码部分的内容可能需要反复听，源码讲解还是挺丰富的，基本上每一章都有源码解析。</p><p>从本集开始</p></blockquote><p>##什么是MVC</p><p>MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分</p><p>M：Model，模型层，指工程中的JavaBean，作用是处理数据</p><p>JavaBean分为两类：</p><ul><li>一类称为实体类Bean：专门存储业务数据的，如 Student、User 等</li><li>一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。</li></ul><p>V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据</p><p>C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器</p><p>MVC的工作流程：<br>用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器</p><hr><p>##SpringMVC 项目创建并编写HelloWorld</p><p>###项目创建和基本配置</p><ol><li>创建 maven 工程，在 pom.xml 中设置打包方式为 <code>war</code></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>引入下列依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- SpringMVC --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ServletAPI --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span><span class="comment">&lt;!--provided表明该包只在编译和测试的时候用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Spring5和Thymeleaf整合包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>添加 web模块，并添加 web.xml 配置文件。<ul><li>直接在 src\main目录下新建一个 webapp 文件夹，它会自动变为 web 模块，随后点击<strong>项目结构</strong>，选择<strong>模块</strong>,在部署描述符栏中点击 ‘+’ 号 ，设置 web.xml 配置文件的路径，选择在 src\main\webapp 目录下：</li></ul></li></ol><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030461.png" alt="image-20221218140835332"></p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030462.png" alt="image-20221218140846448"></p><hr><h3 id="配置-web-xml"><a href="#配置-web-xml" class="headerlink" title="配置 web.xml"></a><strong>配置 web.xml</strong></h3><p>分为两种配置方式</p><ul><li>默认配置方式</li></ul><p>此配置作用下，SpringMVC的配置文件默认位于WEB-INF下，默认名称为&lt;servlet-name&gt;-servlet.xml，例如，以下配置所对应SpringMVC的配置文件位于WEB-INF下，文件名为springMVC-servlet.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        设置springMVC的核心控制器所能处理的请求的请求路径</span></span><br><span class="line"><span class="comment">        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径</span></span><br><span class="line"><span class="comment">        但是/不能匹配.jsp请求路径的请求</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>拓展配置方式</strong></li></ul><p>这是更为常用的配置方式，可以自定义 SpringMVC 配置文件的位置，更加灵活。</p><p>可通过init-param标签设置SpringMVC配置文件的位置和名称，通过load-on-startup标签设置SpringMVC前端控制器DispatcherServlet的初始化时间</p><p>操作如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- contextConfigLocation为固定值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment"> 作为框架的核心组件，在启动过程中有大量的初始化操作要做</span></span><br><span class="line"><span class="comment">而这些操作放在第一次请求时才执行会严重影响访问速度</span></span><br><span class="line"><span class="comment">因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        设置springMVC的核心控制器所能处理的请求的请求路径</span></span><br><span class="line"><span class="comment">        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径</span></span><br><span class="line"><span class="comment">        但是/不能匹配.jsp请求路径的请求</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><blockquote><p>注：</p></blockquote><p>&lt;url-pattern&gt;标签中使用&#x2F;和&#x2F;*的区别：</p><p>&#x2F;所匹配的请求可以是&#x2F;login或.html或.js或.css方式的请求路径，但是&#x2F;不能匹配.jsp请求路径的请求</p><p>因此就可以避免在访问jsp页面时，该请求被DispatcherServlet处理，从而找不到相应的页面</p><p>&#x2F;*则能够匹配所有请求，例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用&#x2F;*的写法</p></blockquote><hr><h3 id="创建请求控制器"><a href="#创建请求控制器" class="headerlink" title="创建请求控制器"></a>创建请求控制器</h3><p>由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要创建处理具体请求的类，即请求控制器</p><p>请求控制器中每一个处理请求的方法成为控制器方法</p><p>因为SpringMVC的控制器由一个POJO（普通的Java类）担任，因此需要通过<code>@Controller</code>注解将其标识为一个控制层组件，交给Spring的IoC容器管理，此时SpringMVC才能够识别控制器的存在</p><p>在 Java 目录下添加一个 Controller 包，同时创建一个类，用注解 <code>@Controller</code> 设置为请求控制器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.Controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">helloController</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="创建SpringMVC配置文件"><a href="#创建SpringMVC配置文件" class="headerlink" title="创建SpringMVC配置文件"></a>创建SpringMVC配置文件</h3><ol><li>扫描包</li><li>配置 Thymeleaf 视图解析器</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 自动扫描包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.mvc.controller&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置Thymeleaf视图解析器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateEngine&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateResolver&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">                    <span class="comment">&lt;!-- 视图前缀 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">                    <span class="comment">&lt;!-- 视图后缀 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.html&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateMode&quot;</span> <span class="attr">value</span>=<span class="string">&quot;HTML5&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">   处理静态资源，例如html、js、css、jpg</span></span><br><span class="line"><span class="comment">  若只设置该标签，则只能访问静态资源，其他请求则无法访问</span></span><br><span class="line"><span class="comment">  此时必须设置&lt;mvc:annotation-driven/&gt;解决问题</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 开启mvc注解驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 处理响应中文内容乱码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultCharset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;supportedMediaTypes&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>text/html<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>application/json<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从这里可以看到，我们的视图模板的前缀是一个 WEB-INF 目录下的 templates 目录，后缀是以 .HTML 结尾，并且格式为 HTML5。</p><p>因此，我们就需要在 WEB-INF 下创建一个 templates 目录进行创建视图：</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030463.png" alt="image-20221218150101944"></p><p>创建 index.html 后，需要在 <code>&lt;html&gt;</code>  标签内加入如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:th=&quot;http://www.thymeleaf.org&quot;</span><br></pre></td></tr></table></figure><p>这被称为 Thymeleaf 的命名空间，要使用 thymeleaf 的页面必须要添加这个命名空间。</p><p>也可以直接将其设置为默认加入，点击设置，选择编辑器，选择 File and Code Templates，在第一个 HTML File 中的 <code>&lt;html&gt;</code> 标签下，加入上述内容即可。以后创建一个 html 页面，将会自动添加上述代码。</p><hr><p>###测试HelloWorld </p><p>我们在页面中添加了标题和一个超链接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/target&#125;&quot;</span>&gt;</span>Target.html<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>超链接要使用 thymeleaf 语法进行视图渲染，实现跳转。因为如果未使用 thymeleaf 语法，则默认是通过绝对路径进行跳转，而这是带了 localhost:8080 的地址，与我们实际的位置不符，使用 thymeleaf 将其通过 thymeleaf 视图解析器解析后，将<strong>路径转为上下文路径</strong>，来确保地址无误。</p><p>随后在控制器类中通过 <code>@RequestMapping</code> 注解返回 String 类型的方法，这些方法返回的字符串再加上 thymeleaf 中的前后缀就是最终要访问页面的地址。</p><p>@RequestMapping注解：处理请求和控制器方法之间的映射关系<br>@RequestMapping注解的value属性可以通过请求地址匹配请求，&#x2F;表示的当前工程的上下文路径<br>localhost:8080&#x2F;springMVC&#x2F;</p><ul><li><p>@RequestMapping 的 value 属性填写的是 thymeleaf 语法指定的值。</p></li><li><p><code>/</code> 是因为我们在 web.xml 配置中设置访问上下文路径的值，因此如果希望某一个页面是每次启动 tomcat 时打开的页面，可以使用这个属性来实现。</p></li></ul><blockquote><p>注 @RequestMapping 中的 value 属性可以省略</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">helloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/target&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">ToTarget</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上述流程之后，启动服务器即可看到如下的页面显示：</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030464.png" alt="image-20221218155104605"></p><p>点击超链接后：</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030465.png" alt="image-20221218155141991"></p><p>可以看出，这是通过<strong>服务器转发的形式实现</strong>的。</p><p>简单小结一下程序实现过程（<strong>我的个人想法，可能不对</strong>）：</p><p>客户端访问主页发送请求 ‘&#x2F;‘ 到达服务器，前端控制器 <strong>DispatcherServlet</strong> 通过注解 <code>@RequestMapping</code> 找到了对应的方法，并通过 thymeleaf 视图解析器解析和控制器对应的方法得到一个字符串，访问将前后缀与方法返回字符串所形成的链接的页面。</p><p>点击超链接后，请求’&#x2F;target’  也是通过前端控制器 <strong>DispatcherServlet</strong>  找到注解对应的方法，再通过视图解析器解析和控制器方法返回的字符串所形成的链接去跳转。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器DispatcherServlet处理。</p><p>前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器，将请求地址和控制器中@RequestMapping注解的value属性值进行匹配，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。</p><p>处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最终转发到视图所对应页面。</p><hr><h2 id="RequestMapping-注解"><a href="#RequestMapping-注解" class="headerlink" title="@RequestMapping 注解"></a>@RequestMapping 注解</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>从注解名称上我们可以看到，@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联起来，建立映射关系。</p><p>SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。</p><p>下面我们做一个测试，我们让不同的类都作为控制器，同时让它们的某一个方法都用 <code>@RequestMapping</code> 注解，并给与相同的 value 值，看一看会发生什么情况：</p><p>​这是控制器1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这是控制器2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController2</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们启动服务器，发现结果如下：</p><p>程序产生了一个异常，情况如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.IllegalStateException: Ambiguous mapping. Cannot map &#x27;testController2&#x27; method </span><br><span class="line">com.atguigu.Controller.TestController2#index()</span><br></pre></td></tr></table></figure><p>这说明如果我们使用 <code>@RequestMapping</code> 注解了相同的 value ,就会导致前端控制器无法判断选择哪一个映射，导致出现了异常。</p><p>在有些时候，我们可能很希望能够有相同的 value 值，因为有一些方法可能属于某一个特定的类型，例如对于一个 User 类，它可能有列表 list，对于 student 类，也可能有 list，我们可以选择起一个别名，但是这样可能很不方便，因此下面引出了 @RequestMapping 的使用位置</p><hr><h3 id="RequestMapping-使用位置"><a href="#RequestMapping-使用位置" class="headerlink" title="@RequestMapping 使用位置"></a>@RequestMapping 使用位置</h3><p><code>@RequestMapping</code> 注解可以使用在<strong>类或方法</strong>上，若在两者都使用了该注解，在使用 thymeleaf 语法时<strong>必须要把两个注解的 value 都写上</strong>，否则将无法找到对应的方法。</p><p><strong>介绍</strong></p><p>@RequestMapping标识一个类：设置映射请求的请求路径的初始信息</p><p>@RequestMapping标识一个方法：设置映射请求请求路径的具体信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestMappingController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时请求映射所映射的请求的请求路径为：/test/testRequestMapping</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/testRequestMapping&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testRequestMapping</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们给类上添加了注解，那么在页面中跳转就必须把类和方法的注解都添加上。</p><p>例如上一节的例子，我们在该例子的第二个类上添加一个 值为 Test 的 @RequestMapping 注解：</p><p>​第一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/Test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController2</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/target&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">target</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的 index 代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/target&#125;&quot;</span>&gt;</span>target<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时启动服务器后点击超链接：</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030466.png" alt="image-20221218165958299"></p><p>会发现出现404：</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030467.png" alt="image-20221218170012753"></p><p>这表明在给类添加上注解后，原来的方法找不到页面了，我们需要在 thymeleaf 语法中添加类对应的注解的值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/Test/target&#125;&quot;</span>&gt;</span>target<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们再次重新部署并点击超链接：</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030468.png" alt="image-20221218170225414"></p><p>可以看到，页面可以访问了。</p><p><strong>说明</strong>: 给类添加上注解后，我们需要在 thymeleaf 中写入完整注解的值，才能通过前后缀找到对应的页面。</p><blockquote><p>有了这个方法，我们就可以实现给不同的方法添加相同的注解了，只需要对不同的类设置不同的类注解就可以了。注解方法的值就能够相同了。 </p><p>例如 User类的 list ，可以为 &#x2F;user&#x2F;list ，Student 类，可以为 &#x2F;student&#x2F;list 。</p></blockquote><hr><h3 id="RequestMapping-注解的-value-属性"><a href="#RequestMapping-注解的-value-属性" class="headerlink" title="@RequestMapping 注解的 value 属性"></a>@RequestMapping 注解的 value 属性</h3><ul><li><p>@RequestMapping注解的value属性通过请求的请求地址匹配请求映射</p></li><li><p>@RequestMapping注解的value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求</p></li><li><p>@RequestMapping注解的value属性必须设置，至少通过请求地址匹配请求映射</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testRequestMapping&#125;&quot;</span>&gt;</span>测试@RequestMapping的value属性--&gt;/testRequestMapping<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/test&#125;&quot;</span>&gt;</span>测试@RequestMapping的value属性--&gt;/test<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">        value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequestMapping</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>value 可以放入字符串数组，只要请求地址满足这些字符串地址中的<strong>任何一个</strong>都可以访问服务器。</p><hr><h3 id="RequestMapping-注解的-Method-属性"><a href="#RequestMapping-注解的-Method-属性" class="headerlink" title="@RequestMapping 注解的 Method 属性"></a>@RequestMapping 注解的 Method 属性</h3><ul><li><p>@RequestMapping注解的method属性通过请求的请求方式（get或post）匹配请求映射</p></li><li><p>@RequestMapping注解的method属性是一个RequestMethod类型的<strong>数组</strong>，表示该请求映射能够匹配多种请求方式的请求</p></li><li><p>若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器<strong>报错405</strong>：Request method ‘POST’ not supported</p></li><li><p>超链接请求方式为 GET</p></li></ul><p>常见的请求方式：</p><ol><li>GET： 用于查找信息</li><li>POST： 用于增加信息</li><li>PUT： 用于修改信息</li><li>DELETE ：用于删除信息</li></ol><blockquote><p>在上面的介绍中容易对我们产生一个误区，误以为 RequestMapping 注解的 Method 属性默认是 GET，实际上，如果我们没有指定一个明确的 Method 属性，那么任何的表单提交方式都是可以正常访问的。</p></blockquote><p>例如：</p><p>如果我们并没有去特定的指示注解 value 为 <code>/test</code> 对应的方法的  @RequestMapping  注解的 Method 属性 ，那么我们无论使用哪一种提交方式的表单，都可以访问到对应的方法。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/test&#125;&quot;</span>&gt;</span>测试@RequestMapping的value属性--&gt;/test<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/test&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而如果在注解中指定了 Method 属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">        value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;,</span></span><br><span class="line"><span class="meta">        method = &#123;RequestMethod.GET, RequestMethod.POST&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequestMapping</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么一旦提交方式不符合这个 method 的要求，就无法正常访问，会报 405 错误。</p><blockquote><p>注：</p><p>1、对于处理指定请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解</p><p>处理get请求的映射–&gt;@GetMapping</p><p>处理post请求的映射–&gt;@PostMapping</p><p>处理put请求的映射–&gt;@PutMapping</p><p>处理delete请求的映射–&gt;@DeleteMapping</p><p>在使用这些派生注解时，<strong>就要求发送请求的方式必须对应派生注解的处理类型。</strong>这样可以不用设置 Method 属性了</p><p>2、常用的请求方式有get，post，put，delete</p><p>但是目前浏览器只支持get和post，若在form表单提交时，为method设置了其他请求方式的字符串（put或delete），则按照默认的请求方式get处理</p><p>若要发送put和delete请求，则需要通过spring提供的过滤器HiddenHttpMethodFilter，在RESTful部分会讲到</p></blockquote><hr><p>###@RequestMapping 注解的 Params 属性 </p><ul><li><p>@RequestMapping注解的params属性通过请求的请求参数匹配请求映射</p></li><li><p>@RequestMapping注解的 params 参数的条件<strong>必须全部满足</strong>才能访问。</p></li></ul><blockquote><p>（这与之前的 value 和 method 属性不同，它们只需要满足其一即可）</p></blockquote><ul><li><p>@RequestMapping注解的params属性是一个字符串类型的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系</p></li><li><p>“param”：要求请求映射所匹配的请求<strong>必须携带param请求参数</strong></p></li><li><p>“!param”：要求请求映射所匹配的请求必须不能携带param请求参数</p></li><li><p>“param&#x3D;value”：要求请求映射所匹配的请求必须携带param请求参数且param&#x3D;value</p></li><li><p>“param!&#x3D;value”：要求请求映射所匹配的请求必须携带param请求参数但是param!&#x3D;value</p></li></ul><p>可以直接通过 ? 后面带参数和值来实现参数请求，但是这样的html 代码会出现<strong>报错</strong>（实际上没有错误）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/test?username=&quot;</span><span class="attr">admin</span>&quot;&quot;&gt;</span>测试@RequestMapping的params属性--&gt;/test<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果希望没有红色报错提示，可以通过在设置 value 属性值时，在旁边添加一个括号 () ，在括号内添加对应的参数和值。这样设置的参数不会出现报错。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/test(username=&#x27;admin&#x27;,password=123456)&quot;</span>&gt;</span>测试@RequestMapping的params属性--&gt;/test<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们设置的 Java 代码中的注解如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">        value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;</span></span><br><span class="line"><span class="meta">        ,method = &#123;RequestMethod.GET, RequestMethod.POST&#125;</span></span><br><span class="line"><span class="meta">        ,params = &#123;&quot;username&quot;,&quot;password!=123456&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequestMapping</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，如果去访问这个超链接，就会报400错误。</p><hr><p>###@RequestMapping注解的headers属性</p><ul><li><p>@RequestMapping注解的headers属性通过请求的请求头信息匹配请求映射</p></li><li><p>@RequestMapping注解的headers属性和 params 属性一样，都<strong>必须全部满足才能访问</strong></p></li><li><p>@RequestMapping注解的headers属性是一个字符串类型的数组，可以通过四种表达式设置请求头信息和请求映射的匹配关系</p></li><li><p>“header”：要求请求映射所匹配的请求必须携带header请求头信息</p></li><li><p>“!header”：要求请求映射所匹配的请求必须不能携带header请求头信息</p></li><li><p>“header&#x3D;value”：要求请求映射所匹配的请求必须携带header请求头信息且<strong>header&#x3D;value</strong></p></li><li><p>“header!&#x3D;value”：要求请求映射所匹配的请求必须携带header请求头信息且<strong>header!&#x3D;value</strong></p></li><li><p>若当前请求满足@RequestMapping注解的value和method属性，但是不满足headers属性，此时页面显示404错误，即资源未找到</p></li></ul><blockquote><p>注：</p><p>若当前请求满足@RequestMapping注解的value和method属性，但是不满足params属性，此时页面回报错400：Parameter conditions “username, password!&#x3D;123456” not met for actual request parameters: username&#x3D;{admin}, password&#x3D;{123456}</p></blockquote><p>###SpringMVC支持ant风格的路径</p><p>类似于模糊查找的效果，可以根据这些符号来实现路径的模糊查找。</p><p>？：表示任意的单个字符</p><p>*：表示任意的0个或多个字符</p><p>**：表示任意的一层或多层目录</p><p>注意：在使用**时，只能使用&#x2F;**&#x2F;xxx的方式</p><ul><li>？类型：</li></ul><p>​我们在注解中添加 <code>@RequestMapping(&quot;/?/target&quot;)</code> ，这就是指在第一级目录中可以填入任何<strong>一个字符</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/?/target&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">target</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>页面可以按照如下渲染</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/a/target&#125;&quot;</span>&gt;</span>target2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然，也可以是除 a 以外的其他任何字符，但不能是 ？ 和  &#x2F;  </p><p>这是因为？后的内容会被解析为参数，而 &#x2F; 被视为目录分隔。即两个 &#x2F; 中间没有任何字符，后一个 &#x2F; 会被视为没有。</p><ul><li>使用两个 &#x2F;</li></ul><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030469.png" alt="image-20221219160944941"></p><ul><li>这里？后面的内容被视为参数，故直接跳转到首页了</li></ul><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030470.png" alt="image-20221219161032693"></p><p><code>*  </code>类似于 <code>?</code> 只是可以填入多个字符的区别，它也可以<strong>不填入任何字符</strong>。</p><p><code>**</code> 表示可以在这中间有多级目录。需要特别注意的是在  &#x2F;**&#x2F;  中的 &#x2F; &#x2F; 之间不能有其他字符。</p><hr><h3 id="SpringMVC支持路径中的占位符（重点）"><a href="#SpringMVC支持路径中的占位符（重点）" class="headerlink" title="SpringMVC支持路径中的占位符（重点）"></a>SpringMVC支持路径中的占位符（重点）</h3><p>原始方式：&#x2F;deleteUser?id&#x3D;1</p><p>rest方式：&#x2F;deleteUser&#x2F;1</p><p>SpringMVC路径中的占位符常用于RESTful风格中，当请求路径中将某些数据通过路径的方式传输到服务器中，就可以在相应的@RequestMapping注解的value属性中通过<strong>占位符{xxx}<strong>表示传输的数据，在通过</strong>@PathVariable</strong>注解，将占位符所表示的数据赋值给控制器方法的形参</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testRest/1/admin&#125;&quot;</span>&gt;</span>测试路径中的占位符--&gt;/testRest<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRest/&#123;id&#125;/&#123;username&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRest</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id, <span class="meta">@PathVariable(&quot;username&quot;)</span> String username)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;id:&quot;</span>+id+<span class="string">&quot;,username:&quot;</span>+username);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终输出的内容为--&gt;id:1,username:admin</span></span><br></pre></td></tr></table></figure><hr><h2 id="SpringMVC-获取请求参数"><a href="#SpringMVC-获取请求参数" class="headerlink" title="SpringMVC 获取请求参数"></a>SpringMVC 获取请求参数</h2><p>###ServletAPI 获取请求参数</p><p>在使用 SpringMVC 获取请求参数之前，先通过最原始的方法，使用 ServletAPI 来获取请求参数：</p><ol><li>编写一个超链接，并为其加入一个 username 和 password 参数并赋值：</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/target(username=&#x27;admin&#x27;,password=123456)&#125;&quot;</span>&gt;</span>ServletAPI获取请求参数<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在控制器注解对应的方法中，为该方法设置一个 <code>HttpServletRequest</code> 参数：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/target&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">target2</span><span class="params">(HttpServletRequest request)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这里难免会考虑：我们没有给这个参数赋值，那么程序是如何运行的呢？</p><blockquote><p>注：由于请求是通过前端控制器 DispatcherServlet 来寻找到对应的 @RequestMapping ，前端控制器会根据找到的方法所需的形参赋予其对应的实参，因此，我们不需要手动为其赋值。</p></blockquote><ol start="3"><li>随后，通过这个 request 参数，调用其 getParameter 方法，即可得到请求的参数了。最后别忘了返回一个字符串实现页面的跳转</li></ol><p> 完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/target&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">target2</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;username:&quot;</span>+username+<span class="string">&quot;password:&quot;</span>+password);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>启动tomcat，点击超链接：</li></ol><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030471.png" alt="image-20221219163647187"></p><p>页面已经显示参数</p><p>同时在 idea 服务器输出中显示了我们方法中对应的输出</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030472.png" alt="image-20221219163723825"></p><p>这种方式实现获取请求参数是无法支持占位符，因为需要知道形参的名称，而占位符是直接在路径中传值，需要在方法参数中使用注解来得到形参的名称，因此这是无法实现的。</p><hr><h3 id="通过控制器方法的形参获取请求参数"><a href="#通过控制器方法的形参获取请求参数" class="headerlink" title="通过控制器方法的形参获取请求参数"></a>通过控制器方法的形参获取请求参数</h3><p>可以直接在方法中写入和参数名称一致的 String 类型形参，SpringMVC 可以直接获取到对应的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/target&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">target2</span><span class="params">(String username,String password)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username:&quot;</span>+username+<span class="string">&quot;password:&quot;</span>+password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username:adminpassword:123456</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><p>若请求所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数</p><p>若使用字符串数组类型的形参，此参数的数组中包含了每一个数据</p><p>若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果</p></blockquote><p>###@RequestParam</p><ul><li>@RequestParam是将请求参数和控制器方法的形参创建映射关系，用在上面的请求参数前面</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/target&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">target2</span><span class="params">(</span></span><br><span class="line"><span class="params">     <span class="meta">@RequestParam()</span> String username,</span></span><br><span class="line"><span class="params">        String password)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username:&quot;</span>+username+<span class="string">&quot;password:&quot;</span>+password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@RequestParam注解一共有三个属性：</p><ul><li><p>value：指定为形参赋值的请求参数的参数名</p></li><li><p>required：设置是否必须传输此请求参数，默认值为true</p></li><li><p>若设置为<strong>true</strong>时，则当前<strong>请求必须传输value所指定的请求参数</strong>，若没有传输该请求参数，且没有设置defaultValue属性，则页面报错<strong>400</strong>：Required String parameter ‘xxx’ is not present；若设置为false，则<strong>当前请求不是必须传输value所指定的请求参数</strong>，若没有传输，则注解所标识的形参的值为<strong>null</strong></p></li><li><p>defaultValue：不管required属性值为true或false，<strong>当value所指定的请求参数没有传输或传输的值为””时，则使用默认值为形参赋值</strong></p></li></ul><p>有时候在浏览器中的参数名无法和控制器方法中的参数名一致，因此就无法实现控制器方法的形参获取请求参数，这时候可以使用 <code>@RequestParam</code>，将 value 指定为 html 页面中参数的名字，这样也能进行对应：</p><p>​例如，我们将 index 中超链接的参数 username 改为 user_name。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/target(user_name=&#x27;admin&#x27;,password=123456)&#125;&quot;</span>&gt;</span>控制器形参获取<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时，如果我们不想直接修改源代码来保持名称的一致，就可以加上这个注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/target&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">target2</span><span class="params">(</span></span><br><span class="line"><span class="params">     <span class="meta">@RequestParam(value = &quot;user_name&quot;)</span> String username,</span></span><br><span class="line"><span class="params">        String password)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username:&quot;</span>+username+<span class="string">&quot;password:&quot;</span>+password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们依然可以访问到对应的控制器方法</p><hr><p>###@RequestHeader 注解</p><p>@RequestHeader是将请求头信息和控制器方法的形参创建映射关系</p><p>@RequestHeader注解一共有三个属性：value、required、defaultValue，用法同@RequestParam</p><p>类似于上面的 @RequestParam 的使用方法。</p><hr><h3 id="CookieValue-注解"><a href="#CookieValue-注解" class="headerlink" title="@CookieValue 注解"></a>@CookieValue 注解</h3><ul><li><p>通过 request.setSession得到一个 Cookie 后，可以使用该注解来获取 Cookie。</p></li><li><p>@CookieValue是将cookie数据和控制器方法的形参创建映射关系</p></li><li><p>@CookieValue注解一共有三个属性：value、required、defaultValue，用法同@RequestParam</p></li></ul><hr><h3 id="通过POJO获取请求参数"><a href="#通过POJO获取请求参数" class="headerlink" title="通过POJO获取请求参数"></a>通过POJO获取请求参数</h3><p>可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/testpojo&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    性别：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>&gt;</span>男<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span>女<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    年龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    邮箱：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建要给对应该表单的实体类User，要求：表单中的 name 属性要和 类的属性名称一致。且需要一个无参构造器（通过反射来创建对象，需要使用）和有参构造器，以及对应属性的 get 和 set 方法。</p><p>控制器方法及测试结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testpojo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testPOJO</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终结果--&gt;User&#123;id=null, username=&#x27;张三&#x27;, password=&#x27;123&#x27;, age=23, sex=&#x27;男&#x27;, email=&#x27;123@qq.com&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>这里的 sex 实际上是出现了乱码问题：</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030473.png" alt="image-20221219200705011"></p><p>​这是由于字符编码不一致导致的。</p><p>下面将会介绍如何解决这个问题</p><p>这是由于 Post 请求方式发生的乱码问题，这是tomcat 的配置没有设置的问题，而get 请求是没有问题的，因为在 tomcat 的配置文件中有设置 GET 请求的编码为 UTF-8</p><h3 id="解决获取请求参数的乱码问题"><a href="#解决获取请求参数的乱码问题" class="headerlink" title="解决获取请求参数的乱码问题"></a>解决获取请求参数的乱码问题</h3><p>解决获取请求参数的乱码问题，可以使用SpringMVC提供的<strong>编码过滤器CharacterEncodingFilter</strong>，但是必须在web.xml中进行注册</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置springMVC的编码过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span><span class="comment">&lt;!--这里的/*表示所有都注册--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>加上这些内容后，就可以解决乱码问题了。</p><p><strong>注意!!!!!!!!!!!!</strong> <strong>设置上述处理编码的代码配置之前，不能有任何请求参数的行为！！！！！！</strong></p><p>下面分析一下源码：</p><p>在上面，我们看到解决编码问题是设置了编码过滤器 CharacterEncodingFilter 类，原因在于过滤器是在我们获取请求参数之前就启动完成了的，我们只<strong>有在获取请求参数之前把编码设置好</strong>，才能解决乱码的问题。</p><p>因此，我们看一下这个类的代码，它有三个属性，这是关于编码的属性，我们需要去寻找能够创建过滤器的方法，在创建过滤器时进行设置编码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharacterEncodingFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> String encoding;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> forceRequestEncoding;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> forceResponseEncoding;</span><br></pre></td></tr></table></figure><p>一般，在过滤器类中应该存在 init 方法来初始化过滤器，或者是有 doFilter 方法来创建过滤器，但是这个类并没有这两个方法，因此我们去查找它的超类：</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030474.png" alt="image-20221219205116686"></p><blockquote><p>并没有过滤器初始化的方法</p></blockquote><blockquote><p>对应的超类：</p></blockquote><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030475.png" alt="image-20221219205133083"></p><p>在超类中，我们找到了 <code>doFilter</code> 方法：</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030476.png" alt="image-20221219205153113"></p><p>在 <code>doFilter</code> 方法中，我们可以找到一个 <code>doFilterInternal </code>的方法，我们知道，这是子类实现的一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.doFilterInternal(httpRequest, httpResponse, filterChain);</span><br></pre></td></tr></table></figure><p>因此，我们定位到子类的 <code>doFilterInternal </code> 方法去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">encoding</span> <span class="operator">=</span> <span class="built_in">this</span>.getEncoding();</span><br><span class="line">    <span class="keyword">if</span> (encoding != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isForceRequestEncoding() || request.getCharacterEncoding() == <span class="literal">null</span>) &#123;</span><br><span class="line">            request.setCharacterEncoding(encoding);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isForceResponseEncoding()) &#123;</span><br><span class="line">            response.setCharacterEncoding(encoding);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里初始化了 encoding 属性，只要 encoding 不为空，就可以设置编码，如果希望响应的编码也改变，就必须修改 </p><p><code>isForceResponseEncoding</code> 的值为 true （默认为 false）。</p><p>这是 isForceResponseEncoding 默认为 false 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CharacterEncodingFilter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.forceRequestEncoding = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">this</span>.forceResponseEncoding = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由此，我们可以通过最开始的代码，在 web.xml 中设置这些属性的值，来让我们的过滤器设置编码，这样，我们就能解决表单提交后的乱码问题了。🐟</p></blockquote><h2 id="SpringMVC共享域对象"><a href="#SpringMVC共享域对象" class="headerlink" title="SpringMVC共享域对象"></a>SpringMVC共享域对象</h2><h3 id="通过-ServletAPI-共享域对象"><a href="#通过-ServletAPI-共享域对象" class="headerlink" title="通过 ServletAPI 共享域对象"></a>通过 ServletAPI 共享域对象</h3><ol><li>使用 ServletAPI 共享域对象，和之前获取请求参数一致，要在对应控制器方法中加入一个形参 <code> HttpServletRequest request</code></li></ol><p>这个可以用来设置域对象，调用其 SetAttribute 方法，设置域对象的键值对：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/SetAttributeByServletAPI&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">success</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    request.setAttribute(<span class="string">&quot;GetSuccess&quot;</span>,<span class="string">&quot;Hello Success!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在首页设置一个超链接，用于跳转到 success 页面来展示该域对象：</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/SetAttributeByServletAPI&#125;&quot;</span>&gt;</span>测试ServletAPI来获取域对象<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在 success 页面中，通过 ${ 键的名称 } 来共享域对象：</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">success</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;GetSuccess&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="comment">&lt;!--thymeleaf获取域对象的语法是用$&#123;&#125;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试结果:</p><p>​点击首页超链接后，显示页面如下：</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030477.png" alt="image-20221221182848189"></p><hr><h3 id="使用ModelAndView-向-request-域对象共享数据"><a href="#使用ModelAndView-向-request-域对象共享数据" class="headerlink" title="使用ModelAndView 向 request 域对象共享数据"></a>使用ModelAndView 向 request 域对象共享数据</h3><p>ModelAndView 类也可以实现域对象共享数据，它封装了两个功能，设置模型和视图，在控制器方法中，我们需要一个 ModelAndView 对象来交给前端控制器解析：</p><p>流程如下：</p><ul><li><p>创建一个 ModelAndView  对象，利用无参构造</p></li><li><p>调用 <code>addObject</code> 方法，设置域对象</p></li><li><p>前端控制器的解析需要控制器方法提供一个视图名称，因此调用 <code>setViewName</code> 方法来设置一个视图名称。</p></li><li><p>方法的返回值必须是 ModelAndView</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModelAndView&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">testModelAndView</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;GetSuccess&quot;</span>,<span class="string">&quot;Hello,ModelAndView&quot;</span>);</span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主页中简单设置一个超链接，来测试我们的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;testModelAndView&#125;&quot;</span>&gt;</span>测试ModelAndView共享域对象<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击超链接后，页面展示如下：</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030478.png" alt="image-20221221185056075"></p><hr><p>###使用 Model 向 request 域对象中共享数据</p><p>Model 调用 <code>addAttribute</code> 设置域对象，在参数中加入 Model 即可。返回的仍然是 String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testModel</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;GetSuccess&quot;</span>, <span class="string">&quot;hello,Model&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###使用map向request域对象共享数据</p><p>直接用 map 存储键值对的方式设置域对象，注意：第一个参数必须是 String，第二个参数可以是 Object</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testMap&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testMap</span><span class="params">(Map&lt;String, Object&gt; map)</span>&#123;</span><br><span class="line">    map.put(<span class="string">&quot;GetSuccess&quot;</span>, <span class="string">&quot;hello,Map&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###使用ModelMap向request域对象共享数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModelMap&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testModelMap</span><span class="params">(ModelMap modelMap)</span>&#123;</span><br><span class="line">    modelMap.addAttribute(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,ModelMap&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Model ，map ，ModelMap 三者都是用形参的方式实现，而 ModelAndView 是通过在方法内创建对象的形式实现。</p></blockquote><p>###Model ，map，ModelMap 的关系</p><p>在上面实现共享域对象的操作，我们可以发现 Model ，map ，ModelMap 三种方式实现都有共同的特征，都需要作为形参来实现功能，下面，将分析它们之间存在的关系：</p><p>通过将上述上个对象进行输出，发现它们的 toString 方法格式一致，说明三者的实际类型应该是一致的，因此利用反射来获取它们的实际类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testMap&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testMap</span><span class="params">(Map&lt;Object, Object&gt; map)</span>&#123;</span><br><span class="line">    map.put(<span class="string">&quot;GetSuccess&quot;</span>, <span class="string">&quot;hello,Map&quot;</span>);</span><br><span class="line">    System.out.println(map.getClass().getName());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/testModel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testModel</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;GetSuccess&quot;</span>, <span class="string">&quot;hello,Model&quot;</span>);</span><br><span class="line">    System.out.println(model.getClass().getName());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/testModelMap&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testModelMap</span><span class="params">(ModelMap modelMap)</span>&#123;</span><br><span class="line">    modelMap.addAttribute(<span class="string">&quot;GetSuccess&quot;</span>, <span class="string">&quot;hello,ModelMap&quot;</span>);</span><br><span class="line">    System.out.println(modelMap.getClass().getName());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后它们都返回了一个类型：<code>BindingAwareModelMap</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.validation.support.BindingAwareModelMap</span><br></pre></td></tr></table></figure><p>通过看 ModelMap 的源码，可以看到它是 LinkedHashMap&lt;String, Object&gt;  子类，这说明它实现了 Map 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ModelMap</span> <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;String, Object&gt; &#123;</span><br></pre></td></tr></table></figure><p>打开类型层次结构：</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030479.png" alt="image-20221221194035888"></p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030480.png" alt="image-20221221194052731"></p><p>可以看到， ModelMap 存在子类 BindingAwareModelMap ，因此满足我们上面的情况</p><p>对于 Model 接口，它有一个接口实现类是 ExtendedModelMap ，而该类的子类就是 BindingAwareModelMap （可由上图看出）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendedModelMap</span> <span class="keyword">extends</span> <span class="title class_">ModelMap</span> <span class="keyword">implements</span> <span class="title class_">Model</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExtendedModelMap</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>并且，由于继承了 ModelMap类，所以它也实现了 Map 接口。</p><blockquote><p> <strong>注</strong>：实际上，上面使用的所有共享域对象的方法，最终<strong>都是封装到 ModelAndView 中</strong>。可以通过给各个方法中的类对象设置断点调试得到，它们最终都是被封装在前端控制器中的一个名为 mv 的 ModelAndView 对象中。</p></blockquote><hr><p>###向session域共享数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testSession&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testSession</span><span class="params">(HttpSession session)</span>&#123;</span><br><span class="line">    session.setAttribute(<span class="string">&quot;testSessionScope&quot;</span>, <span class="string">&quot;hello,session&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 success 页面中要获取 session 域对象，需要使用 <strong>session.键名</strong> ：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;session.GetSuccess&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试结果：</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030481.png" alt="image-20221221201443877"></p><hr><p>###向application域共享数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testApplication&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testApplication</span><span class="params">(HttpSession session)</span>&#123;</span><br><span class="line"><span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> session.getServletContext();</span><br><span class="line">    application.setAttribute(<span class="string">&quot;testApplicationScope&quot;</span>, <span class="string">&quot;hello,application&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 success 页面中和 session 一样，要用 application.键名 ：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;application.GetSuccess&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p>##SpringMVC的视图</p><p>SpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户</p><p>SpringMVC视图的种类很多，默认有转发视图和重定向视图</p><p>当工程引入jstl的依赖，转发视图会自动转换为JstlView</p><p>若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是ThymeleafView</p><p>###ThymeleafView</p><p>当控制器方法中所设置的视图名称<strong>没有任何前缀</strong>时，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testHello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testHello</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###转发视图</p><p>SpringMVC中默认的转发视图是InternalResourceView</p><p>SpringMVC中创建转发视图的情况：</p><p>当控制器方法中所设置的视图名称以”forward:”为前缀时，创建<strong>InternalResourceView</strong>视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”forward:”去掉，剩余部分作为最终路径通过转发的方式实现跳转</p><p>例如”forward:&#x2F;“（转发到主页），”forward:&#x2F;employee”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testForward&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testForward</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/testHello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="重定向视图"><a href="#重定向视图" class="headerlink" title="重定向视图"></a>重定向视图</h3><p>SpringMVC中默认的重定向视图是RedirectView</p><p>当控制器方法中所设置的视图名称以”redirect:”为前缀时，创建RedirectView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”redirect:”去掉，剩余部分作为最终路径通过重定向的方式实现跳转</p><p>例如”redirect:&#x2F;“，”redirect:&#x2F;employee”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRedirect&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRedirect</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/testHello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><p>重定向视图在解析时，会先将redirect:前缀去掉，然后会判断剩余部分是否以&#x2F;开头，若是则会自动拼接上下文路径</p></blockquote><hr><h3 id="视图控制器view-controller"><a href="#视图控制器view-controller" class="headerlink" title="视图控制器view-controller"></a>视图控制器view-controller</h3><p>当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用view-controller标签进行表示</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">path：设置处理的请求地址</span></span><br><span class="line"><span class="comment">view-name：设置请求地址所对应的视图名称</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/testView&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;success&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:view-controller</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注：</p><p>当SpringMVC中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，此时需要在SpringMVC的核心配置文件中设置开启mvc注解驱动的标签：</p><p>&lt;mvc:annotation-driven &#x2F;&gt;</p></blockquote><hr><p>##RESTful</p><h3 id="RESTful简介"><a href="#RESTful简介" class="headerlink" title="RESTful简介"></a>RESTful简介</h3><p>REST：<strong>Re</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer，表现层资源状态转移。</p><h5 id="a-gt-资源"><a href="#a-gt-资源" class="headerlink" title="a&gt;资源"></a>a&gt;资源</h5><p>资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个URI来标识。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的URI与其进行交互。</p><h5 id="b-gt-资源的表述"><a href="#b-gt-资源的表述" class="headerlink" title="b&gt;资源的表述"></a>b&gt;资源的表述</h5><p>资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如HTML&#x2F;XML&#x2F;JSON&#x2F;纯文本&#x2F;图片&#x2F;视频&#x2F;音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。</p><h5 id="c-gt-状态转移"><a href="#c-gt-状态转移" class="headerlink" title="c&gt;状态转移"></a>c&gt;状态转移</h5><p>状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。</p><blockquote><p>上面不必细看，反正也挺难看懂，大概就是将服务器中各种文件（XML，音频图片资源等）看作资源，然后在客户端和服务器之间实现资源的操作叫做状态转移。看下面的实际操作内容</p></blockquote><hr><h3 id="RESTful的实现"><a href="#RESTful的实现" class="headerlink" title="RESTful的实现"></a>RESTful的实现</h3><p>具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。</p><p>它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。</p><p>REST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。</p><table><thead><tr><th>操作</th><th>传统方式</th><th>REST风格</th></tr></thead><tbody><tr><td>查询操作</td><td>getUserById?id&#x3D;1</td><td>user&#x2F;1–&gt;get请求方式</td></tr><tr><td>保存操作</td><td>saveUser</td><td>user–&gt;post请求方式</td></tr><tr><td>删除操作</td><td>deleteUser?id&#x3D;1</td><td>user&#x2F;1–&gt;delete请求方式</td></tr><tr><td>更新操作</td><td>updateUser</td><td>user–&gt;put请求方式</td></tr></tbody></table><hr><h3 id="PUT-和-DELETE-请求方式的实现原理"><a href="#PUT-和-DELETE-请求方式的实现原理" class="headerlink" title="PUT 和 DELETE 请求方式的实现原理"></a>PUT 和 DELETE 请求方式的实现原理</h3><p>我们之前的实践知道，表单提交 PUT 和 DELETE 请求是无法直接实现的，因为表单没有这两种提交方式，而要想实现这两种提交，就需要使用到一个过滤器：<strong>org.springframework.web.filter.HiddenHttpMethodFilter</strong> ，将其注册在 web.xml 文件中，设置好对应的过滤器配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>hiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>hiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span><span class="comment">&lt;!--表示对所有路径都适用--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>HiddenHttpMethodFilter</strong> 处理put和delete请求的条件：</p><p>a&gt;当前请求的请求方式必须为post</p><p>b&gt;当前请求必须传输请求参数_method</p><p>满足以上条件，<strong>HiddenHttpMethodFilter</strong> 过滤器就会将当前请求的请求方式转换为请求参数_method的值，因此请求参数_method的值才是最终的请求方式</p><p>为何该类具有这种功能，我们可以对其源码进行了解：</p><ol><li>首先，它是一个过滤器，需要我们可以查找其 doFilter 方法或含有 FilterChain 参数的方法，这个就是创建过滤器的方法：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">requestToUse</span> <span class="operator">=</span> request;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;POST&quot;</span>.equals(request.getMethod()) &amp;&amp; request.getAttribute(<span class="string">&quot;javax.servlet.error.exception&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">paramValue</span> <span class="operator">=</span> request.getParameter(<span class="built_in">this</span>.methodParam);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(paramValue)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> paramValue.toUpperCase(Locale.ENGLISH);</span><br><span class="line">            <span class="keyword">if</span> (ALLOWED_METHODS.contains(method)) &#123;</span><br><span class="line">                requestToUse = <span class="keyword">new</span> <span class="title class_">HiddenHttpMethodFilter</span>.HttpMethodRequestWrapper(request, method);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，它首先创建了一个 HttpServletRequest  对象，用于保存发送的请求。随后，将其与 POST 请求方式比较，如果请求方式为 POST 则可进入 if 语句块。 if 语句块中将当前过滤器对象的 methodParam 属性对应的参数赋给了一个 String 变量。下面再将该变量变为大写，这个变大写的作用是用于在发送请求时，若为小写的请求，如（delete，put），就将其先转换为统一的大写再执行。</p><p>下面有一个变量：ALLOWED_METHODS，这是一个 List 集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; ALLOWED_METHODS;</span><br></pre></td></tr></table></figure><p>这个集合内存储了允许执行的 _method 请求方式。</p><p>我们可以在该类下找到一个静态代码块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    ALLOWED_METHODS = Collections.unmodifiableList(Arrays.asList(HttpMethod.PUT.name(), HttpMethod.DELETE.name(), HttpMethod.PATCH.name()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这不难看出，该变量有且仅有 PUT,DELETE,PATCH 三种请求方式的名字。</p><p>在上面的方法中还有如下一段代码，这是判断我们当前的 method 是否符合上述三种请求方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> paramValue.toUpperCase(Locale.ENGLISH);</span><br><span class="line"><span class="keyword">if</span> (ALLOWED_METHODS.contains(method)) &#123;</span><br><span class="line">    requestToUse = <span class="keyword">new</span> <span class="title class_">HiddenHttpMethodFilter</span>.HttpMethodRequestWrapper(request, method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>满足之后，就将我们一开始获得的 request 对象通过一个 HiddenHttpMethodFilter 构造器来赋值。</p><p>这是该构造器方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HttpMethodRequestWrapper</span><span class="params">(HttpServletRequest request, String method)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(request);</span><br><span class="line">    <span class="built_in">this</span>.method = method;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造器的 method 参数是我们传入的 _method 的值，用这个 HttpMethodRequestWrapper 包装器来包装到上面代码中的 requestToUse </p><p>完整的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HiddenHttpMethodFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; ALLOWED_METHODS;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_METHOD_PARAM</span> <span class="operator">=</span> <span class="string">&quot;_method&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">methodParam</span> <span class="operator">=</span> <span class="string">&quot;_method&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HiddenHttpMethodFilter</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMethodParam</span><span class="params">(String methodParam)</span> &#123;</span><br><span class="line">        Assert.hasText(methodParam, <span class="string">&quot;&#x27;methodParam&#x27; must not be empty&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.methodParam = methodParam;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">requestToUse</span> <span class="operator">=</span> request;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;POST&quot;</span>.equals(request.getMethod()) &amp;&amp; request.getAttribute(<span class="string">&quot;javax.servlet.error.exception&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">paramValue</span> <span class="operator">=</span> request.getParameter(<span class="built_in">this</span>.methodParam);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(paramValue)) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> paramValue.toUpperCase(Locale.ENGLISH);</span><br><span class="line">                <span class="keyword">if</span> (ALLOWED_METHODS.contains(method)) &#123;</span><br><span class="line">                    requestToUse = <span class="keyword">new</span> <span class="title class_">HiddenHttpMethodFilter</span>.HttpMethodRequestWrapper(request, method);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        filterChain.doFilter((ServletRequest)requestToUse, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ALLOWED_METHODS = Collections.unmodifiableList(Arrays.asList(HttpMethod.PUT.name(), HttpMethod.DELETE.name(), HttpMethod.PATCH.name()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HttpMethodRequestWrapper</span> <span class="keyword">extends</span> <span class="title class_">HttpServletRequestWrapper</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String method;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">HttpMethodRequestWrapper</span><span class="params">(HttpServletRequest request, String method)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(request);</span><br><span class="line">            <span class="built_in">this</span>.method = method;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getMethod</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.method;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此我们可以得出：我们要想实现 PUT 和 DELETE 请求，要有两个条件：一个是 POST 请求，一个是 methodParam 参数需要满足 PUT 、DELETE、 PATCH 。（即_method 要为上述三种）</p><p>因此，当我们要使用 PUT 请求方式的时候，就可以在原来表单的基础上，将 method 设置为 POST，而在其内部设置一个标签，设置一个 name 属性为 _method，将其值设为 PUT 即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/user&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;put&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;PUT&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;修改&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里还有一个细节问题</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>hiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>hiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在我们的配置中，我们将 HiddenHttpMethodFilter 放在了 CharacterEncodingFilter 前面。</p><p>我们知道，HiddenHttpMethodFilter 是需要获取请求参数的，因此会导致 CharacterEncodingFilter 失效，故我们需要将它们的位置进行替换：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>hiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>hiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p> 下面，我们就正式进行 RestFul 的案例操作：</p></blockquote><h2 id="RestFul-案例"><a href="#RestFul-案例" class="headerlink" title="RestFul 案例"></a>RestFul 案例</h2><h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h3><p>传统 CRUD 一样，实现对员工信息的增删改查。</p><ul><li><p>搭建环境</p><ul><li>新建项目，按照之前的教程，搭建一个 SpringMVC 工作环境。</li></ul></li><li><p>准备实体类，放在自定义包 bean 包内。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Integer id;</span><br><span class="line">   <span class="keyword">private</span> String lastName;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String email;</span><br><span class="line">   <span class="comment">//1 male, 0 female</span></span><br><span class="line">   <span class="keyword">private</span> Integer gender;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.id = id;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getLastName</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> lastName;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLastName</span><span class="params">(String lastName)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> email;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.email = email;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Integer <span class="title function_">getGender</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> gender;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(Integer gender)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.gender = gender;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(Integer id, String lastName, String email, Integer gender)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>();</span><br><span class="line">      <span class="built_in">this</span>.id = id;</span><br><span class="line">      <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">      <span class="built_in">this</span>.email = email;</span><br><span class="line">      <span class="built_in">this</span>.gender = gender;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>准备dao模拟数据，放在自定义包 dao 包中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.mvc.bean.Employee;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeDao</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Employee&gt; employees = <span class="literal">null</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">static</span>&#123;</span><br><span class="line">      employees = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Employee&gt;();</span><br><span class="line"></span><br><span class="line">      employees.put(<span class="number">1001</span>, <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1001</span>, <span class="string">&quot;E-AA&quot;</span>, <span class="string">&quot;aa@163.com&quot;</span>, <span class="number">1</span>));</span><br><span class="line">      employees.put(<span class="number">1002</span>, <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1002</span>, <span class="string">&quot;E-BB&quot;</span>, <span class="string">&quot;bb@163.com&quot;</span>, <span class="number">1</span>));</span><br><span class="line">      employees.put(<span class="number">1003</span>, <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1003</span>, <span class="string">&quot;E-CC&quot;</span>, <span class="string">&quot;cc@163.com&quot;</span>, <span class="number">0</span>));</span><br><span class="line">      employees.put(<span class="number">1004</span>, <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1004</span>, <span class="string">&quot;E-DD&quot;</span>, <span class="string">&quot;dd@163.com&quot;</span>, <span class="number">0</span>));</span><br><span class="line">      employees.put(<span class="number">1005</span>, <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1005</span>, <span class="string">&quot;E-EE&quot;</span>, <span class="string">&quot;ee@163.com&quot;</span>, <span class="number">1</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">initId</span> <span class="operator">=</span> <span class="number">1006</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Employee employee)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(employee.getId() == <span class="literal">null</span>)&#123;</span><br><span class="line">         employee.setId(initId++);</span><br><span class="line">      &#125;</span><br><span class="line">      employees.put(employee.getId(), employee);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> Collection&lt;Employee&gt; <span class="title function_">getAll</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> employees.values();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> Employee <span class="title function_">get</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> employees.get(id);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">      employees.remove(id);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是项目整体结构的截图：</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030482.png" alt="image-20221224113102255"></p><hr><h3 id="访问首页和查看员工信息"><a href="#访问首页和查看员工信息" class="headerlink" title="访问首页和查看员工信息"></a>访问首页和查看员工信息</h3><p>首先我们访问一下首页</p><ol><li>编写一个 index.html 页面作为首页：</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/employee&#125;&quot;</span>&gt;</span>查看员工信息<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>仅给它一个超链接，用于查看员工信息。</p><ol start="2"><li>编写员工的 Controller</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmployeeDao employeeDao;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/employee&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmployee</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">        Collection&lt;Employee&gt; employeeList = employeeDao.getAll();</span><br><span class="line">        model.addAttribute(<span class="string">&quot;employeeList&quot;</span>,employeeList);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;employee_list&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们需要查看员工信息，因此对应超链接设置映射的 value 值，同时超链接采用 GET 请求方式进行对应</p><p>控制器一般会封装一个实现功能对象的 Dao，接下来我们要通过它来获取员工的信息。</p><p>使用我们封装在类中的 employeeDao，调用方法来获取员工信息列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;Employee&gt; employeeList = employeeDao.getAll();</span><br></pre></td></tr></table></figure><p>这里我们使用 model 的方式来共享作用域：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.addAttribute(<span class="string">&quot;employeeList&quot;</span>,employeeList);</span><br></pre></td></tr></table></figure><p>最后要返回跳转的页面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">&quot;employee_list&quot;</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>在跳转后的页面 employee_list.html 中，我们通过前端和 thymeleaf 渲染技术来实现员工信息的显示：</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Employee info<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">colspan</span>=<span class="string">&quot;5&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center&quot;</span> <span class="attr">cellpadding</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span> &gt;</span>Employee info<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>id<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>lastname<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>email<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>gender<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>options<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;employee : $&#123;employeeList&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.id&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.lastName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.email&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.gender&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>update<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>delete<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不必在意太多代码，只需了解我们通过表格来显示这些信息。</p><p>使用 each 来让 List 集合中的内容分行显示在页面上，这里用 employee 作为一个变量来帮助表示对应的属性值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;employee : $&#123;employeeList&#125;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面就可以通过该变量对应的属性来显示值了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;employee : $&#123;employeeList&#125;&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.id&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.lastName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.email&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.gender&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果我们希望能够通过超链接来传输参数来确定我们要更新或删除的内容（例如以 id 来修改员工信息)，我们可以通过<strong>拼接</strong>的方式实现</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/employee/&#125;+$&#123;employee.id&#125;&quot;</span>&gt;</span>update<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>&#x2F;employee&#x2F;id 是 RestFul 的方式获取参数</p></blockquote><p>还可以放入到 href 中，但是需要前面的 <code>/employee/</code> 加上引号 ：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>update<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试结果：</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030483.png" alt="image-20221224122314896"></p><p>要实现修改或删除，还得再加上表单来确保请求方式：</p><p>例如要删除的话，表单如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;DELETE&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="实现删除操作"><a href="#实现删除操作" class="headerlink" title="实现删除操作"></a>实现删除操作</h3><p>删除操作的构想：</p><ul><li>首先是在员工列表页面 EmployeeList 中要有一个超链接来实现单击删除的操作</li><li>要使得请求方式为 delete，因此我们建立一个 form 表单设置请求方式，并且通过 vue 让我们点击超链接的事件转为 form 表单的提交操作，让超链接的跳转地址转为 表单的 action 地址。最后实现表单的提交</li><li>提交表单后，将请求发送到服务器，实现删除功能操作后跳转到员工列表界面 EmployeeList</li><li>点击删除后，页面保留在员工列表界面，但是原先点击的那条记录消失。</li></ul><ol><li>创建处理delete请求方式的表单（这是为了符合请求方式的约定，将删除的请求方式设为 delete）跳转的页面是下面超链接的href，这个操作我们通过 vue 来实现</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 作用：通过超链接控制表单的提交，将post请求转换为delete请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;deleteForm&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- HiddenHttpMethodFilter要求：必须传输_method请求参数，并且值为最终的请求方式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;delete&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>删除超链接绑定点击事件</li></ol><p>引入vue.js</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/vue.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>删除超链接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;deleteA&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;deleteEmployee&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>delete<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过vue处理点击事件（这里涉及前端，简单了解）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> vue = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>:<span class="string">&quot;#dataTable&quot;</span>,<span class="comment">//设置了表格的id，用于绑定 vue 实施的对象</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//event表示当前事件</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">deleteEmployee</span>:<span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//通过id获取表单标签</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> deleteForm = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;deleteForm&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//将触发事件的超链接的href属性为表单的action属性赋值</span></span></span><br><span class="line"><span class="language-javascript">                deleteForm.<span class="property">action</span> = event.<span class="property">target</span>.<span class="property">href</span>;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//提交表单</span></span></span><br><span class="line"><span class="language-javascript">                deleteForm.<span class="title function_">submit</span>();</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//阻止超链接的默认跳转行为</span></span></span><br><span class="line"><span class="language-javascript">                event.<span class="title function_">preventDefault</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>控制器方法<ul><li>这里能够确保我们点击删除之后，实现了记录删除和仍然返回到员工列表页面的功能。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;, method = RequestMethod.DELETE)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">deleteEmployee</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">    employeeDao.delete(id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/employee&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在我们以为大功告成时，我们发现，在点击了 delete 后，竟然显示 405。这是什么原因呢？</p></blockquote><p>这有两个原因：</p><ol><li>我们添加了 vue.js 的文件在 static 包中，由于这是在之后加入的配置，因此暂时还未被打包，因此我们需要重新打包，来确保该 static 文件在我们的项目 target 目录中。</li></ol><p>​确保存在 static 目录内有 vue.js ：</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030484.png" alt="image-20221225111324810"></p><p>仅需在 Maven 工具中重新打包即可</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030485.png" alt="image-20221225111408025"></p><p>除此之外，我们点击仍然还是有问题。这是因为 vue.js 文件是无法被前端控制器解析，我们之前能够调用 vue 框架，是因为我们使用了 Servlet 内置的一个默认解析器，使用它来调用 Servlet 处理 vue.js 即可。因此我们需要在 SpringMVC 配置文件中启动这个默认解析器，在 SpringMVC.xml 文件中放入下面代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>一旦加入了这个默认解析器，我们就必须加入注解驱动，否则无法正常使用</p><p>若没有添加注解驱动，则全部由默认解析器处理，加入了注解驱动则是先通过前端控制器进行处理，若前端控制器无法处理就使用默认解析器处理。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>现在我们点击 delete 即可实现所需的功能了。</p><h3 id="实现添加操作"><a href="#实现添加操作" class="headerlink" title="实现添加操作"></a>实现添加操作</h3><p>添加操作，实现的思路为：</p><ul><li><p>通过超链接，跳转到添加页面中（这里只有跳转页面的功能，因此可以通过配置文件跳转：</p><ul><li><pre><code class="xml">&lt;mvc:view-controller path=&quot;/toAdd&quot; view-name=&quot;Add_Employee&quot;&gt;&lt;/mvc:view-controller&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ 在跳转页面中，通过一个 form 表单，显示需要提交的内容，并设置跳转的地址 action 跳转到服务器端对应的映射地址：</span><br><span class="line"></span><br><span class="line">```html</span><br><span class="line">&lt;form th:action=&quot;@&#123;/addEmployee&#125;&quot; method=&quot;post&quot;&gt;</span><br><span class="line">   lastName:&lt;input type=&quot;text&quot; name=&quot;lastName&quot;&gt;&lt;br&gt;</span><br><span class="line">    email:&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;br&gt;</span><br><span class="line">    gender:&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot;&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;add&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p>服务器对应的映射方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/addEmployee&quot; ,method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">addEmployee</span><span class="params">(Employee employee)</span>&#123;</span><br><span class="line">    employeeDao.save(employee);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/employee&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这里我们通过重定向方式回到员工列表页面。（前一次请求不影响后续的结果）</p><hr><p>###执行更新</p><p>要实现更新，思路如下：</p><ul><li>在员工列表点击超链接 update ，跳转到一个更新页面，在该页面上要显示员工原来的信息，即实现回显。</li><li>修改完信息后，将页面再次跳转回员工列表，需要显示修改后的信息。</li></ul><ol><li>先来写超链接跳转的代码：</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>update<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过 id 来确定修改的对象，并将参数传给服务器对应控制器方法。</p><ol start="2"><li>控制器方法：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot; ,method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">updateEmployee</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id, Model model )</span>&#123;</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> employeeDao.get(id);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;employee&quot;</span>,employee);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;employee_update&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到 id 参数，同时将其存入域对象，随后转发到修改信息的页面 employee_update.html  ：</p><ol start="3"><li>页面主体的 form 表单如下：</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/employee&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;put&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;employee.id&#125;&quot;</span>&gt;</span></span><br><span class="line">    lastName:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;employee.lastName&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    email:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;employee.email&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    gender:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;$&#123;employee.gender&#125;&quot;</span>&gt;</span>male</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;$&#123;employee.gender&#125;&quot;</span>&gt;</span>female<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;update&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为是更新修改操作，所以请求方式为 put ，同时我们不希望用户可以修改 id，因此我们将该内容隐藏。并提示用户可以输入名字，邮箱，性别来更新员工信息。</p><p>在这里，用了 thymeleaf 的语法，来获取域对象和更新视图。注意：对于文本类型的，可以直接指定 th:value ，而对于 radio 这种选择项，要使用 th:field 来实现回显。</p><ol start="4"><li>接下来,当用户提交表单时，需要进行后台的记录更新，我们通过对应上述 action 属性中的内容设置控制器方法，并实现更新信息的功能，最后，还需要跳转回员工列表：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee&quot; ,method = RequestMethod.PUT)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">updateEmployee</span><span class="params">(Employee employee)</span>&#123;</span><br><span class="line">    employeeDao.save(employee);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/employee&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="HttpMessageConvert"><a href="#HttpMessageConvert" class="headerlink" title="HttpMessageConvert"></a>HttpMessageConvert</h2><p>HttpMessageConverter，报文信息转换器，将请求报文转换为Java对象，或将Java对象转换为响应报文</p><p>HttpMessageConverter提供了两个注解和两个类型：@RequestBody，@ResponseBody，RequestEntity，</p><p>ResponseEntity</p><p>###@RequestBody</p><p>@RequestBody可以获取请求体，需要在控制器方法设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值</p><p>例如，我们通过下面的 form 表单提交内容给控制器方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/testRequestBody&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是我们的控制器方法，我们可以通过 @RequestBody 来获取响应体的信息并跳转页面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RequestMapping(<span class="string">&quot;/testRequestBody&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequestBody</span><span class="params">(<span class="meta">@RequestBody</span> String requestBody)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;requestBody:&quot;</span>+requestBody);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestBody:username=admin&amp;password=123456</span><br></pre></td></tr></table></figure><hr><h3 id="RequestEntity"><a href="#RequestEntity" class="headerlink" title="RequestEntity"></a>RequestEntity</h3><p>RequestEntity 封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过 <code>getHeaders()</code> 获取请求头信息，通过 <code>getBody()</code> 获取请求体信息</p><p>例如，通过下面代码来获取请求头和请求体信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRequestEntity&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequestEntity</span><span class="params">(RequestEntity&lt;String&gt; requestEntity)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;requestHeader:&quot;</span>+requestEntity.getHeaders());</span><br><span class="line">    System.out.println(<span class="string">&quot;requestBody:&quot;</span>+requestEntity.getBody());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">requestHeader:[host:&quot;localhost:8080&quot;, connection:&quot;keep-alive&quot;, content-length:&quot;27&quot;, cache-control:&quot;max-age=0&quot;, sec-ch-ua:&quot;&quot; Not A;Brand&quot;;v=&quot;99&quot;, &quot;Chromium&quot;;v=&quot;90&quot;, &quot;Google Chrome&quot;;v=&quot;90&quot;&quot;, sec-ch-ua-mobile:&quot;?0&quot;, upgrade-insecure-requests:&quot;1&quot;, origin:&quot;http://localhost:8080&quot;, user-agent:&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36&quot;]</span><br><span class="line">requestBody:username=admin&amp;password=123</span><br></pre></td></tr></table></figure><hr><p>###@ResponseBody</p><p>@ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testResponseBody&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testResponseBody</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：这里的 <code>return &quot;success&quot;</code> 可不是视图跳转到页面 success.html ，而是一个包含 success 文本的新的页面，因为<strong>响应体本身就是一个页面。</strong></p><h3 id="用-ResponseBody-处理-json"><a href="#用-ResponseBody-处理-json" class="headerlink" title="用 @ResponseBody 处理 json"></a>用 @ResponseBody 处理 json</h3><p>有时候我们希望能响应给客户端一个 Java 对象，但是我们目前通过控制器只能返回字符串，因此我们需要其他的方式来使响应能够提供对象。因此我们能够使用 json 。 json 会将我们的 Java 对象转为字符串形式发送给客户端。</p><p>在我们不使用 json 时，我们直接发送对象给浏览器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/TestResponseBody&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">TestResponseBody</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">10</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提示500 </p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030486.png" alt="image-20221225221159640"></p><p>我们需要引入 json 的包来实现传输对象操作：</p><ol><li>导入jackson的依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在SpringMVC的核心配置文件中开启mvc的注解驱动，此时在HandlerAdaptor中会自动装配一个消息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的Java对象转换为Json格式的字符串</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>在处理器方法上使用@ResponseBody注解进行标识</p></li><li><p>将Java对象直接作为控制器方法的返回值返回，就会自动转换为Json格式的字符串</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/TestResponseBody&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">TestResponseBody</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">10</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来讲，就是我们不需要更改原来的内容，只需引入 json 的包即可实现响应对象操作：</p><p>结果如下：</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030487.png" alt="image-20221225221543768"></p><hr><p>###SpringMVC处理ajax</p><ol><li>请求超链接：</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testAjax&#125;&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;testAjax&quot;</span>&gt;</span>testAjax<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>通过vue和axios处理点击事件（要提前将 vue.js 和 axios.js 文件放入到 static 包下）：</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/vue.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/axios.min.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> vue = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">testAjax</span>:<span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">axios</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">url</span>:event.<span class="property">target</span>.<span class="property">href</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">params</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">username</span>:<span class="string">&quot;admin&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">password</span>:<span class="string">&quot;123456&quot;</span></span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="title function_">alert</span>(response.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125;);</span></span><br><span class="line"><span class="language-javascript">                event.<span class="title function_">preventDefault</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="RestController注解"><a href="#RestController注解" class="headerlink" title="@RestController注解"></a>@RestController注解</h3><p>@RestController注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@Controller注解，并且为其中的每个方法添加了@ResponseBody注解</p><hr><h3 id="ResponseEntity"><a href="#ResponseEntity" class="headerlink" title="ResponseEntity"></a>ResponseEntity</h3><p>ResponseEntity用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文</p><p>##文件下载</p><p>可以使用 ResponseEntity 直接作为一个响应报文发送给浏览器。用于下载服务器的文件：</p><p><strong>使用ResponseEntity实现下载文件的功能</strong></p><p>例如：要求在服务器中设置一张图片，我们希望用户在打开页面后点击超链接可以实现下载该图片</p><p>​思路：</p><ol><li>先在项目中设置一个 static 包并存入对应需要下载的图片</li><li>实现一个页面，需要有一个超链接，要求用户一但访问这个页面点击超链接后就会自动下载图片附件。</li><li>实现后端下载功能。</li></ol><p>​主要代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testDown&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;<span class="type">byte</span>[]&gt; testResponseEntity(HttpSession session) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//获取ServletContext对象</span></span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> session.getServletContext();</span><br><span class="line">    <span class="comment">//获取服务器中文件的真实路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> servletContext.getRealPath(<span class="string">&quot;/static/img/1.jpg&quot;</span>); </span><br><span class="line">    <span class="comment">//创建输入流</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(realPath);</span><br><span class="line">    <span class="comment">//创建字节数组</span></span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[is.available()];</span><br><span class="line">    <span class="comment">//将流读到字节数组中</span></span><br><span class="line">    is.read(bytes);</span><br><span class="line">    <span class="comment">//创建HttpHeaders对象设置响应头信息</span></span><br><span class="line">    MultiValueMap&lt;String, String&gt; headers = <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">    <span class="comment">//设置要下载方式以及下载文件的名字</span></span><br><span class="line">    headers.add(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename=1.jpg&quot;</span>);<span class="comment">//attachment表示以附件的形式下载</span></span><br><span class="line">    <span class="comment">//设置响应状态码</span></span><br><span class="line">    <span class="type">HttpStatus</span> <span class="variable">statusCode</span> <span class="operator">=</span> HttpStatus.OK;</span><br><span class="line">    <span class="comment">//创建ResponseEntity对象</span></span><br><span class="line">    ResponseEntity&lt;<span class="type">byte</span>[]&gt; responseEntity = <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(bytes, headers, statusCode);</span><br><span class="line">    <span class="comment">//关闭输入流</span></span><br><span class="line">    is.close();</span><br><span class="line">    <span class="keyword">return</span> responseEntity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需修改 1.jpg，选择对应的文件名，以及文件的真实路径 &#x2F;static&#x2F;img&#x2F;1.jpg </p><p>而创建 ResponseEntity 的三个参数一个是下载文件的数据流，一个是响应头信息，响应头是一个 MultiValueMap 接口的实现类，它们是 Map 的子类，我们知道它们存储的是键值对，这和响应头的形式相符合。最后还需要设置响应状态码，响应状态码就是我们在网页中常见的一些三位数数字，例如 200，404等。</p><p>需要将图片放在 webapp 下的 static 目录下的 img 目录中：</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030488.png" alt="image-20221228151714369"></p><blockquote><p>同样，不单单只能下载图片，还可以下载其他类型的文件，例如音频等。</p></blockquote><p>##文件上传</p><p>文件上传要求form表单的请求方式必须为post，并且添加属性enctype&#x3D;”multipart&#x2F;form-data”，这个属性，确保了表单提交是以二进制的形式实现。</p><p>SpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息</p><ol><li>添加依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在 SpringMVC 配置文件中添加配置：<ol><li>这个配置必须要有 id 属性，并且设置为 multipartResolver 属性值，这是因为 SpringMVC 的 IOC 容器是通过 id 来识别这个解析器，而并非是使用类型解析。</li></ol></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>控制器方法（我们可以在form表单点击提交时跳转到这个控制器方法实现上传功能）：<ol><li>关键点：需要使用 <strong>MultipartFile 类</strong>，这是存储上传文件的类。</li><li>通过 session 对象来设置一个上传路径用于保存文件。</li><li>为了避免上传文件时出现文件名重复的问题导致两个同名文件上传后将内容替换，需要给每个文件名设置一个 UUID ，这样就避免了文件名重复的问题。</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testUp&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testUp</span><span class="params">(MultipartFile photo, HttpSession session)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//获取上传的文件的文件名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> photo.getOriginalFilename();</span><br><span class="line">    <span class="comment">//处理文件重名问题</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">hzName</span> <span class="operator">=</span> fileName.substring(fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>));<span class="comment">//所有文件都有一个后缀，通过获取其文件名中包括&#x27;.&#x27;的后缀来确保文件格式正确。</span></span><br><span class="line">    fileName = UUID.randomUUID().toString() + hzName;<span class="comment">//通过随机生成一个 UUID ，来作为上传文件的文件名。</span></span><br><span class="line">    <span class="comment">//获取服务器中photo目录的路径</span></span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> session.getServletContext();</span><br><span class="line">    <span class="type">String</span> <span class="variable">photoPath</span> <span class="operator">=</span> servletContext.getRealPath(<span class="string">&quot;photo&quot;</span>);<span class="comment">//设置一个保存上传文件的目录路径</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(photoPath);</span><br><span class="line">    <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">        file.mkdir();<span class="comment">//用于创建目录，若无 file 文件对应路径的目录，则会创建该目录</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">finalPath</span> <span class="operator">=</span> photoPath + File.separator + fileName;<span class="comment">//File.separator是目录分隔符，在目录中常见到的/或\，由于我们无法确定使用哪一种分隔符，因此我们使用这个方法。</span></span><br><span class="line">    <span class="comment">//实现上传功能</span></span><br><span class="line">    photo.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(finalPath));<span class="comment">//调用MultipartFile对象的 transferTo 来上传文件到指定路径中。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>###拦截器简介</p><p>SpringMVC中的拦截器用于拦截控制器方法的执行</p><p>我们知道，在 SpringMVC 项目的执行流程中，请求会经过如下过程：</p><ol><li>过滤器过滤</li><li>前端控制器解析</li><li>控制器方法响应请求</li></ol><p>而拦截器就是在前端控制器解析后，在执行控制器方法的过程中进行操作。</p><p>拦截器包括三种情况，一个是在控制器方法执行之前，一个是控制器方法执行之后，还有是在视图渲染之后</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030489.png" alt="image-20221228172638683"></p><hr><h3 id="拦截器的配置"><a href="#拦截器的配置" class="headerlink" title="拦截器的配置"></a>拦截器的配置</h3><ol><li>创建一个类，实现接口 <code>HandlerInterceptor</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span></span><br></pre></td></tr></table></figure><p>重写三个默认方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们虽然设置了拦截器实现类，但是我们还没有让 SpringMVC 识别到，因此我们需要在 SpringMVC.xml 配置文件中进行配置。</p><p><strong>SpringMVC 关于拦截器的配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.mvc.Controller.FirstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;firstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/testRequestEntity&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;firstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><p>在我们设置好拦截器的配置和对应的拦截器类型后，我们可以启动服务器，发现页面打开后并没有显示内容，这说明拦截器具有拦截功能，使得我们页面不能正常显示。下面，我们将深入了解这个拦截功能。</p><p>拦截器有三种流程情况，是哪一个流程导致了我们的页面被拦截 ?</p><p>我们在拦截器实现类中发现 preHandle 方法有一个返回值，而另外两个方法并没有，因此我们在此下一个断点进入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;FirstInterceptor-----&gt;preHandle&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到执行到下图中的方法：</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030490.png" alt="image-20221228182330312"></p><p>这是拦截器的 preHandle 方法的返回值，如果为 false ，则 applyPreHandle 方法返回 false，若为 true，则不进入这条 if 语句。</p><p>我们知道，我们现在设置的 preHandle 返回值为 false，这也是<strong>重写方法时默认设置</strong>的。所以我们会进入这个 if 语句。</p><p>可以看到，返回 false 了：</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030491.png" alt="image-20221228182553207"></p><p>接下来进入了这条 if 语句：</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030492.png" alt="image-20221228182624340"></p><p>我们知道，刚才我们的 applyPreHandle 方法返回了 false，所以会进入这条 if 语句，因此我们的方法会直接返回。而该类中后面的语句不再执行。可是，我们可以看到，在该语句后就是我们实际创建 ModelAndView 实现视图解析的语句，若未执行该语句，就无法进行视图解析，因此由此可知：</p><ul><li><strong>如果我们的 preHandle 方法返回了 false ，就会产生拦截，而设置为 true，就不会产生拦截</strong>。</li></ul><p><strong>总结</strong></p><p>除了 bean 的方式配置拦截器，还可以使用 ref 和 mvc:mapping， bean 和 ref 设置的拦截器拦截所有请求，而 mvc:mapping 可以设置拦截请求的路径。</p><hr><h3 id="多个拦截器的执行顺序"><a href="#多个拦截器的执行顺序" class="headerlink" title="多个拦截器的执行顺序"></a>多个拦截器的执行顺序</h3><p>根据当前请求，找到 <strong>HandlerExecutionChain</strong>【可以处理请求的handler以及handler的所有 拦截器】</p><p>a&gt;若每个拦截器的preHandle()都返回true</p><p>此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关：</p><p>preHandle()会按照配置的顺序执行，而postHandle()和afterComplation()会按照配置的反序执行</p><p>b&gt;若某个拦截器的preHandle()返回了false</p><p>preHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false的拦截器之前的拦截器的afterComplation()会执行</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030493.png" alt="image-20221228185039327"></p><p>从这张图中可以看到，preHandle 是按照配置顺序执行，而 postHandle 和 afterCompletion 是按照配置的反序执行。</p><p>##异常处理器</p><h3 id="基于配置的异常处理"><a href="#基于配置的异常处理" class="headerlink" title="基于配置的异常处理"></a>基于配置的异常处理</h3><p>SpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：<strong>HandlerExceptionResolver</strong></p><p>HandlerExceptionResolver接口的实现类有：DefaultHandlerExceptionResolver和SimpleMappingExceptionResolver</p><p>SpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver，使用方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionMappings&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        properties的键表示处理器方法执行过程中出现的异常</span></span><br><span class="line"><span class="comment">        properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;java.lang.ArithmeticException&quot;</span>&gt;</span>error<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionAttribute&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p>###基于注解的异常处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@ControllerAdvice将当前类标识为异常处理的组件</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@ExceptionHandler用于设置所标识方法处理的异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(ArithmeticException.class)</span></span><br><span class="line">    <span class="comment">//ex表示当前请求处理中出现的异常对象</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleArithmeticException</span><span class="params">(Exception ex, Model model)</span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;ex&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>##注解配置SpringMVC</p><p>使用配置类和注解代替web.xml和SpringMVC配置文件的功能</p><h3 id="创建初始化类，代替web-xml"><a href="#创建初始化类，代替web-xml" class="headerlink" title="创建初始化类，代替web.xml"></a>创建初始化类，代替web.xml</h3><p>在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器。<br>Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为<strong>AbstractAnnotationConfigDispatcherServletInitializer</strong>，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。</p><p>实现该类的对应方法，根据不同配置类对应在不同方法的数组返回值中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebInit</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定spring的配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定SpringMVC的配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;WebConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定DispatcherServlet的映射规则，即url-pattern</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加过滤器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">        <span class="type">CharacterEncodingFilter</span> <span class="variable">encodingFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>();</span><br><span class="line">        encodingFilter.setEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        encodingFilter.setForceRequestEncoding(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">HiddenHttpMethodFilter</span> <span class="variable">hiddenHttpMethodFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HiddenHttpMethodFilter</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Filter</span>[]&#123;encodingFilter, hiddenHttpMethodFilter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建SpringConfig配置类，代替spring的配置文件"><a href="#创建SpringConfig配置类，代替spring的配置文件" class="headerlink" title="创建SpringConfig配置类，代替spring的配置文件"></a><strong>创建SpringConfig配置类，代替spring的配置文件</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line"><span class="comment">//ssm整合之后，spring的配置信息写在此类中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建WebConfig配置类，代替SpringMVC的配置文件"><a href="#创建WebConfig配置类，代替SpringMVC的配置文件" class="headerlink" title="创建WebConfig配置类，代替SpringMVC的配置文件"></a><strong>创建WebConfig配置类，代替SpringMVC的配置文件</strong></h3><ol><li><p><code>@EnableWebMvc</code> 注解是设置该类为 SpringMVC 配置文件的注解，需要放在类上。</p></li><li><p>需要实现<code> WebMvcConfigurer</code> 接口，通过实现其各个方法来实现各种解析器的配置。</p></li></ol><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030494.png" alt="image-20221230194608535"></p><ol start="3"><li>也有一部分不是直接通过实现方法来配置的，例如文件上传解析器、模板解析器等，在 SpringMVC.xml 中是依靠 <code>Bean</code> 标签实现的，我们可以通过注解  <code>@Bean</code> 来实现。</li></ol><p>下面是我们之前使用过的各种解析器的注解实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//扫描组件</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.atguigu.mvc.controller&quot;)</span></span><br><span class="line"><span class="comment">//开启MVC注解驱动</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用默认的servlet处理静态资源</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置文件上传解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CommonsMultipartResolver <span class="title function_">multipartResolver</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonsMultipartResolver</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置拦截器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="type">FirstInterceptor</span> <span class="variable">firstInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FirstInterceptor</span>();</span><br><span class="line">        registry.addInterceptor(firstInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//配置视图控制</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">    public void addViewControllers(ViewControllerRegistry registry) &#123;</span></span><br><span class="line"><span class="comment">        registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//配置异常映射</span></span><br><span class="line">    <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">    public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123;</span></span><br><span class="line"><span class="comment">        SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver();</span></span><br><span class="line"><span class="comment">        Properties prop = new Properties();</span></span><br><span class="line"><span class="comment">        prop.setProperty(&quot;java.lang.ArithmeticException&quot;, &quot;error&quot;);</span></span><br><span class="line"><span class="comment">        //设置异常映射</span></span><br><span class="line"><span class="comment">        exceptionResolver.setExceptionMappings(prop);</span></span><br><span class="line"><span class="comment">        //设置共享异常信息的键</span></span><br><span class="line"><span class="comment">        exceptionResolver.setExceptionAttribute(&quot;ex&quot;);</span></span><br><span class="line"><span class="comment">        resolvers.add(exceptionResolver);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置生成模板解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ITemplateResolver <span class="title function_">templateResolver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">WebApplicationContext</span> <span class="variable">webApplicationContext</span> <span class="operator">=</span> ContextLoader.getCurrentWebApplicationContext();</span><br><span class="line">        <span class="comment">// ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得</span></span><br><span class="line">        <span class="type">ServletContextTemplateResolver</span> <span class="variable">templateResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletContextTemplateResolver</span>(</span><br><span class="line">                webApplicationContext.getServletContext());</span><br><span class="line">        templateResolver.setPrefix(<span class="string">&quot;/WEB-INF/templates/&quot;</span>);</span><br><span class="line">        templateResolver.setSuffix(<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">        templateResolver.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        templateResolver.setTemplateMode(TemplateMode.HTML);</span><br><span class="line">        <span class="keyword">return</span> templateResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成模板引擎并为模板引擎注入模板解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SpringTemplateEngine <span class="title function_">templateEngine</span><span class="params">(ITemplateResolver templateResolver)</span> &#123;</span><br><span class="line">        <span class="type">SpringTemplateEngine</span> <span class="variable">templateEngine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringTemplateEngine</span>();</span><br><span class="line">        templateEngine.setTemplateResolver(templateResolver);</span><br><span class="line">        <span class="keyword">return</span> templateEngine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成视图解析器并未解析器注入模板引擎</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ViewResolver <span class="title function_">viewResolver</span><span class="params">(SpringTemplateEngine templateEngine)</span> &#123;</span><br><span class="line">        <span class="type">ThymeleafViewResolver</span> <span class="variable">viewResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThymeleafViewResolver</span>();</span><br><span class="line">        viewResolver.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        viewResolver.setTemplateEngine(templateEngine);</span><br><span class="line">        <span class="keyword">return</span> viewResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="SpringMVC执行流程"><a href="#SpringMVC执行流程" class="headerlink" title="SpringMVC执行流程"></a>SpringMVC执行流程</h2><blockquote><p>这个部分具体可以看视频的最后4集。可以更直观的理解。笔记仅仅做了简单的介绍。</p></blockquote><p>###SpringMVC常用组件</p><ul><li>DispatcherServlet：<strong>前端控制器</strong>，不需要工程师开发，由框架提供</li></ul><p>​作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求</p><ul><li>HandlerMapping：<strong>处理器映射器</strong>，不需要工程师开发，由框架提供</li></ul><p>​作用：根据请求的url、method等信息查找Handler，即控制器方法</p><ul><li>Handler：<strong>处理器</strong>，需要工程师开发</li></ul><p>​作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理</p><ul><li>HandlerAdapter：<strong>处理器适配器</strong>，不需要工程师开发，由框架提供</li></ul><p>​作用：通过HandlerAdapter对处理器（控制器方法）进行执行</p><ul><li>ViewResolver：<strong>视图解析器</strong>，不需要工程师开发，由框架提供</li></ul><p>​作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、RedirectView</p><ul><li>View：<strong>视图</strong></li></ul><p>​作用：将模型数据通过页面展示给用户</p><h3 id="DispatcherServlet初始化过程"><a href="#DispatcherServlet初始化过程" class="headerlink" title="DispatcherServlet初始化过程"></a>DispatcherServlet初始化过程</h3><p>DispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度。</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030495.png" alt="images"></p><h5 id="a-gt-初始化WebApplicationContext"><a href="#a-gt-初始化WebApplicationContext" class="headerlink" title="a&gt;初始化WebApplicationContext"></a>a&gt;初始化WebApplicationContext</h5><p>所在类：org.springframework.web.servlet.FrameworkServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> WebApplicationContext <span class="title function_">initWebApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">WebApplicationContext</span> <span class="variable">rootContext</span> <span class="operator">=</span></span><br><span class="line">        WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">    <span class="type">WebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.webApplicationContext != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// A context instance was injected at construction time -&gt; use it</span></span><br><span class="line">        wac = <span class="built_in">this</span>.webApplicationContext;</span><br><span class="line">        <span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">            <span class="type">ConfigurableWebApplicationContext</span> <span class="variable">cwac</span> <span class="operator">=</span> (ConfigurableWebApplicationContext) wac;</span><br><span class="line">            <span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line">                <span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line">                <span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line">                <span class="keyword">if</span> (cwac.getParent() == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// The context instance was injected without an explicit parent -&gt; set</span></span><br><span class="line">                    <span class="comment">// the root application context (if any; may be null) as the parent</span></span><br><span class="line">                    cwac.setParent(rootContext);</span><br><span class="line">                &#125;</span><br><span class="line">                configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No context instance was injected at construction time -&gt; see if one</span></span><br><span class="line">        <span class="comment">// has been registered in the servlet context. If one exists, it is assumed</span></span><br><span class="line">        <span class="comment">// that the parent context (if any) has already been set and that the</span></span><br><span class="line">        <span class="comment">// user has performed any initialization such as setting the context id</span></span><br><span class="line">        wac = findWebApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class="line">        <span class="comment">// 创建WebApplicationContext</span></span><br><span class="line">        wac = createWebApplicationContext(rootContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.refreshEventReceived) &#123;</span><br><span class="line">        <span class="comment">// Either the context is not a ConfigurableApplicationContext with refresh</span></span><br><span class="line">        <span class="comment">// support or the context injected at construction time had already been</span></span><br><span class="line">        <span class="comment">// refreshed -&gt; trigger initial onRefresh manually here.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.onRefreshMonitor) &#123;</span><br><span class="line">            <span class="comment">// 刷新WebApplicationContext</span></span><br><span class="line">            onRefresh(wac);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.publishContext) &#123;</span><br><span class="line">        <span class="comment">// Publish the context as a servlet context attribute.</span></span><br><span class="line">        <span class="comment">// 将IOC容器在应用域共享</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">attrName</span> <span class="operator">=</span> getServletContextAttributeName();</span><br><span class="line">        getServletContext().setAttribute(attrName, wac);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="b-gt-创建WebApplicationContext"><a href="#b-gt-创建WebApplicationContext" class="headerlink" title="b&gt;创建WebApplicationContext"></a>b&gt;创建WebApplicationContext</h5><p>所在类：org.springframework.web.servlet.FrameworkServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> WebApplicationContext <span class="title function_">createWebApplicationContext</span><span class="params">(<span class="meta">@Nullable</span> ApplicationContext parent)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; contextClass = getContextClass();</span><br><span class="line">    <span class="keyword">if</span> (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(</span><br><span class="line">            <span class="string">&quot;Fatal initialization error in servlet with name &#x27;&quot;</span> + getServletName() +</span><br><span class="line">            <span class="string">&quot;&#x27;: custom WebApplicationContext class [&quot;</span> + contextClass.getName() +</span><br><span class="line">            <span class="string">&quot;] is not of type ConfigurableWebApplicationContext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过反射创建 IOC 容器对象</span></span><br><span class="line">    <span class="type">ConfigurableWebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span></span><br><span class="line">        (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line"></span><br><span class="line">    wac.setEnvironment(getEnvironment());</span><br><span class="line">    <span class="comment">// 设置父容器</span></span><br><span class="line">    wac.setParent(parent);</span><br><span class="line">    <span class="type">String</span> <span class="variable">configLocation</span> <span class="operator">=</span> getContextConfigLocation();</span><br><span class="line">    <span class="keyword">if</span> (configLocation != <span class="literal">null</span>) &#123;</span><br><span class="line">        wac.setConfigLocation(configLocation);</span><br><span class="line">    &#125;</span><br><span class="line">    configureAndRefreshWebApplicationContext(wac);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="c-gt-DispatcherServlet初始化策略"><a href="#c-gt-DispatcherServlet初始化策略" class="headerlink" title="c&gt;DispatcherServlet初始化策略"></a>c&gt;DispatcherServlet初始化策略</h5><p>FrameworkServlet创建WebApplicationContext后，刷新容器，调用onRefresh(wac)，此方法在DispatcherServlet中进行了重写，调用了initStrategies(context)方法，初始化策略，即初始化DispatcherServlet的各个组件</p><p>所在类：org.springframework.web.servlet.DispatcherServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initStrategies</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">   initMultipartResolver(context);</span><br><span class="line">   initLocaleResolver(context);</span><br><span class="line">   initThemeResolver(context);</span><br><span class="line">   initHandlerMappings(context);</span><br><span class="line">   initHandlerAdapters(context);</span><br><span class="line">   initHandlerExceptionResolvers(context);</span><br><span class="line">   initRequestToViewNameTranslator(context);</span><br><span class="line">   initViewResolvers(context);</span><br><span class="line">   initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DispatcherServlet调用组件处理请求"><a href="#DispatcherServlet调用组件处理请求" class="headerlink" title="DispatcherServlet调用组件处理请求"></a>DispatcherServlet调用组件处理请求</h3><h5 id="a-gt-processRequest"><a href="#a-gt-processRequest" class="headerlink" title="a&gt;processRequest()"></a>a&gt;processRequest()</h5><p>FrameworkServlet重写HttpServlet中的service()和doXxx()，这些方法中调用了processRequest(request, response)</p><p>所在类：org.springframework.web.servlet.FrameworkServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">    <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">failureCause</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">LocaleContext</span> <span class="variable">previousLocaleContext</span> <span class="operator">=</span> LocaleContextHolder.getLocaleContext();</span><br><span class="line">    <span class="type">LocaleContext</span> <span class="variable">localeContext</span> <span class="operator">=</span> buildLocaleContext(request);</span><br><span class="line"></span><br><span class="line">    <span class="type">RequestAttributes</span> <span class="variable">previousAttributes</span> <span class="operator">=</span> RequestContextHolder.getRequestAttributes();</span><br><span class="line">    <span class="type">ServletRequestAttributes</span> <span class="variable">requestAttributes</span> <span class="operator">=</span> buildRequestAttributes(request, response, previousAttributes);</span><br><span class="line"></span><br><span class="line">    <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class="keyword">new</span> <span class="title class_">RequestBindingInterceptor</span>());</span><br><span class="line"></span><br><span class="line">    initContextHolders(request, localeContext, requestAttributes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 执行服务，doService()是一个抽象方法，在DispatcherServlet中进行了重写</span></span><br><span class="line">        doService(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ServletException | IOException ex) &#123;</span><br><span class="line">        failureCause = ex;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        failureCause = ex;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Request processing failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        resetContextHolders(request, previousLocaleContext, previousAttributes);</span><br><span class="line">        <span class="keyword">if</span> (requestAttributes != <span class="literal">null</span>) &#123;</span><br><span class="line">            requestAttributes.requestCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">        logResult(request, response, failureCause, asyncManager);</span><br><span class="line">        publishRequestHandledEvent(request, response, startTime, failureCause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="b-gt-doService"><a href="#b-gt-doService" class="headerlink" title="b&gt;doService()"></a>b&gt;doService()</h5><p>所在类：org.springframework.web.servlet.DispatcherServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    logRequest(request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Keep a snapshot of the request attributes in case of an include,</span></span><br><span class="line">    <span class="comment">// to be able to restore the original attributes after the include.</span></span><br><span class="line">    Map&lt;String, Object&gt; attributesSnapshot = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class="line">        attributesSnapshot = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class="line">        <span class="keyword">while</span> (attrNames.hasMoreElements()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">attrName</span> <span class="operator">=</span> (String) attrNames.nextElement();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123;</span><br><span class="line">                attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make framework objects available to handlers and view objects.</span></span><br><span class="line">    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class="line">    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="built_in">this</span>.localeResolver);</span><br><span class="line">    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="built_in">this</span>.themeResolver);</span><br><span class="line">    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.flashMapManager != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">FlashMap</span> <span class="variable">inputFlashMap</span> <span class="operator">=</span> <span class="built_in">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line">        <span class="keyword">if</span> (inputFlashMap != <span class="literal">null</span>) &#123;</span><br><span class="line">            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">        &#125;</span><br><span class="line">        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> <span class="title class_">FlashMap</span>());</span><br><span class="line">        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="built_in">this</span>.flashMapManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">RequestPath</span> <span class="variable">requestPath</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.parseRequestPath &amp;&amp; !ServletRequestPathUtils.hasParsedRequestPath(request)) &#123;</span><br><span class="line">        requestPath = ServletRequestPathUtils.parseAndCache(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 处理请求和响应</span></span><br><span class="line">        doDispatch(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// Restore the original attribute snapshot, in case of an include.</span></span><br><span class="line">            <span class="keyword">if</span> (attributesSnapshot != <span class="literal">null</span>) &#123;</span><br><span class="line">                restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (requestPath != <span class="literal">null</span>) &#123;</span><br><span class="line">            ServletRequestPathUtils.clearParsedRequestPath(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="c-gt-doDispatch"><a href="#c-gt-doDispatch" class="headerlink" title="c&gt;doDispatch()"></a>c&gt;doDispatch()</h5><p>所在类：org.springframework.web.servlet.DispatcherServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">processedRequest</span> <span class="operator">=</span> request;</span><br><span class="line">    <span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">multipartRequestParsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Exception</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            mappedHandler：调用链</span></span><br><span class="line"><span class="comment">                包含handler、interceptorList、interceptorIndex</span></span><br><span class="line"><span class="comment">            handler：浏览器发送的请求所匹配的控制器方法</span></span><br><span class="line"><span class="comment">            interceptorList：处理控制器方法的所有拦截器集合</span></span><br><span class="line"><span class="comment">            interceptorIndex：拦截器索引，控制拦截器afterCompletion()的执行</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">           <span class="comment">// 通过控制器方法创建相应的处理器适配器，调用所对应的控制器方法</span></span><br><span class="line">            <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isGet</span> <span class="operator">=</span> <span class="string">&quot;GET&quot;</span>.equals(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">&quot;HEAD&quot;</span>.equals(method)) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用拦截器的preHandle()</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Actually invoke the handler.</span></span><br><span class="line">            <span class="comment">// 由处理器适配器调用具体的控制器方法，最终获得ModelAndView对象</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            applyDefaultViewName(processedRequest, mv);</span><br><span class="line">            <span class="comment">// 调用拦截器的postHandle()</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            <span class="comment">// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,</span></span><br><span class="line">            <span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">            dispatchException = <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler dispatch failed&quot;</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 后续处理：处理模型数据和渲染视图</span></span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">                               <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler processing failed&quot;</span>, err));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">            <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">                cleanupMultipart(processedRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="d-gt-processDispatchResult"><a href="#d-gt-processDispatchResult" class="headerlink" title="d&gt;processDispatchResult()"></a>d&gt;processDispatchResult()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                   <span class="meta">@Nullable</span> HandlerExecutionChain mappedHandler, <span class="meta">@Nullable</span> ModelAndView mv,</span></span><br><span class="line"><span class="params">                                   <span class="meta">@Nullable</span> Exception exception)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">errorView</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ModelAndViewDefiningException) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;ModelAndViewDefiningException encountered&quot;</span>, exception);</span><br><span class="line">            mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> (mappedHandler != <span class="literal">null</span> ? mappedHandler.getHandler() : <span class="literal">null</span>);</span><br><span class="line">            mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">            errorView = (mv != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Did the handler return a view to render?</span></span><br><span class="line">    <span class="keyword">if</span> (mv != <span class="literal">null</span> &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">        <span class="comment">// 处理模型数据和渲染视图</span></span><br><span class="line">        render(mv, request, response);</span><br><span class="line">        <span class="keyword">if</span> (errorView) &#123;</span><br><span class="line">            WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;No view rendering, null ModelAndView returned.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">        <span class="comment">// Concurrent handling started during a forward</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Exception (if any) is already handled..</span></span><br><span class="line">        <span class="comment">// 调用拦截器的afterCompletion()</span></span><br><span class="line">        mappedHandler.triggerAfterCompletion(request, response, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringMVC的执行流程"><a href="#SpringMVC的执行流程" class="headerlink" title="SpringMVC的执行流程"></a>SpringMVC的执行流程</h3><ol><li><p>用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获。</p></li><li><p>DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI），判断请求URI对应的映射：</p></li></ol><p>a) 不存在</p><p>i. 再判断是否配置了mvc:default-servlet-handler</p><p>ii. 如果没配置，则控制台报映射查找不到，客户端展示404错误</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030496.png" alt="image-20210709214911404"></p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030497.png" alt="image-20210709214947432"></p><p>iii. 如果有配置，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404错误</p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030498.png" alt="image-20210709215255693"></p><p><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/202306101030499.png" alt="image-20210709215336097"></p><p>b) 存在则执行下面的流程</p><ol start="3"><li><p>根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain执行链对象的形式返回。</p></li><li><p>DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。</p></li><li><p>如果成功获得HandlerAdapter，此时将开始执行拦截器的preHandler(…)方法【正向】</p></li><li><p>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)方法，处理请求。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：</p></li></ol><p>a) HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息</p><p>b) 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等</p><p>c) 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</p><p>d) 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</p><ol start="7"><li><p>Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象。</p></li><li><p>此时将开始执行拦截器的postHandle(…)方法【逆向】。</p></li><li><p>根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver进行视图解析，根据Model和View，来渲染视图。</p></li><li><p>渲染视图完毕执行拦截器的afterCompletion(…)方法【逆向】。</p></li><li><p>将渲染结果返回给客户端。</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git基本操作教程</title>
      <link href="/Shirly.github.io/2023/08/04/%E9%80%9A%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/Git/"/>
      <url>/Shirly.github.io/2023/08/04/%E9%80%9A%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/Git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git介绍"><a href="#Git介绍" class="headerlink" title="Git介绍"></a>Git介绍</h1><p>​Git 是目前世界上最先进的分布式版本控制系统。</p><blockquote><p>什么是版本控制系统？</p></blockquote><p>可以举一个例子：我们在编辑文案的时候时常需要修改文件，而如果我们希望将修改前的内容恢复，那么我们就需要先将原来的内容保存下来再修改。因此就会出现一个情况，就是我们保存的文件副本越来越多，当我们需要恢复文件内容的时候发现，一大堆的文件难以查找到确切的位置。当你希望把文档给同事进行编辑的时候，得把你的改动和他的改动进行合并，这个操作在内容十分庞大的文件中十分繁琐。</p><p>于是，我们就希望有这么一个软件，它能帮助我们进行修改内容的记录，还能实现同事协作编辑。这样就可以避免了需要创建许多副本和内容合并的问题。</p><h2 id="集中式版本控制系统和分布式版本控制系统"><a href="#集中式版本控制系统和分布式版本控制系统" class="headerlink" title="集中式版本控制系统和分布式版本控制系统"></a>集中式版本控制系统和分布式版本控制系统</h2><h3 id="集中式版本控制系统"><a href="#集中式版本控制系统" class="headerlink" title="集中式版本控制系统"></a>集中式版本控制系统</h3><p>集中式版本控制系统是通过一个中央服务器来统一管理所有用户提交的代码，用户需要从中央服务器中获取项目来进行开发工作。</p><p><strong>优势和劣势：</strong></p><p>集中式版本控制系统虽然实现了版本控制，它也能让多个用户协作来开发项目，用户也可以很轻松的看到其他用户的修改，但是，一旦中央服务器发生了故障，就会导致所有的用户都无法提交更新，在服务器恢复之前，任何人都无法协同工作。</p><h3 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h3><p>分布式版本控制系统没有中央服务器，它可以让所有用户都拥有整个项目的代码，用户就可以在本机进行修改和版本控制，代码存储在远程库中，远程库是一个代码托管中心，所有用户可以把代码推送到远程库上。而用户若需要获取代码，可以从远程库上克隆代码到本机。</p><p>若远程库服务器出现了故障，也可以直接到同事的电脑上获取代码，若是你已经提前克隆了代码，你仅仅只是在服务器故障的时间段中无法tui’s</p><h2 id="Git-工作机制"><a href="#Git-工作机制" class="headerlink" title="Git 工作机制"></a>Git 工作机制</h2><p><img src="/Shirly.github.io/Git.assets/image-20230629170732473.png" alt="image-20230629170732473"></p><p>解释：</p><ol><li><p><strong>工作区</strong></p><p>用于存储代码的位置，相当于我们创建一个工程项目后的那个目录。我们可以对这个区域的代码进行更新。</p></li><li><p><strong>暂存区</strong></p><p>工作区完成的代码需要添加到暂存区，暂存区可以临时存储我们在工作区添加的代码。暂存区的代码仍然可以删除。</p></li><li><p><strong>本地库</strong></p><p>可以将暂存区的代码提交到本地库，代码提交到本地库后就会生成对应的版本，这个代码就无法再删除了。本地库中的代码是基于上一个版本的代码进行的更新。</p></li></ol><h2 id="代码托管中心"><a href="#代码托管中心" class="headerlink" title="代码托管中心"></a>代码托管中心</h2><p>代码托管中心是基于网络服务器的远程代码仓库，一般我们称之为远程库。</p><p>局域网：</p><p>​GitLab （自己公司可以搭建一个GitLab）</p><p>互联网：</p><p>​GitHub (外网)</p><p>​Gitee  （国内平台）</p><p><strong>代码提交到本地库后，可以再将本地库的代码推送到远程库</strong></p><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>不用多解释，直接搜索 git， 官网下载稳定版本就好。</p><p>除了路径选择外，安装过程的全部选默认。</p><p>安装完成后，可以查看一下git是否成功安装：</p><p>打开 Git Bash：</p><p><img src="/Shirly.github.io/Git.assets/image-20230629173525319.png" alt="image-20230629173525319"></p><p>输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><p>or：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git -v</span><br></pre></td></tr></table></figure><p><img src="/Shirly.github.io/Git.assets/image-20230629173619596.png" alt="image-20230629173619596"></p><p>显示版本即安装完成。</p><h2 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h2><p>首次安装Git，要设置一下用户签名，否则无法正常提交代码。</p><p>这里设置的用户签名和 GitHub 的账号没有任何关系。</p><p>配置签名的作用：只是<strong>区分不同开发人员的身份</strong>。</p><p><strong>设置用户名</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &lt;用户名&gt; </span><br></pre></td></tr></table></figure><p><strong>设置邮箱</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &lt;邮箱&gt;</span><br></pre></td></tr></table></figure><p>作为版本控制系统的客户端，每台客户机对版本库的所有提交操作，都需要注明操作者的身份。所以客户机首先需要进行自我身份的注册，即创建用户。</p><p><strong>初始化本地库</strong></p><p>我们在本地磁盘中任意新建一个文件夹，将其作为Git的本地库。</p><p>我们在该目录下右击选择 Git Bash</p><p>然后输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>即可实现初始化本地库</p><p><img src="/Shirly.github.io/Git.assets/image-20230629193614076.png" alt="image-20230629193614076"></p><p>在该目录下就会生成一个 .git文件夹：</p><p><img src="/Shirly.github.io/Git.assets/image-20230629193709212.png" alt="image-20230629193709212"></p><p><strong>查看状态</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>我们对刚才创建的本地库调用一下：</p><p><img src="/Shirly.github.io/Git.assets/image-20230629193915142.png" alt="image-20230629193915142"></p><p>提示了没有任何提交。</p><p>这个结果很显然，现在我们还没有提交代码到本地库呢。</p><p>这里我们通过下述代码创建一个文本文件 hello，然后在里面输入一些内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim hello.txt</span><br></pre></td></tr></table></figure><p><img src="/Shirly.github.io/Git.assets/image-20230629194502622.png" alt="image-20230629194502622"></p><blockquote><p>这里讲一下linux复制粘贴的方法：选中一行按两次y就是复制，然后按p粘贴。然后输入完文本后，按 ’shift‘ + ’:‘ 再输入wq保存退出文本。</p></blockquote><p>此时我们创建好文件后，再查看状态，即输入 git status：</p><p><img src="/Shirly.github.io/Git.assets/image-20230629194702928.png" alt="image-20230629194702928"></p><p>这里仍然有问题，但是我们的 hello.txt 文件已经被检测到了，但是 git 还未追踪文件。</p><p><strong>添加暂存区</strong></p><p>上面我们还未追踪 hello.txt，我们需要将该文件添加到暂存区：</p><p>输入如下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add hello.txt</span><br></pre></td></tr></table></figure><p>然后我们再 git status 看一下状态：</p><p><img src="/Shirly.github.io/Git.assets/image-20230629195155552.png" alt="image-20230629195155552"></p><p>本地库中仍然为空。但是这里的 hello.txt 变绿了，说明 git 已经对该文件进行追踪。但此时文件还未生成历史版本，仍然可以被删除。</p><p><strong>删除暂存区文件</strong></p><p>暂存区的内容是可以被删除的，上图给了我们对应的指令，这里我们调用下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached&lt;文件名&gt;</span><br></pre></td></tr></table></figure><p>删除后 ,hello.txt 又变红了：</p><p><img src="/Shirly.github.io/Git.assets/image-20230629195515241.png" alt="image-20230629195515241"></p><p>虽然被删除了，但是是删除的暂存区的文件，并不是工作区，因此，在资源管理器下的 hello.txt 仍然存在：</p><p><img src="/Shirly.github.io/Git.assets/image-20230629195727055.png" alt="image-20230629195727055"></p><p>这里将hello.txt从暂存区删除了，但为了接下来能够继续我们的学习，我们先将 hello.txt 添加到暂存区。</p><p><strong>提交本地库</strong></p><p>通过下述指令将暂存区内容提交本地库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &lt;<span class="string">&quot;message&quot;</span>&gt; hello.txt</span><br></pre></td></tr></table></figure><p>提交后，若我们再查看一下状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p><img src="/Shirly.github.io/Git.assets/image-20230629200654405.png" alt="image-20230629200654405"></p><p><strong>查看日志</strong></p><p>查看版本信息日志命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><p><img src="/Shirly.github.io/Git.assets/image-20230629200809767.png" alt="image-20230629200809767"></p><p>可以看到版本号（这里的版本号是被<strong>简化</strong>后的），该版本的描述。</p><p>查看更详细日志命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p><img src="/Shirly.github.io/Git.assets/image-20230629200928128.png" alt="image-20230629200928128"></p><p>可以看到提交该文件的作者和时间，以及完整的版本号。</p><h1 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h1><p>我们上面已经成功提交了 hello.txt 的第一个版本到本地库，现在，我们要修改这个文件：</p><p>进入文件</p><p><img src="/Shirly.github.io/Git.assets/image-20230629201910747.png" alt="image-20230629201910747"></p><p>在一第行加入一串2后保存退出：</p><p><img src="/Shirly.github.io/Git.assets/image-20230629201954014.png" alt="image-20230629201954014"></p><p>下面我们来看一下 git 的状态（git status）：</p><p><img src="/Shirly.github.io/Git.assets/image-20230629202030190.png" alt="image-20230629202030190"></p><p>又爆红了，这里给出的提示是 modified，说明我们修改了文件，我们如果要再次跟踪并提交，只需要再执行刚才的两条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add hello.txt</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&#x27;second commit&#x27;</span> hello.txt</span><br></pre></td></tr></table></figure><p>这里的描述信息改成了第二次提交版本。</p><p><img src="/Shirly.github.io/Git.assets/image-20230629202240393.png" alt="image-20230629202240393"></p><p>这里提示我们一行增加，一行减少，指的是 git 将之前的第一行删除，改为我们新编写的内容添加进去。</p><p>这里我们再查看一下日志（git reflog 或者 git log）:</p><p><img src="/Shirly.github.io/Git.assets/image-20230629202314120.png" alt="image-20230629202314120"></p><p>可以看得出来， git 的指针已经成功更改为最新的 second commit 版本。</p><blockquote><p>这里我再修改一个内容，在第二行加入几个3，然后再提交一下。</p></blockquote><h1 id="版本穿梭"><a href="#版本穿梭" class="headerlink" title="版本穿梭"></a>版本穿梭</h1><p>当我们提交了几个版本之后，git 的指针总是指向最新提交的那个版本，但现实是我们有可能需要使用过去的版本，因此我们需要能够将 git 的指针指向过去提交过的版本。那么，我们该如何实现呢？</p><p>使用下面的命名，我们就可以自由地选择版本号中穿梭了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure><p>我在下图中将git从原本指向第三版本修改为指向第二版本。</p><p><img src="/Shirly.github.io/Git.assets/image-20230629203508074.png" alt="image-20230629203508074"></p><p><img src="/Shirly.github.io/Git.assets/image-20230629203644522.png" alt="image-20230629203644522"></p><p>这里再查看日志，就会看到现在的git已经指向了第二个版本号了，</p><p>并且，我们进行版本穿梭的行为也会记录在日志中。</p><p><strong>在资源管理器中查看版本号</strong></p><p>我们打开.git目录：</p><p><img src="/Shirly.github.io/Git.assets/image-20230629203750574.png" alt="image-20230629203750574"></p><p>这里的 HEAD 文件显示了当前的分支：</p><p><img src="/Shirly.github.io/Git.assets/image-20230629203846705.png" alt="image-20230629203846705"></p><p>我们打开 refs 目录，进入 heads 目录，里面有一个 master 文件（这里里就存储了当前 git 指向的版本对应的版本号）：</p><p><img src="/Shirly.github.io/Git.assets/image-20230629203910093.png" alt="image-20230629203910093"></p><p>用文本软件打开它：</p><p><img src="/Shirly.github.io/Git.assets/image-20230629203941921.png" alt="image-20230629203941921"></p><p>此时，你可以尝试将 hello.txt 和 master 文件同时用文本编辑器打开，然后再用上面的版本穿梭指令执行更换版本，你就会发现这两个文件里的内容会跟着你的版本修改而变更。</p><h1 id="Git分支操作"><a href="#Git分支操作" class="headerlink" title="Git分支操作"></a>Git分支操作</h1><p>服务器运行模式：</p><p><img src="/Shirly.github.io/Git.assets/image-20230629205133697.png" alt="image-20230629205133697"></p><p>服务器分为多种：生产、测试、线上环境。不同任务的开发者通过不同的分支进行不同的工作。</p><p>在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支，使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行。一个分支相当于一个单独的副本，底层是指针的引用。</p><p>多个分支经过各自的测试提交直到稳定后，再合并到主线分支。</p><p><strong>分支的好处</strong></p><ol><li>同时并行推进多个功能开发，提高并发效率。</li><li>各个分支开发过程中，若某一个分支开发失败，不会对其他分支有任何影响。</li></ol><p>分支实际上都是指向具体版本记录的指针，当前所在的分支，其实是由HEAD决定的，所以创建分支的本质就是多创建一个指针。</p><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><p><strong>创建分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 分支名</span><br></pre></td></tr></table></figure><p><strong>查看分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -v</span><br></pre></td></tr></table></figure><p><strong>切换分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 分支名</span><br></pre></td></tr></table></figure><p><strong>把指定分支合并到当前分支上</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge 分支名</span><br></pre></td></tr></table></figure><p>我们先来查看一下分支：</p><p>目前只有 master 分支</p><p><img src="/Shirly.github.io/Git.assets/image-20230629210015580.png" alt="image-20230629210015580"></p><p>接下来我们创建一下分支：</p><p><img src="/Shirly.github.io/Git.assets/image-20230629210119394.png" alt="image-20230629210119394"></p><p>这里我们可以看到，两个分支的版本号都是相同的，说明分配到不同任务的开发者可以在各自的分支中拿到同样版本的代码。</p><p>接下来，我们来切换一下分支，将当前的指向master的分支改成指向 hot-fix 分支上：</p><p><img src="/Shirly.github.io/Git.assets/image-20230629210704377.png" alt="image-20230629210704377"></p><p>我们可以查看一下分支，可以看到现在已经切换到 hot-fix分支了。</p><p>然后我们在 hot-fix 分支下修改 hello.txt的内容（减少2和3的个数），提交，查看日志：</p><p><img src="/Shirly.github.io/Git.assets/image-20230629211021426.png" alt="image-20230629211021426"></p><p>可以看到指针已经指向 hot-fix分支，并显示提交日志</p><p>同时资源管理器中我们的文件也发生了变化：</p><p>出现了两个分支：</p><p><img src="/Shirly.github.io/Git.assets/image-20230629211250384.png" alt="image-20230629211250384"></p><p><img src="/Shirly.github.io/Git.assets/image-20230629211218314.png" alt="image-20230629211218314"></p><p><img src="/Shirly.github.io/Git.assets/image-20230629211224382.png" alt="image-20230629211224382"></p><p><img src="/Shirly.github.io/Git.assets/image-20230629211233104.png" alt="image-20230629211233104"></p><p>两个分支对应的版本号是不同的。</p><h2 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a><strong>分支合并</strong></h2><p><strong>正常合并</strong></p><p>上面我们在不同的分支进行了各自的提交操作，从而在不同的分支上的 hello.txt 的版本是不同的，而我们最终是需要将它们合并在一起的。</p><p>下面我们来合并一下分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge 分支名</span><br></pre></td></tr></table></figure><p>这里的分支名是将选择的分支合并到当前的分支下，也就是用命令中的分支对应的版本来更新我们当前分支下的版本的内容。</p><p>我们切换回master分支并合并 hot-fix 分支：</p><p><img src="/Shirly.github.io/Git.assets/image-20230629211738089.png" alt="image-20230629211738089"></p><p>然后我们查看一下 hello.txt 的内容：</p><p><img src="/Shirly.github.io/Git.assets/image-20230629211811369.png" alt="image-20230629211811369"></p><p><strong>冲突合并</strong></p><p>合并分支时，两个分支在同一个文件的同一个位置有两套完全不同的修改。Git无法替代我们决定使用哪一个，必须人为决定新代码的内容。</p><p>我们先对两个分支的 hello.txt 都做一些修改。</p><p>然后，我们套用上面的命令把 hot-fix合并到 master中，会发现它出现了错误，但是它会处于一个新的状态，master|merging，这样的情况下，我们可以再打开 hello.txt 页面，手动将我们需要的内容更新保存，并删除不需要的内容，最后提交即可。这时更新的是 master 这个分支。</p><p>出现了冲突</p><p><img src="/Shirly.github.io/Git.assets/image-20230630211213251.png" alt="image-20230630211213251"></p><p>但是此刻我们已经进入了合并的状态：</p><p><img src="/Shirly.github.io/Git.assets/image-20230630211328957.png" alt="image-20230630211328957"></p><p>我们只需要手动修改合并内容即可，进入hello.txt：</p><p><img src="/Shirly.github.io/Git.assets/image-20230630211347820.png" alt="image-20230630211347820"></p><p>这里HEAD指的就是我们当前分支修改的内容。而下面被<code>=========</code> 分开的下半部分就是hot-fix修改的部分，</p><p><img src="/Shirly.github.io/Git.assets/image-20230630211404075.png" alt="image-20230630211404075"></p><p>因此我们只需要保留我们真正需要的部分，删除上面和下面的Hello Git!语句以及它标识分支的语句，让两个 test 语句留下后保存即可。</p><p><img src="/Shirly.github.io/Git.assets/image-20230630211611903.png" alt="image-20230630211611903"></p><p>此时我们再查看状态：</p><p><img src="/Shirly.github.io/Git.assets/image-20230630211655791.png" alt="image-20230630211655791"></p><p>我们只需要再次跟踪提交即可。</p><blockquote><p>注意，最后的提交不需要再指定文件名了。</p></blockquote><p><img src="/Shirly.github.io/Git.assets/image-20230630211755428.png" alt="image-20230630211755428"></p><p>我们再来查看一下日志：</p><p><img src="/Shirly.github.io/Git.assets/image-20230630211809870.png" alt="image-20230630211809870"></p><h1 id="团队协作"><a href="#团队协作" class="headerlink" title="团队协作"></a>团队协作</h1><p><strong>团队内部协作</strong></p><p>机制如图：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701160018916.png" alt="image-20230701160018916"></p><p>团队内成员可以自由地拉取代码和推送代码。并且可以将远程库克隆到自己的本地库中。</p><p><strong>跨团队协作</strong></p><p>机制如图：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701160509729.png" alt="image-20230701160509729"></p><p>另一个团队的成员可以将主团队的代码传输自己的远程库B中，然后再通过克隆到自己的本地库，本地库经过修改之后再推送到自己的远程库，随后，需要向主团队的远程库发送推送请求，经过审核后可以推送给著团队的远程库A。</p><h1 id="GitHub操作"><a href="#GitHub操作" class="headerlink" title="GitHub操作"></a>GitHub操作</h1><h2 id="远程库操作"><a href="#远程库操作" class="headerlink" title="远程库操作"></a>远程库操作</h2><p><strong>创建远程库</strong></p><p>创建远程库很简单，登录GitHub后创建一个 repository 即可。最好将你上传的<strong>代码的目录名称与远程库名称一致</strong>。</p><p><strong>创建别名</strong></p><p>我们可以先查看一下别名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p><img src="/Shirly.github.io/Git.assets/image-20230701161503675.png" alt="image-20230701161503675"></p><p>此时我们没有任何一个别名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add &lt;别名&gt; &lt;远程库地址&gt;</span><br></pre></td></tr></table></figure><p><img src="/Shirly.github.io/Git.assets/image-20230701161725049.png" alt="image-20230701161725049"></p><p>下面我们再查看一下别名：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701161749334.png" alt="image-20230701161749334"></p><p>fetch表示拉取，push表示推送。这里表示创建了两个别名，分别可以拉取和推送</p><p><strong>Git推送到远程库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程库别名&gt; &lt;分支名&gt;</span><br></pre></td></tr></table></figure><p><img src="/Shirly.github.io/Git.assets/image-20230701163150095.png" alt="image-20230701163150095"></p><p>可能会碰上443网络超时问题，解决方案是设置全局代理。</p><p><a href="https://zhuanlan.zhihu.com/p/636418854">解决 Github port 443 : Timed out - 知乎 (zhihu.com)</a></p><p><strong>拉取代码到本地</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;远程库地址or远程库别名&gt; &lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><p>这里我们在GitHub远程库上对文档进行修改（最后加一行1）：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701163506859.png" alt="image-20230701163506859"></p><p>查看本地库：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701163634819.png" alt="image-20230701163634819"></p><p>显然，我们的本地库是还未更新的，因此我们这里要拉取远程库的代码到本地库：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701163706744.png" alt="image-20230701163706744"></p><p>再来看一下文件：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701163719178.png" alt="image-20230701163719178"></p><p><strong>克隆远程仓库到本地</strong></p><p>对于公共库，克隆代码是不需要登录账号的。直接指定地址即可。</p><p>clone会做如下操作：</p><ol><li>拉取代码</li><li>初始化本地库</li><li>创建别名</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;克隆地址&gt;</span><br></pre></td></tr></table></figure><p>我们创建一个新的文件夹：gitclone</p><p><img src="/Shirly.github.io/Git.assets/image-20230701164532004.png" alt="image-20230701164532004"></p><p>打开目录后点开 git bash</p><p><img src="/Shirly.github.io/Git.assets/image-20230701164625497.png" alt="image-20230701164625497"></p><p>复制远程库地址：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701164645302.png" alt="image-20230701164645302"></p><p><img src="/Shirly.github.io/Git.assets/image-20230701164711083.png" alt="image-20230701164711083"></p><p>可以在 gitclone 目录下看到克隆过来的 gitinit 项目：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701164802475.png" alt="image-20230701164802475"></p><p>打开：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701164814841.png" alt="image-20230701164814841"></p><p>我们查看一下克隆后的远程库别名：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701164851368.png" alt="image-20230701164851368"></p><p>这里统一都叫origin</p><h2 id="团队内协作实践"><a href="#团队内协作实践" class="headerlink" title="团队内协作实践"></a>团队内协作实践</h2><p>下面，我们希望能够将克隆的代码修改后提交给远程库。</p><p>我们的团队成员在自己的本地克隆并完成了对应的代码更新，他需要将新的代码推送到团队的远程库中，调用下述命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程库地址&gt; &lt;分支名&gt;</span><br></pre></td></tr></table></figure><p>但是，直接提交会被拒绝：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701192958209.png" alt="image-20230701192958209"></p><p>这是因为这位成员还未得到授权，我们登录拥有权限的账户给当前账户权限：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701194059232.png" alt="image-20230701194059232"></p><p>搜索账户名称，然后确认。</p><p>点击复制：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701194130113.png" alt="image-20230701194130113"></p><p>让团队成员访问复制的页面然后同一协作即可。</p><p><img src="/Shirly.github.io/Git.assets/image-20230701194252191.png" alt="image-20230701194252191"></p><p>现在，你就可以再次提交试试了。</p><p>提交成功，并修改了代码：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701194409222.png" alt="image-20230701194409222"></p><p>在GitHub上搜索项目时，如果你知道你所需项目的创作者，你可以这样搜索：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名/项目名</span><br></pre></td></tr></table></figure><p>可以更加精准地查找到你需要的项目</p><h2 id="跨团队协作实践"><a href="#跨团队协作实践" class="headerlink" title="跨团队协作实践"></a>跨团队协作实践</h2><p>对于需要跨团队的用户来说，他只需要打开需要跨团队项目，点击右上角的 fork，即可在自己的账户中创建该项目的远程库。</p><p><img src="/Shirly.github.io/Git.assets/image-20230701201136642.png" alt="image-20230701201136642"></p><p>随后，该用户对自己库中的项目完成了修改：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701201220720.png" alt="image-20230701201220720"></p><p><img src="/Shirly.github.io/Git.assets/image-20230701201238728.png" alt="image-20230701201238728"></p><p>但是，此时主团队的远程库仍未更新，我们只需要让跨团队成员点击 Pull requests：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701201322543.png" alt="image-20230701201322543"></p><p><img src="/Shirly.github.io/Git.assets/image-20230701201335659.png" alt="image-20230701201335659"></p><p><img src="/Shirly.github.io/Git.assets/image-20230701201405293.png" alt="image-20230701201405293"></p><p>这样后续就可以在主团队的账号中找到这个拉取请求（Pull requests）了。</p><h2 id="SSH免密登录"><a href="#SSH免密登录" class="headerlink" title="SSH免密登录"></a>SSH免密登录</h2><p>我们除了上面HTTPS的方式实现克隆、拉取、推送外，我们还可以通过SSH来实现这些功能。</p><p>SSH是一种网络协议，用于计算机之间的加密登录。通过SSH，可以把所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。利用SSH协议可以有效防止远程管理过程中的信息泄露问题。相比telnet，SSH更加安全可靠。您可以使用SSH协议来远程连接到其他计算机，以便在远程计算机上执行命令或操作文件。</p><p>这里提示我们还未配置：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701202521253.png" alt="image-20230701202521253"></p><p>点击头像，选择设置：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701202539464.png" alt="image-20230701202539464"></p><p><img src="/Shirly.github.io/Git.assets/image-20230701202559649.png" alt="image-20230701202559649"></p><p>标题任意，密钥的获取教程如下：</p><p>打开C盘，进入 User 目录，进入你的账户名称下的目录，会看到一个.ssh的文件：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701202721757.png" alt="image-20230701202721757"></p><p>我们不要进入该.ssh，直接在当前目录右击选择 Git Bash，并输入如下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &lt;邮箱&gt;</span><br></pre></td></tr></table></figure><p><code>ssh-keygen</code> ssh密钥生成命令</p><p><code>-t</code> 使用哪一种加密算法生成</p><p><code>rsa</code> 非对称加密协议</p><p><code>-C &lt;邮箱&gt;</code> 描述</p><p>输入后再按三下回车即可：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701203122967.png" alt="image-20230701203122967"></p><p>此时，.ssh目录下出现了3个文件：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701203204515.png" alt="image-20230701203204515"></p><p>我们可以直接查看 id_rsa.pub，或者通过 cd .ssh，然后 cat id_rsa.pub的方式来获取里面的内容，这个就是我们的ssh密钥了(它是以你刚才输入的邮箱结尾的)</p><p><img src="/Shirly.github.io/Git.assets/image-20230701203319455.png" alt="image-20230701203319455"></p><p><img src="/Shirly.github.io/Git.assets/image-20230701203517248.png" alt="image-20230701203517248"></p><p>接下来，我们通过SSH的方式来实现拉取和推送：</p><p>首先在远程库中找到SSH地址：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701203639997.png" alt="image-20230701203639997"></p><p>然后推送：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;ssh地址&gt; &lt;分支名&gt;</span><br></pre></td></tr></table></figure><p><img src="/Shirly.github.io/Git.assets/image-20230701203834531.png" alt="image-20230701203834531"></p><p>输入 yes</p><p><img src="/Shirly.github.io/Git.assets/image-20230701204004441.png" alt="image-20230701204004441"></p><p><img src="/Shirly.github.io/Git.assets/image-20230701204016105.png" alt="image-20230701204016105"></p><p>拉取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;ssh地址&gt; &lt;分支名&gt;</span><br></pre></td></tr></table></figure><p>我们先修改一下远程库的hello.txt内容：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701204048921.png" alt="image-20230701204048921"></p><p>然后调用指令拉取：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701204148400.png" alt="image-20230701204148400"></p><blockquote><p>有概率443，重试即可。</p></blockquote><p>查看一下本地的hello.txt：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701204218124.png" alt="image-20230701204218124"></p><p>有修改的内容。</p><h1 id="IDEA-操作-Git"><a href="#IDEA-操作-Git" class="headerlink" title="IDEA 操作 Git"></a>IDEA 操作 Git</h1><h2 id="配置-Git-忽略文件"><a href="#配置-Git-忽略文件" class="headerlink" title="配置 Git 忽略文件"></a>配置 Git 忽略文件</h2><p>我们创建 IDEA 项目时，会自动生成很多没必要的文件：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701204440204.png" alt="image-20230701204440204"></p><p>这些文件与项目的实际功能无关，不参与服务器上部署运行，把它们忽略掉能够屏蔽IDE工具之间差异。</p><p><strong>忽略实现方案</strong></p><ol><li>创建忽略规则文件 ： xxxx.ignore，一般建议是 git.ignore，我们可以在刚才你的用户文件夹下创建这个文件，然后复制下面内容。</li></ol><p>下面是该文件内容的通用模板：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Compiled class file</span></span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"><span class="comment"># Log file</span></span><br><span class="line">*.<span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># BlueJ files</span></span><br><span class="line">*.ctxt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mobile Tools for Java (J2ME)</span></span><br><span class="line">.mtj.tmp/<span class="comment"># Package Files #</span></span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.nar</span><br><span class="line">*.ear</span><br><span class="line">*.zip</span><br><span class="line">*.tar.gz</span><br><span class="line">*.rar</span><br><span class="line"></span><br><span class="line">hs_err_pid*</span><br><span class="line"></span><br><span class="line">.classpath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">target</span><br><span class="line">.idea</span><br><span class="line">*.iml</span><br></pre></td></tr></table></figure><p>虽然写好了忽略文件，但是Git此时还不知道这个文件，因此我们要修改配置。</p><p>点开同目录下的.gitconfig文件，在[core]栏下加上下面的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">excludesfile = &lt;你刚才git.ignore的地址&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意：地址中的斜杆要使用 ‘ &#x2F; ‘</p></blockquote><p><img src="/Shirly.github.io/Git.assets/image-20230701210151822.png" alt="image-20230701210151822"></p><h2 id="IDEA-配置-Git"><a href="#IDEA-配置-Git" class="headerlink" title="IDEA 配置 Git"></a>IDEA 配置 Git</h2><p>接下来我们在 IDEA 中配置 Git：</p><p>打开 IDEA，点击设置-&gt;版本控制-&gt;Git-&gt;选择你的git的安装路径：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701210335069.png" alt="image-20230701210335069"></p><p>选择 bin 目录下的 git.ext：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701210430182.png" alt="image-20230701210430182"></p><p>选完后，点击测试，会在下方显示Git的版本：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701210518072.png" alt="image-20230701210518072"></p><blockquote><p> 为了后续的介绍，我们先随便创建一个 maven 项目。</p></blockquote><p>要想在 IDEA 中使用 Git ，我们除了前面在射中中添加了 Git ，我们还需要在项目中添加上。</p><p>点击上方的 VCS-&gt;导入到版本控制-&gt;创建Git仓库</p><p><img src="/Shirly.github.io/Git.assets/image-20230701211522340.png" alt="image-20230701211522340"></p><p><img src="/Shirly.github.io/Git.assets/image-20230701211532591.png" alt="image-20230701211532591"></p><p>点击确定</p><p>可以看到，我们的项目中部分文件变红了：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701211556153.png" alt="image-20230701211556153"></p><p>这和我们之前在 Git 中没有追踪 hello.txt 是一致的情况。</p><p>我们只需要右键对应的文件，然后选择 Git，点击添加即可：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701211717641.png" alt="image-20230701211717641"></p><p>对应项目中出现了.git文件：<br><img src="/Shirly.github.io/Git.assets/image-20230701212000838.png" alt="image-20230701212000838"></p><p>现在变绿了：<br><img src="/Shirly.github.io/Git.assets/image-20230701211736201.png" alt="image-20230701211736201"></p><p>当然这样太麻烦了，我们也可以直接将整个项目进行添加和提交到本地库。</p><p><img src="/Shirly.github.io/Git.assets/image-20230701211846250.png" alt="image-20230701211846250"></p><p>项目中灰色的文件是被我们之前设置的忽略文件：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701212026497.png" alt="image-20230701212026497"></p><h2 id="版本切换"><a href="#版本切换" class="headerlink" title="版本切换"></a>版本切换</h2><p>这里我又提交了两次，并分别命名为 ：second commit 和 third commit。</p><p>然后我们点击项目左下角的 git ，并选择日志：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701212748999.png" alt="image-20230701212748999"></p><p>这里的黄色箭头就是指向我们当前项目的版本，我们可以右键选择切换版本。</p><h2 id="创建分支和切换分支"><a href="#创建分支和切换分支" class="headerlink" title="创建分支和切换分支"></a>创建分支和切换分支</h2><p>方法1：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701213418764.png" alt="image-20230701213418764"></p><p>方法2：</p><p>点击下方的分支名：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701213449115.png" alt="image-20230701213449115"></p><p><img src="/Shirly.github.io/Git.assets/image-20230701213457057.png" alt="image-20230701213457057"></p><p><img src="/Shirly.github.io/Git.assets/image-20230701213542240.png" alt="image-20230701213542240"></p><p>勾上签出分支，就会自动切换到 hot-fix 分支。</p><p>创建出新的分支后，若要切换回master分支，只需要再点击右下角的hot-fix，然后选择master，选择检出：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701213719032.png" alt="image-20230701213719032"></p><h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p><strong>正常合并</strong></p><p>在 hot-fix分支下多写了一行代码并提交：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701214033699.png" alt="image-20230701214033699"></p><p><img src="/Shirly.github.io/Git.assets/image-20230701214051775.png" alt="image-20230701214051775"></p><p>我们切换回master分支，然后将其合并：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701214142748.png" alt="image-20230701214142748"></p><p>合并后，master分支的代码也和 hot-fix 同步了：<br><img src="/Shirly.github.io/Git.assets/image-20230701214210762.png" alt="image-20230701214210762"></p><p><strong>冲突合并</strong></p><p>我们分别在 hot-fix 和 master 中都修改代码并提交：<br><img src="/Shirly.github.io/Git.assets/image-20230701214708954.png" alt="image-20230701214708954"></p><p><img src="/Shirly.github.io/Git.assets/image-20230701214743603.png" alt="image-20230701214743603"></p><p>然后我们按照上面同样的方式，用hot-fix合并 master：</p><p>弹出如下界面：</p><p>左边是master分支的修改，右边是hot-fix分支的修改：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701214832071.png" alt="image-20230701214832071"></p><p>两边的符号的含义如下：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701214934465.png" alt="image-20230701214934465"></p><p>在我们确认合并结果后点击应用：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701215004283.png" alt="image-20230701215004283"></p><p>日志状态：</p><p><img src="/Shirly.github.io/Git.assets/image-20230701215012744.png" alt="image-20230701215012744"></p><p>#IDEA集成GitHub</p><h2 id="IDEA登录GitHub"><a href="#IDEA登录GitHub" class="headerlink" title="IDEA登录GitHub"></a>IDEA登录GitHub</h2><p>在 IDEA 中点击设置-&gt;版本控制 -&gt;GitHub：</p><p><img src="/Shirly.github.io/Git.assets/image-20230702152543465.png" alt="image-20230702152543465"></p><p>这里我们可以直接通过账号密码登录：</p><p>会发现这种方式能难成功登录。<img src="/Shirly.github.io/Git.assets/image-20230702152634162.png" alt="image-20230702152634162"></p><p><img src="/Shirly.github.io/Git.assets/image-20230702152650352.png" alt="image-20230702152650352"></p><p>我们可以通过访问令牌（Token）的方式登录：</p><p>打开GitHub，点击头像-&gt;Setting-&gt;开发者设置-&gt;个人访问令牌-&gt;新建个人访问令牌（经典），生成一个令牌，这个令牌要将所有权限都开启。</p><p><img src="/Shirly.github.io/Git.assets/image-20230702153412833.png"></p><p>生成成功后，记得用一个文件保存令牌，因为我们刷新页面后将无法再看到：</p><p>回到IDEA中将访问令牌输入进去，访问成功：</p><p><img src="/Shirly.github.io/Git.assets/image-20230702153609708.png" alt="image-20230702153609708"></p><h2 id="分享代码到GitHub"><a href="#分享代码到GitHub" class="headerlink" title="分享代码到GitHub"></a>分享代码到GitHub</h2><p>在IDEA中分享代码可以自动将当前项目在 GitHub 上创建远程库并推送。</p><p>在IDEA中按照如下图所示点击：</p><p><img src="/Shirly.github.io/Git.assets/image-20230702154024054.png" alt="image-20230702154024054"></p><p>会弹出如下窗口：</p><p><img src="/Shirly.github.io/Git.assets/image-20230702154132633.png" alt="image-20230702154132633"></p><p>你可以设置远程库的名称，远程库的别名，远程库是否私有和描述等。</p><p>完成设置后点击 Share，一段时间后便完成了项目分享到GitHub</p><p><img src="/Shirly.github.io/Git.assets/image-20230702154244199.png" alt="image-20230702154244199"></p><h2 id="推送代码到GitHub"><a href="#推送代码到GitHub" class="headerlink" title="推送代码到GitHub"></a>推送代码到GitHub</h2><p>操作如图：</p><p><img src="/Shirly.github.io/Git.assets/image-20230702155057406.png" alt="image-20230702155057406"></p><p>我们现在本地中对代码做一些修改：</p><p><img src="/Shirly.github.io/Git.assets/image-20230702155214392.png" alt="image-20230702155214392"></p><p>完成常规的对本地库的追踪提交，后按照上图推送的操作进行：</p><p><img src="/Shirly.github.io/Git.assets/image-20230702155432505.png" alt="image-20230702155432505"></p><p><img src="/Shirly.github.io/Git.assets/image-20230702155441559.png" alt="image-20230702155441559"></p><h2 id="IDEA-拉取代码"><a href="#IDEA-拉取代码" class="headerlink" title="IDEA 拉取代码"></a>IDEA 拉取代码</h2><p>我们先在远程库中对代码做一些修改：</p><p><img src="/Shirly.github.io/Git.assets/image-20230702155541035.png" alt="image-20230702155541035"></p><p>然后回到IDEA，进行如下操作：</p><p><img src="/Shirly.github.io/Git.assets/image-20230702155603681.png" alt="image-20230702155603681"></p><p><img src="/Shirly.github.io/Git.assets/image-20230702155633967.png" alt="image-20230702155633967"></p><p>可以看到代码拉取成功：</p><p><img src="/Shirly.github.io/Git.assets/image-20230702155650017.png" alt="image-20230702155650017"></p><blockquote><p> 注意：拉取代码之前，一定要确认自己本地代码是未修改的，否则拉取代码下来会导致冲突，本地修改的代码可能会消失。</p></blockquote><p><strong>ssh实现推送和拉取</strong></p><p>我们之前配置了ssh，现在来使用它的地址来实现上述功能：</p><p>打开推送功能：</p><p><img src="/Shirly.github.io/Git.assets/image-20230702155855938.png" alt="image-20230702155855938"></p><p>点击上面的git-test，然后选择定义远程：</p><p><img src="/Shirly.github.io/Git.assets/image-20230702155916972.png" alt="image-20230702155916972"></p><p><img src="/Shirly.github.io/Git.assets/image-20230702155922337.png" alt="image-20230702155922337"></p><p>这里我们起名叫做：ssh-git（任意，方便辨别就行）</p><p>然后我们到GitHub上找到项目的 ssh 地址：</p><p><img src="/Shirly.github.io/Git.assets/image-20230702160102772.png" alt="image-20230702160102772"></p><p>你就可以按照之前的教程对ssh的地址进行操作了。</p><h2 id="克隆代码"><a href="#克隆代码" class="headerlink" title="克隆代码"></a>克隆代码</h2><p>我们现在要把远程库中的代码克隆到本地。操作如下：<img src="/Shirly.github.io/Git.assets/image-20230702160533018.png" alt="image-20230702160533018"></p><p>你可以直接输入URL来复制，</p><p>这里的URL一般公司会直接提供它们远程库中的地址，我们现在可以从自己的远程库中选择一个URL，复制粘贴过来即可。</p><p><img src="/Shirly.github.io/Git.assets/image-20230702160935486.png" alt="image-20230702160935486"></p><p>若该项目的远程库在你的GitHub账户上，你也可以直接点击你的账户，然后克隆对应的项目</p><p><img src="/Shirly.github.io/Git.assets/image-20230702161032177.png" alt="image-20230702161032177"></p><h2 id="（码云）Gitee-操作"><a href="#（码云）Gitee-操作" class="headerlink" title="（码云）Gitee 操作"></a>（码云）Gitee 操作</h2><p>Gitee是国内的开源代码托管平台，类似于GitHub国内版（，相较于GitHub,由于是国内的平台，它在推送代码拉取代码等行为会比GitHub更流畅，受网络影响小。</p><p>类似于GitHub,我们先去Gitee上注册一个账号，然后你可以顺便绑定一下你的GitHub，方便你的登录操作。</p><p>码云的页面和GitHub类似，你也可以自由地创建仓库，上传代码。</p><p>我们可以提前创建一个空的远程库叫做 git-test。便于你后面的推送拉取操作。</p><p><img src="/Shirly.github.io/Git.assets/image-20230702162630238.png" alt="image-20230702162630238"></p><p>回到IDEA，我们要先下载 Gitee 的插件：</p><p><img src="/Shirly.github.io/Git.assets/image-20230702162726079.png" alt="image-20230702162726079"></p><p>安装完成后，我们重启IDEA，就可以在VCS中看到 Gitee 的图标了。</p><p><img src="/Shirly.github.io/Git.assets/image-20230702162809552.png" alt="image-20230702162809552"></p><p>剩下的操作和GitHub类似，你可以分享代码、推送代码、拉取代码、克隆代码到你的远程库or你的本地库中，只是把操作从GitHub改成Gitee而已。</p><h2 id="将GitHub的远程库复制到Gitee"><a href="#将GitHub的远程库复制到Gitee" class="headerlink" title="将GitHub的远程库复制到Gitee"></a>将GitHub的远程库复制到Gitee</h2><p>我们创建一个新的仓库时，若是希望将GitHub上的项目复制到Gitee上，我们可以点击下图中的链接：</p><p><img src="/Shirly.github.io/Git.assets/image-20230702163558955.png" alt="image-20230702163558955"></p><p><img src="/Shirly.github.io/Git.assets/image-20230702163658049.png" alt="image-20230702163658049"></p><p>我们可以直接输入GitHub上项目对应的HTTPS协议的URL来导入仓库，若你绑定了GitHub账号，你也可以直接点击’’导入 GitHub 仓库’’ 来直接导入你需要的远程库。</p><p>我们将GitHub上的 gitinit 远程库导入到Gitee上。</p><p><strong>同步更新</strong></p><p>我们在GitHub上的远程库中修改了代码，我们若希望在Gitee上同步修改，只需要点击Gitee对应远程库中名称右边的符号：<img src="/Shirly.github.io/Git.assets/image-20230702164026350.png" alt="image-20230702164026350"></p><p>等待片刻即可实现更新。</p><h1 id="GitLab"><a href="#GitLab" class="headerlink" title="GitLab"></a>GitLab</h1><p>GitLab 是一个自建代码托管平台。其使用 Git 作为代码管理工具。是使用 MIT 许可证的基于网络的 Git 仓库管理工具。</p><p><a href="https://about.gitlab.com/">The DevSecOps Platform | GitLab</a></p><p>打开GitLab官网，然后选择 install：</p><p><img src="/Shirly.github.io/Git.assets/image-20230702170103037.png" alt="image-20230702170103037"></p><blockquote><p>注意：这里需要提前购买服务器来使用，或者你安装一个虚拟机</p></blockquote><p>这里我们往下拉，选择 CentOS7，当然你选择你对应的服务器版本即可。</p><p>将这行命令放到服务器的&#x2F;opt&#x2F;module下安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.rpm.sh | sudo bash</span><br></pre></td></tr></table></figure><p><img src="/Shirly.github.io/Git.assets/image-20230702170338573.png" alt="image-20230702170338573"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>欢迎</title>
      <link href="/Shirly.github.io/2023/03/28/%E6%AC%A2%E8%BF%8E/"/>
      <url>/Shirly.github.io/2023/03/28/%E6%AC%A2%E8%BF%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="一些简单的介绍和说明"><a href="#一些简单的介绍和说明" class="headerlink" title="一些简单的介绍和说明:"></a>一些简单的介绍和说明:</h1><p>首先感谢你访问我的博客😁，<br>当前博客的构建还只是一个雏形，未来可能会更新一些日常和我变成遇到的一些问题的文档。<br>做这个博客的初衷呢，主要是最近后端的学习一直摆烂，Spring boot视频里的原码看的我头秃！但我除了做笔记啥也干不了，严重消磨了我的热情，但是碍于前端知识的匮乏，不想花太长时间做一个页面，却又急于想要出一个东西，于是就做了这个博客。<br>（还有，github抽风是真的很讨厌！！！）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;测试代码&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
