<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>智能 BI 项目实现记录 | 摸鱼的老方</title><meta name="author" content="老方"><meta name="copyright" content="老方"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一个利用 AI 生成实现的自动生成图标和分析项目">
<meta property="og:type" content="article">
<meta property="og:title" content="智能 BI 项目实现记录">
<meta property="og:url" content="https://fangmoyu.github.io/2024/03/04/%E5%B0%8F%E6%96%B9%E7%9A%84%E9%A1%B9%E7%9B%AE/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE/index.html">
<meta property="og:site_name" content="摸鱼的老方">
<meta property="og:description" content="一个利用 AI 生成实现的自动生成图标和分析项目">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fangmoyu.github.io/image/4.png">
<meta property="article:published_time" content="2024-03-04T01:12:31.966Z">
<meta property="article:modified_time" content="2024-03-04T01:47:41.362Z">
<meta property="article:author" content="老方">
<meta property="article:tag" content="博客，老方">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fangmoyu.github.io/image/4.png"><link rel="shortcut icon" href="/Shirly.github.io/img/favicon.png"><link rel="canonical" href="https://fangmoyu.github.io/2024/03/04/%E5%B0%8F%E6%96%B9%E7%9A%84%E9%A1%B9%E7%9B%AE/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/Shirly.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/Shirly.github.io/',
  algolia: undefined,
  localSearch: {"path":"/Shirly.github.io/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":50},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 老方","link":"链接: ","source":"来源: 摸鱼的老方","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '智能 BI 项目实现记录',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-04 09:47:41'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="./css/bgCSS.css"><link rel="stylesheet" href="./css/transpancy.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/Shirly.github.io/./image/MyAvatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/Shirly.github.io/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/Shirly.github.io/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/Shirly.github.io/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/Shirly.github.io/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/Shirly.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 文档</span></a></div><div class="menus_item"><a class="site-page" href="/Shirly.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/Shirly.github.io/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/Shirly.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Shirly.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/Shirly.github.io/about/"><i class="fa-fw fa fa-th-list"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/Shirly.github.io/./image/4.png')"><nav id="nav"><span id="blog-info"><a href="/Shirly.github.io/" title="摸鱼的老方"><span class="site-name">摸鱼的老方</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/Shirly.github.io/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/Shirly.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 文档</span></a></div><div class="menus_item"><a class="site-page" href="/Shirly.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/Shirly.github.io/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/Shirly.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Shirly.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/Shirly.github.io/about/"><i class="fa-fw fa fa-th-list"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">智能 BI 项目实现记录</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-04T01:12:31.966Z" title="发表于 2024-03-04 09:12:31">2024-03-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-04T01:47:41.362Z" title="更新于 2024-03-04 09:47:41">2024-03-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="智能 BI 项目实现记录"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="智能-BI-项目"><a href="#智能-BI-项目" class="headerlink" title="智能 BI 项目"></a>智能 BI 项目</h1><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><h3 id="BI-平台是什么？"><a href="#BI-平台是什么？" class="headerlink" title="BI 平台是什么？"></a>BI 平台是什么？</h3><p>BI 商业智能：数据可视化、报表可视化系统</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240207195639888.png" alt="image-20240207195639888"></p>
<p>主流 BI 平台：帆软 BI 、小马 BI 、微软 Power BI </p>
<p>传统 BI 平台：<a target="_blank" rel="noopener" href="https://chartcube.alipay.com/">ChartCube - 在线图表制作工具 (alipay.com)</a></p>
<ol>
<li>需要人工上传数据</li>
<li>需要人工拖选分析要用到的数据行和列</li>
<li>需要人工选择图表类型</li>
</ol>
<p>智能 BI 平台：</p>
<p>区别于传统的 BI ，用户只需要导入最原始的数据集，输入想要进行分析的目标（比如分析一下网站的增长趋势），就能利用 AI 自动生成一个符合要求的图表以及结论</p>
<p>优点：让不会数据分析的同学也能输入目标快速完成数据分析，大幅节约人力成本。</p>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol>
<li>智能分析：用户输入目标和原始数据，可以自动生成图表和分析结论。</li>
<li>图表管理</li>
<li>图表生成的异步化（消息队列）</li>
</ol>
<h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p>客户端通过输入分析诉求、原始数据给业务后端，业务后端通过调用 AI 服务， AI 服务生成图表和分析结果发送给业务后端，处理用户数据，如果图表和分析结果需要被保存，则可以将其存储在数据库中。</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240210145736425.png" alt="image-20240210145736425"></p>
<p><strong>优化流程：</strong></p>
<p>但是要考虑一个情况，当前的用户量如果较大，都去调用 AI 生成报表，那么对于 AI 服务来说压力过大，AI 服务会不堪重负，这里通过一个消息队列，当用户发送一个请求，会先将请求发送到消息队列中，消息队列会实时判断 AI 服务的调用状态，如果 AI 服务的调用情况良好，它就会去调用任务处理模块来调用 AI 服务。</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240207203903342.png" alt="image-20240207203903342"></p>
<h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ol>
<li>React</li>
<li>Umi + Ant Design Pro</li>
<li>可视化库 （Echarts + HighCharts + AntV）</li>
<li>umi openapi 代码生成 （自动生成后端调用代码）</li>
</ol>
<h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><ol>
<li>Spring Boot (万用 Java 后端项目模版，快速搭建基础框架，避免重复写代码)</li>
<li>MySQL 数据库</li>
<li>Mybatis Plus 数据访问框架</li>
<li>消息队列 （RabbitMQ）</li>
<li>AI 能力 （ OpenAI 接口开发）</li>
<li>Excel 的上传和数据的解析</li>
<li>Swagger + Knife4j 项目接口文档</li>
<li>Hutools 工具库</li>
</ol>
<h2 id="项目计划"><a href="#项目计划" class="headerlink" title="项目计划"></a>项目计划</h2><p><strong>第一期</strong></p>
<p>前端项目初始化</p>
<p>后端项目初始化</p>
<p>前端开发</p>
<ul>
<li>快速开发登录功能</li>
<li>图表分析页面的开发</li>
<li>图表管理的开发</li>
</ul>
<p>后端开发</p>
<ul>
<li>库表设计</li>
<li>图表管理开发</li>
<li>文件上传接口开发</li>
</ul>
<p>前后端业务流程跑通。</p>
<h2 id="前端项目初始化"><a href="#前端项目初始化" class="headerlink" title="前端项目初始化"></a>前端项目初始化</h2><p>项目安装依赖过程中如果出现 node 版本不匹配的问题，可以通过直接去官网更新，或者采用：</p>
<p>nvm 可以自由切换 node 的版本。</p>
<ol>
<li>按照官方文档初始化</li>
<li>项目试运行</li>
<li>代码托管（方便还原）</li>
<li>移除不必要的能力 （比如国际化）</li>
</ol>
<h2 id="脚手架项目-bug-解决方案"><a href="#脚手架项目-bug-解决方案" class="headerlink" title="脚手架项目 bug 解决方案"></a>脚手架项目 bug 解决方案</h2><p>项目配置的 bug ，比如删除国际化的时候，报下图错误：</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240208103902221.png" alt="image-20240208103902221"></p>
<p>可以尝试去官方 github 下的 issue 下去查找解决方案：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ant-design/ant-design-pro">ant-design&#x2F;ant-design-pro: 👨🏻‍💻👩🏻‍💻 Use Ant Design like a Pro! (github.com)</a></p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240208104101917.png" alt="image-20240208104101917"></p>
<p>路由不显示名称：</p>
<p>要想让页面的导航栏显示要跳转的页面，可以给路由设置一个 name 属性。</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240208105459994.png" alt="image-20240208105459994"></p>
<h2 id="后端项目初始化"><a href="#后端项目初始化" class="headerlink" title="后端项目初始化"></a>后端项目初始化</h2><p>使用 Spring Boot 万用后端项目模版</p>
<h2 id="bug-解决"><a href="#bug-解决" class="headerlink" title="bug 解决"></a>bug 解决</h2><p>出现项目端口被占用的情况</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240208111348570.png" alt="image-20240208111348570"></p>
<p>可能是开启了 Hyper - V ，一个 Windows 10 上的虚拟机功能：</p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/virtualization/hyper-v-on-windows/about/">Windows 10 上的 Hyper-V 简介 | Microsoft Learn</a></p>
<h2 id="库表设计"><a href="#库表设计" class="headerlink" title="库表设计"></a>库表设计</h2><p><strong>图表表 ： chart</strong></p>
<p>id 采用雪花算法产生的随机 id </p>
<p>userId 创建图表的用户 id</p>
<p>goal ：分析目标 text</p>
<p>chartData ： 图标数据 text</p>
<p>chartType ： 图标类型</p>
<p>genChart ：text 生成的图标数据</p>
<p>genResult  text 生成的分析结论</p>
<p>createTime </p>
<p>updateTime</p>
<p>isDelete</p>
<p>用 @TableId 注解的属性 idType 来设置 id 字段的值为随机数，确保用户 id 的安全性：</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240208141332794.png" alt="image-20240208141332794"></p>
<p><a target="_blank" rel="noopener" href="https://baomidou.com/pages/223848/#idtype">注解 | MyBatis-Plus (baomidou.com)</a></p>
<h2 id="前端调用后端"><a href="#前端调用后端" class="headerlink" title="前端调用后端"></a>前端调用后端</h2><p>前端更改对应的请求路径地址：在 app.tsx 里修改 request. baseURL</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240208143821395.png" alt="image-20240208143821395"></p>
<h1 id="第二期"><a href="#第二期" class="headerlink" title="第二期"></a>第二期</h1><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ol>
<li>前置准备</li>
<li>开发登录、注册页面</li>
<li>学习使用 AI 生成 BI 图表的完整流程（梳理功能点和工作）</li>
<li>开发智能分析功能<ul>
<li>文件上传（前后端）</li>
<li>Excel 处理</li>
</ul>
</li>
<li>图表管理功能</li>
</ol>
<blockquote>
<p>项目的开发需要提前先写出项目的核心步骤、流程，便于后续的具体开发。</p>
</blockquote>
<h2 id="继续初始化项目"><a href="#继续初始化项目" class="headerlink" title="继续初始化项目"></a>继续初始化项目</h2><h3 id="后端启动项目端口冲突问题解决："><a href="#后端启动项目端口冲突问题解决：" class="headerlink" title="后端启动项目端口冲突问题解决："></a>后端启动项目端口冲突问题解决：</h3><p>原因： Windows Hyper-V 虚拟化平台占用了端口。</p>
<p><strong>方案一</strong></p>
<ol>
<li>查询哪些端口号被占用了：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface ipv4 show excludedportrange protocol=tcp</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>启动项目时，避开这些端口：</li>
</ol>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240208222009951.png" alt="image-20240208222009951"></p>
<p><strong>方案二</strong></p>
<p>禁用 Hype-V</p>
<h2 id="前端项目初始化-1"><a href="#前端项目初始化-1" class="headerlink" title="前端项目初始化"></a>前端项目初始化</h2><ol>
<li>修改端口</li>
<li>删除 mock 数据</li>
<li>修改 favicon.ico 替换 Logo，这个是网站上的图标，通过网上的在线 png 转 favicon.ico 转换器 ，你可以用自己的图片，去生成自己想要的 favicon.ico。</li>
<li>删除国际化 locales 目录</li>
<li>删除 test 测试相关目录</li>
<li>mainfest.json 文件是用来开发 app 的时候，指定不同的配置，可以删除。</li>
<li>prettier、eslint、editorConfig、stylelint ，想要开启 prettier 美化配置</li>
<li>替换标题名称 通过 ctrl + shift + r 全局替换所有的 Ant Design Pro 和 Ant Design 为 智能 BI</li>
</ol>
<h3 id="开发登录注册页面"><a href="#开发登录注册页面" class="headerlink" title="开发登录注册页面"></a>开发登录注册页面</h3><p>先删掉不需要的，再根据后端去做调整。</p>
<p>如果出现 Cookie 没有发送给后端，就按照之前两个项目的方法解决。</p>
<p>统一去 RequestConfig 下去做配置。</p>
<h3 id="智能分析业务开发"><a href="#智能分析业务开发" class="headerlink" title="智能分析业务开发"></a>智能分析业务开发</h3><h4 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h4><ol>
<li><p>用户输入</p>
<p>a . 分析目标</p>
<p>b . 上传原始数据 （excel）</p>
<p>c . 更精细化地控制图表，比如图表类型、图表名称等</p>
</li>
<li><p>后端校验</p>
<p>a . 校验用户的输入是否合法</p>
<p>b . 成本控制（次数统计和校验、鉴权）</p>
</li>
<li><p>把处理后的数据输入给 AI 模型 （调用 AI 接口）</p>
</li>
<li><p>图表信息、结论文本在前端进行展示</p>
</li>
</ol>
<h4 id="开发接口"><a href="#开发接口" class="headerlink" title="开发接口"></a>开发接口</h4><p>根据用户输入的文本和文件，最后返回图表信息和结论文本</p>
<p>给 chart 表补充 name 字段</p>
<h2 id="AI-提词小技巧"><a href="#AI-提词小技巧" class="headerlink" title="AI 提词小技巧"></a>AI 提词小技巧</h2><p><strong>原始数据压缩</strong></p>
<p>AI 接口普遍都有输入字数限制，尽可能压缩数据，能够允许多传一些数据。</p>
<p>如何向 AI 提词 ？</p>
<p>AI 提词技巧 1：<strong>持续输入，持续优化</strong></p>
<p>AI 提词技巧 2 ： <strong>数据压缩 <strong>（内容压缩：比如把很长的内容提取关键词，</strong>关键词也可以让 AI 来做</strong>。）</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240209234022920.png" alt="image-20240209234022920"></p>
<h2 id="文件上传请求"><a href="#文件上传请求" class="headerlink" title="文件上传请求"></a>文件上传请求</h2><p>利用 @RequestPart 去实现文件上传</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yhj198927/article/details/135750505?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-135750505-blog-79727061.235%5Ev43%5Epc_blog_bottom_relevance_base8&spm=1001.2101.3001.4242.1&utm_relevant_index=3">@RequestPart 和@RequestParam的区别_requestparam 和 requestpart-CSDN博客</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestPart(&quot;file&quot;)</span> MultipartFile</span><br></pre></td></tr></table></figure>

<p>用上述注解即可实现文件上传。</p>
<h2 id="EasyExcel-读取数据并按照顺序返回"><a href="#EasyExcel-读取数据并按照顺序返回" class="headerlink" title="EasyExcel 读取数据并按照顺序返回"></a>EasyExcel 读取数据并按照顺序返回</h2><p>EasyExcel 读取 Excel 文件返回的结果是一个 List ，而这个 List 中的元素是 Excel 文件中每一行的数据，我们可以通过 List.get( i ) 去获取第 i 行数据。</p>
<p>获取某一行的结果是一个 Map，它的键是从 0 开始的，一个键对应该行的一个单元格的值，并且如果 Excel 文件并未完全清理脏数据，可能会出现值为 null 的情况。 </p>
<p>而默认的 HashMap 是无序的，所以我们如果需要按照表格原来的顺序返回，就需要通过 LionkedHashMap 来实现：<img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240210102514007.png" alt="image-20240210102514007"></p>
<p><strong>过滤其中为空的值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">headerMap.values().stream().filter(ObjectUtils::isNotEmpty).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240210102802031.png" alt="image-20240210102802031"></p>
<h2 id="调用-AI"><a href="#调用-AI" class="headerlink" title="调用 AI"></a>调用 AI</h2><p>AI 需要一个预设，便于更加精准地得到我们需要的结果。</p>
<p>比如你去给一个调整了推荐歌曲预设的 ai 发送歌手，它就会根据这个歌手推荐他的歌曲，而如果你给其他的 ai 发送相同名字的歌手，那么 ai 可能返回的是歌手的信息：</p>
<p><strong>预设过的 ai：</strong></p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240210104333578.png" alt="image-20240210104333578"></p>
<p><strong>其他 ai：</strong></p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240210104320251.png" alt="image-20240210104320251"></p>
<p>输入：</p>
<p>系统预设（提前告诉它职责、功能、回复格式要求） + 分析目标 + 压缩后的数据</p>
<p>由于 openAi 是一个无状态的系统，如果需要保留之前发送的信息，需要将整个信息打包，一起发送给 openAI</p>
<p>最简单的系统预设：</p>
<ul>
<li>你是一个数据分析师，接下来我会给你我的分析目标和原始数据，请给我分析结论。</li>
</ul>
<p>可以从下图中看出来，没有预设下得出的结果是不一样的：</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240210104925032.png" alt="image-20240210104925032"></p>
<h2 id="启动后端模板"><a href="#启动后端模板" class="headerlink" title="启动后端模板"></a>启动后端模板</h2><p>使用鱼皮的新版后端模板：</p>
<p><a target="_blank" rel="noopener" href="https://wx.zsxq.com/dweb2/index/topic_detail/212528442245281">知识星球 | 深度连接铁杆粉丝，运营高品质社群，知识变现的工具 (zsxq.com)</a></p>
<p>配置相应的 Redis 和本地数据库信息之后，启动项目，访问项目接口文档地址：</p>
<p><a target="_blank" rel="noopener" href="http://localhost:8101/api/doc.html#/home">接口文档</a></p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240210182633582.png" alt="image-20240210182633582"></p>
<h3 id="后端项目模板学习"><a href="#后端项目模板学习" class="headerlink" title="后端项目模板学习"></a>后端项目模板学习</h3><p><strong>自定义注解</strong></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/364505627">自定义注解 详细解释以及使用 - 知乎 (zhihu.com)</a></p>
<p>通过自定义注解，实现用户必须满足某种角色才能访问</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span> <span class="comment">// 注解的范围</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 注解的生命周期</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AuthCheck &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 必须有某个角色</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">mustRole</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>利用 AOP 切面，让所有被加上了上述注解的方法都会执行下面的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行拦截</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> authCheck</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(authCheck)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">doInterceptor</span><span class="params">(ProceedingJoinPoint joinPoint, AuthCheck authCheck)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">mustRole</span> <span class="operator">=</span> authCheck.mustRole();</span><br><span class="line">        <span class="type">RequestAttributes</span> <span class="variable">requestAttributes</span> <span class="operator">=</span> RequestContextHolder.currentRequestAttributes();</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> ((ServletRequestAttributes) requestAttributes).getRequest();</span><br><span class="line">        <span class="comment">// 当前登录用户</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">loginUser</span> <span class="operator">=</span> userService.getLoginUser(request);</span><br><span class="line">        <span class="comment">// 必须有该权限才通过</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(mustRole)) &#123;</span><br><span class="line">            <span class="type">UserRoleEnum</span> <span class="variable">mustUserRoleEnum</span> <span class="operator">=</span> UserRoleEnum.getEnumByValue(mustRole);</span><br><span class="line">            <span class="keyword">if</span> (mustUserRoleEnum == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.NO_AUTH_ERROR);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">userRole</span> <span class="operator">=</span> loginUser.getUserRole();</span><br><span class="line">            <span class="comment">// 如果被封号，直接拒绝</span></span><br><span class="line">            <span class="keyword">if</span> (UserRoleEnum.BAN.equals(mustUserRoleEnum)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.NO_AUTH_ERROR);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 必须有管理员权限</span></span><br><span class="line">            <span class="keyword">if</span> (UserRoleEnum.ADMIN.equals(mustUserRoleEnum)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mustRole.equals(userRole)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.NO_AUTH_ERROR);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过权限校验，放行</span></span><br><span class="line">        <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p><strong>定义工具类方便开发</strong></p>
<p>之前的项目中需要校验条件抛出的异常很多，可以通过编写一个统一的抛出异常工具类来统一实现校验和执行抛出异常操作，让代码更加优雅。</p>
<p><strong>实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抛异常工具类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航知识星球&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThrowUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 条件成立则抛异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> condition</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> runtimeException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">throwIf</span><span class="params">(<span class="type">boolean</span> condition, RuntimeException runtimeException)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">            <span class="keyword">throw</span> runtimeException;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 条件成立则抛异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> condition</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> errorCode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">throwIf</span><span class="params">(<span class="type">boolean</span> condition, ErrorCode errorCode)</span> &#123;</span><br><span class="line">        throwIf(condition, <span class="keyword">new</span> <span class="title class_">BusinessException</span>(errorCode));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 条件成立则抛异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> condition</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> errorCode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">throwIf</span><span class="params">(<span class="type">boolean</span> condition, ErrorCode errorCode, String message)</span> &#123;</span><br><span class="line">        throwIf(condition, <span class="keyword">new</span> <span class="title class_">BusinessException</span>(errorCode, message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一旦目标为空，就直接抛出异常。无法根据空目标产生内容</span></span><br><span class="line">ThrowUtils.throwIf(StringUtils.isBlank(goal),ErrorCode.PARAMS_ERROR,<span class="string">&quot;目标为空&quot;</span>);</span><br><span class="line"><span class="comment">// 如果名称不为空，并且名称长度大于100，就抛出异常，并给出提示</span></span><br><span class="line">ThrowUtils.throwIf(StringUtils.isNotBlank(name) &amp;&amp; name.length() &gt; <span class="number">100</span>, ErrorCode.PARAMS_ERROR, <span class="string">&quot;名称过长&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>同理可以根据这种思路定义更多的工具类便于开发</p>
<h2 id="Excel-实现读取数据"><a href="#Excel-实现读取数据" class="headerlink" title="Excel 实现读取数据"></a>Excel 实现读取数据</h2><p><strong>同步读</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步读，不用写监听器</span></span><br><span class="line">List&lt;Map&lt;Integer, String&gt;&gt; list = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    list = EasyExcel.read(multipartFile.getInputStream())</span><br><span class="line">            .excelType(ExcelTypeEnum.XLSX)</span><br><span class="line">            .sheet()</span><br><span class="line">            .headRowNumber(<span class="number">0</span>)</span><br><span class="line">            .doReadSync();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;表格处理错误&quot;</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>读取表头以及真实数据：</p>
<p>利用 Stream 流，实现读取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取表头(第一行)</span></span><br><span class="line">LinkedHashMap&lt;Integer, String&gt; headerMap =(LinkedHashMap&lt;Integer, String&gt;) list.get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 过滤出其中不为空的内容</span></span><br><span class="line">List&lt;String&gt; headerList = headerMap.values().stream().filter(ObjectUtils::isNotEmpty).collect(Collectors.toList());</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">stringBuilder.append(StringUtils.join(headerList,<span class="string">&quot;,&quot;</span>)).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="comment">// 将真实数据过滤空值后输出。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">    Map&lt;Integer, String&gt; dataMap = list.get(i);</span><br><span class="line">    List&lt;String&gt; dataList = dataMap.values()</span><br><span class="line">            .stream()</span><br><span class="line">            .filter(ObjectUtils::isNotEmpty)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    stringBuilder.append(StringUtils.join(dataList,<span class="string">&quot;,&quot;</span>)).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="第三期"><a href="#第三期" class="headerlink" title="第三期"></a>第三期</h1><p>计划：</p>
<ol>
<li>跑通整个智能分析功能的业务流程<ol>
<li>后端</li>
<li>前端</li>
</ol>
</li>
<li>开发图表管理功能</li>
<li>系统优化</li>
</ol>
<h3 id="生成图表"><a href="#生成图表" class="headerlink" title="生成图表"></a><strong>生成图表</strong></h3><p>我们的期望是让 AI 生成图表，但是 AI 无法直接生成现成的图表，但是可以生成图表代码 &#x3D; &gt; 可以把代码利用前端的组件库（echarts）在网页进行展示。</p>
<h4 id="给-AI-添加新的描述"><a href="#给-AI-添加新的描述" class="headerlink" title="给 AI 添加新的描述"></a>给 AI 添加新的描述</h4><p>通过上述的思路，我们可以给 AI 更多的描述来实现生成图表代码，然后将生成的代码用于我们的前端页面，但是直接按照如下提问：</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240212215510016.png" alt="image-20240212215510016"></p>
<p>生成的结果：</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240212215702701.png" alt="image-20240212215702701"></p>
<h4 id="通过预设实现更加细致的回答"><a href="#通过预设实现更加细致的回答" class="headerlink" title="通过预设实现更加细致的回答"></a>通过预设实现更加细致的回答</h4><p>显然 ，AI 生成了一段整个网页的代码，这不能直接插入到我们的项目前端代码中。</p>
<p>我们需要更加细致的加入预设来让 AI 生成的结果符合要求：</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240212220013833.png" alt="image-20240212220013833"></p>
<p>我们可以对 AI 进行更加细致的<strong>系统预设</strong>，让它知道应该回答什么内容之后，我们只需要通过简洁的提问，它可以生成按照我们需要的内容：</p>
<h3 id="AI-提问技巧"><a href="#AI-提问技巧" class="headerlink" title="AI 提问技巧"></a>AI 提问技巧</h3><p>如果想让 AI 更好地理解我们的输出，给我们预期的、精确格式的输出，我们就需要严格控制咋们的提问词。</p>
<ul>
<li>使用系统预设</li>
<li>控制输入格式（让 AI 更精确地理解我们的需求）</li>
</ul>
<p>比如：</p>
<p>你是一个数据分析师和前端开发专家，接下来我会按照以下固定格式给你提供内容：</p>
<p>分析需求：</p>
<p>（数据分析的需求或者目标）</p>
<p>原始数据：</p>
<p>{csv 格式的原始数据，用 , 作为分隔符}</p>
<p>请根据以上内容，帮我分析数据分析结论和可视化图表代码</p>
<ul>
<li>控制输出格式（让 AI 按照我们预期的结果返回）</li>
</ul>
<p>咋们先来看一下前端 echarts 的实例代码：</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240212220915561.png" alt="image-20240212220915561"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">option = &#123;</span><br><span class="line">  <span class="attr">xAxis</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;category&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: [<span class="string">&#x27;Mon&#x27;</span>, <span class="string">&#x27;Tue&#x27;</span>, <span class="string">&#x27;Wed&#x27;</span>, <span class="string">&#x27;Thu&#x27;</span>, <span class="string">&#x27;Fri&#x27;</span>, <span class="string">&#x27;Sat&#x27;</span>, <span class="string">&#x27;Sun&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">yAxis</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;value&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">series</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">data</span>: [<span class="number">150</span>, <span class="number">230</span>, <span class="number">224</span>, <span class="number">218</span>, <span class="number">135</span>, <span class="number">147</span>, <span class="number">260</span>],</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;line&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>继续完善提问</strong></p>
<p>你是一个数据分析师和前端开发专家，接下来我会按照以下固定格式给你提供内容：</p>
<p>分析需求：</p>
<p>（数据分析的需求或者目标）</p>
<p>原始数据：</p>
<p>{csv 格式的原始数据，用 , 作为分隔符}</p>
<p>请根据以上内容，帮我按照指定格式生成内容（此外不要输出多余的开头、结尾、注释等内容）</p>
<p>【【【【【</p>
<p>{前端 Echarts V5 的 option 配置对象 js 代码，合理地将数据进行可视化}</p>
<p>【【【【【</p>
<p>{图表的描述，以及明确的数据分析结论、越详细越好}</p>
<p>通过上述的提示词， AI 就会按照我们的格式返回结果了，但是也可能存在一些随机性，不一定绝对能按照我们的需要返回，如果仍然存在随机性，那么我们就需要更多地去优化提示词。</p>
<ul>
<li>直接指定一个示例回答，one-shot 或者 few-shot</li>
</ul>
<h3 id="Java三种调用-AI-的方式"><a href="#Java三种调用-AI-的方式" class="headerlink" title="Java三种调用 AI 的方式"></a>Java三种调用 AI 的方式</h3><ol>
<li>直接调用 OpenAI 或者其他 AI 原始大模型官网接口</li>
</ol>
<p>官网：</p>
<p><a target="_blank" rel="noopener" href="https://platform.openai.com/docs/guides/text-generation/chat-completions-api">文本生成 - OpenAI API</a></p>
<p>优点：不经封装、最灵活、最原始</p>
<p>缺点：要钱、要魔法</p>
<h4 id="通过发送-HTTP-请求调用"><a href="#通过发送-HTTP-请求调用" class="headerlink" title="通过发送 HTTP 请求调用"></a>通过发送 HTTP 请求调用</h4><p>本质上 OpenAI 就是提供了 HTTP 接口，我们可以用任何语言去调用。</p>
<p>看官方文档的 curl 语言实现， curl 是一个用于请求 Web 服务器的命令行工具。</p>
<p><a target="_blank" rel="noopener" href="https://platform.openai.com/docs/quickstart?context=curl">Text generation - OpenAI API</a></p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240212223855563.png" alt="image-20240212223855563"></p>
<p>可以看到，要调用 AI 只需要调用下图的地址，并在请求头中加入用户的密钥 API KEY，然后按照下图的请求体发送内容：</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240212223918833.png" alt="image-20240212223918833"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">curl https://api.openai.com/v1/chat/completions   -H &quot;Content-Type: application/json&quot;   -H &quot;Authorization: Bearer $OPENAI_API_KEY&quot;   -d &#x27;&#123;</span><br><span class="line">    &quot;model&quot;: &quot;gpt-3.5-turbo&quot;,</span><br><span class="line">    &quot;messages&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;role&quot;: &quot;system&quot;,</span><br><span class="line">        &quot;content&quot;: &quot;You are a poetic assistant, skilled in explaining complex programming concepts with creative flair.&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;role&quot;: &quot;user&quot;,</span><br><span class="line">        &quot;content&quot;: &quot;Compose a poem that explains the concept of recursion in programming.&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;&#x27;</span><br></pre></td></tr></table></figure>



<ol>
<li>在请求头中指定 OPENAI_API_KEY</li>
<li>找到你需要的 OpenAI 接口</li>
<li>使用 Java 的 HTTP 请求调用库去调用 OpenAI 的接口</li>
</ol>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240212224343475.png" alt="image-20240212224343475"></p>
<h4 id="2-使用云服务商提供的、封装后的-AI-接口"><a href="#2-使用云服务商提供的、封装后的-AI-接口" class="headerlink" title="2. 使用云服务商提供的、封装后的 AI 接口"></a>2. 使用云服务商提供的、封装后的 AI 接口</h4><p>比如 Azure 云</p>
<p>优点：本地都能用</p>
<p>缺点：依然要钱，而且可能比之前调用原始的接口更贵</p>
<h4 id="3-利用鱼聪明-AI-提供的开发-SDK"><a href="#3-利用鱼聪明-AI-提供的开发-SDK" class="headerlink" title="3. 利用鱼聪明 AI 提供的开发 SDK"></a>3. 利用鱼聪明 AI 提供的开发 SDK</h4><blockquote>
<p>这里值得学习一下这个 SDK 实现，利用了 API 开放平台的功能去做的。</p>
</blockquote>
<p>优点：目前不要钱。而且有很多线程的模型（prompt 系统预设）给大家用</p>
<p>缺点：不完全灵活，但是可以定义自己的模型</p>
<p><strong>使用鱼聪明 SDK ：</strong></p>
<p>下载安装 maven 依赖</p>
<p><a target="_blank" rel="noopener" href="https://github.com/liyupi/yucongming-java-sdk">liyupi&#x2F;yucongming-java-sdk: 鱼聪明 AI 的 Java SDK，几行代码使用 AI 助手能力！ (github.com)</a></p>
<p>在 yml 配置文件中配置相应的 accessKey 和 SecretKey</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240214171602770.png" alt="image-20240214171602770"></p>
<p>选择鱼聪明上的某一个模型：</p>
<p>对应的模型 id 在链接上：</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240213192040888.png" alt="image-20240213192040888"></p>
<p>调用鱼聪明 ai java sdk 的方法，调用鱼聪明接口。</p>
<p>通过这种方式不需要自己提前在代码中去写相应的 prompt 去告诉 ai 需要返回的信息内容了。因为模型已经设定好了。</p>
<p>调用方法：</p>
<p><strong>初始化 YuCongMingClient 对象</strong></p>
<p>方法 1：自主 new 对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String accessKey = &quot;你的 accessKey&quot;;</span><br><span class="line">String secretKey = &quot;你的 secretKey&quot;;</span><br><span class="line">YuCongMingClient client = new YuCongMingClient(accessKey, secretKey);</span><br></pre></td></tr></table></figure>



<p>方法 2：通过配置注入对象</p>
<p>修改配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yuapi:</span><br><span class="line">  client:</span><br><span class="line">    access-key: 你的 access-key</span><br><span class="line">    secret-key: 你的 secret-key</span><br></pre></td></tr></table></figure>



<p>使用客户端对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Resource</span><br><span class="line">private YuCongMingClient client;</span><br></pre></td></tr></table></figure>



<h4 id="3、构造请求参数"><a href="#3、构造请求参数" class="headerlink" title="3、构造请求参数"></a>3、构造请求参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DevChatRequest devChatRequest = new DevChatRequest();</span><br><span class="line">devChatRequest.setModelId(1651468516836098050L);</span><br><span class="line">devChatRequest.setMessage(&quot;鱼皮&quot;);</span><br></pre></td></tr></table></figure>



<h4 id="4、获取响应结果"><a href="#4、获取响应结果" class="headerlink" title="4、获取响应结果"></a>4、获取响应结果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BaseResponse&lt;DevChatResponse&gt; response = client.doChat(devChatRequest);</span><br><span class="line">System.out.println(response.getData());</span><br></pre></td></tr></table></figure>



<h4 id="调用-AI-1"><a href="#调用-AI-1" class="headerlink" title="调用 AI"></a>调用 AI</h4><p>使用 SDK 调用鱼聪明的方法可以抽象成一个方法，因此可以选择新建一个类，用来编写一些调用 AI 接口的方法。</p>
<p>然后封装一个 AI <strong>返回结果 BiResponse</strong>，因为模型的返回结果已经被我们提前定义好了，因此不用担心 AI 会返回一些不符合条件的回答。</p>
<p>BiResponse 要有两个字段：</p>
<ol>
<li>genChart</li>
<li>genResult</li>
</ol>
<p>分别是生成的图表和生成的结果</p>
<p>用户会发送一些需求 goal 和 图表类型 chartType ，可以将其加入到用户输入的内容中来确保用户的输入得到正确的结果。</p>
<p>生成数据后，将对应的图表插入到数据库中：</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240213194905712.png" alt="image-20240213194905712"></p>
<h4 id="小插曲：研究鱼皮的鱼聪明-SDK"><a href="#小插曲：研究鱼皮的鱼聪明-SDK" class="headerlink" title="小插曲：研究鱼皮的鱼聪明 SDK"></a>小插曲：研究鱼皮的鱼聪明 SDK</h4><p>基本是和 API 项目类似的，先来看一下它的配置实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;yuapi.client&quot;)</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YuCongMingClientConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String accessKey;</span><br><span class="line">    <span class="keyword">private</span> String secretKey;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> YuCongMingClient <span class="title function_">yuApiClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">YuCongMingClient</span>(<span class="built_in">this</span>.accessKey, <span class="built_in">this</span>.secretKey);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>非常简单的配置实现，就是通过组件扫描和注解实现对 accessKey 和 secretKey 的配置，同时它会将一个 yuApiClient 对象存储在 IOC 容器中管理，并将用户在 yml 绑定的 accessKey 和 secretKey 作为属性绑定在这个对象中。</p>
<p>配置好之后，我们会通过调用 IOC 容器中的 yuCongMingClient 对象，调用其 doChat 方法来向鱼聪明 AI 发送请求。</p>
<p>这里我们来看一下这个 doChat 的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BaseResponse&lt;DevChatResponse&gt; <span class="title function_">doChat</span><span class="params">(DevChatRequest devChatRequest)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://www.yucongming.com/api/dev/chat&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSONUtil.toJsonStr(devChatRequest);</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> ((HttpRequest)HttpRequest.post(url).addHeaders(<span class="built_in">this</span>.getHeaderMap(json))).body(json).execute().body();</span><br><span class="line">    TypeReference&lt;BaseResponse&lt;DevChatResponse&gt;&gt; typeRef = <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;BaseResponse&lt;DevChatResponse&gt;&gt;() &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> (BaseResponse)JSONUtil.toBean(result, typeRef, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是一顿 HTTP 请求实现调用接口。</p>
<p>其对应的加密方法也是和 API 项目一样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, String&gt; <span class="title function_">getHeaderMap</span><span class="params">(String body)</span> &#123;</span><br><span class="line">    Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    hashMap.put(<span class="string">&quot;accessKey&quot;</span>, <span class="built_in">this</span>.accessKey);</span><br><span class="line">    hashMap.put(<span class="string">&quot;nonce&quot;</span>, RandomUtil.randomNumbers(<span class="number">4</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">encodedBody</span> <span class="operator">=</span> SecureUtil.md5(body);</span><br><span class="line">    hashMap.put(<span class="string">&quot;body&quot;</span>, encodedBody);</span><br><span class="line">    hashMap.put(<span class="string">&quot;timestamp&quot;</span>, String.valueOf(System.currentTimeMillis() / <span class="number">1000L</span>));</span><br><span class="line">    hashMap.put(<span class="string">&quot;sign&quot;</span>, SignUtils.genSign(encodedBody, <span class="built_in">this</span>.secretKey));</span><br><span class="line">    <span class="keyword">return</span> hashMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>DevChatRequest 对象的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DevChatRequest</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long modelId;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>需要确定一个 modelId ，即调用的模型 id，和用户的需求 message。</p>
<p>将该对象放入到 doChat 方法的参数中，即可对相应的模型进行对话</p>
<p>message 信息提供：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">分析需求：</span><br><span class="line">分析网站用户的增长情况</span><br><span class="line">原始数据：</span><br><span class="line">日期,用户数</span><br><span class="line">1号,10</span><br><span class="line">2号,20</span><br><span class="line">3号,30</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>返回结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">【【【【【</span><br><span class="line">&#123;</span><br><span class="line">  xAxis: &#123;</span><br><span class="line">    type: &#x27;category&#x27;,</span><br><span class="line">    data: [&#x27;1号&#x27;, &#x27;2号&#x27;, &#x27;3号&#x27;]</span><br><span class="line">  &#125;,</span><br><span class="line">  yAxis: &#123;</span><br><span class="line">    type: &#x27;value&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  series: [&#123;</span><br><span class="line">    data: [10, 20, 30],</span><br><span class="line">    type: &#x27;line&#x27;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br><span class="line">【【【【【</span><br><span class="line">根据数据分析可得出以下结论：</span><br><span class="line">1. 网站用户数在3天内逐渐增长。</span><br><span class="line">2. 用户增长速度较快，呈现线性增长趋势。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>得到生成的结果之后，可以通过<strong>分割字符串的方式</strong>来获取各个模块的内容。</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240214181235798.png" alt="image-20240214181235798"></p>
<h4 id="doChat-方法的请求和响应"><a href="#doChat-方法的请求和响应" class="headerlink" title="doChat 方法的请求和响应"></a>doChat 方法的请求和响应</h4><p>方法名：doChat</p>
<p>请求参数：</p>
<ul>
<li>modelId：使用的会话模型（助手）id</li>
<li>message：要发送的消息，不超过 1024 字</li>
</ul>
<p>响应结果：</p>
<ul>
<li>code：响应状态码</li>
<li>data：<ul>
<li>content：对话结果内容</li>
</ul>
</li>
<li>message：响应信息</li>
</ul>
<h2 id="智能接口实现"><a href="#智能接口实现" class="headerlink" title="智能接口实现"></a>智能接口实现</h2><ol>
<li>构造用户请求</li>
<li>调用鱼聪明 sdk，得到 AI 响应数据</li>
<li>从 AI 响应结果中，找到需要的信息</li>
<li>保存图表到数据库</li>
</ol>
<p>返回结果保存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BiResponse</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String genChart;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String genResult;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long chartId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>完整的后端请求 ai 生成图表方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件上传</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> multipartFile</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> genChartByAiRequest</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/gen&quot;)</span></span><br><span class="line"><span class="keyword">public</span> BaseResponse&lt;BiResponse&gt; <span class="title function_">uploadFile</span><span class="params">(<span class="meta">@RequestPart(&quot;file&quot;)</span> MultipartFile multipartFile,</span></span><br><span class="line"><span class="params">                                       GenChartByAiRequest genChartByAiRequest, HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="comment">// 只有登录了才能去调用接口</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">loginUser</span> <span class="operator">=</span> userService.getLoginUser(request);</span><br><span class="line">    <span class="type">String</span> <span class="variable">chartType</span> <span class="operator">=</span> genChartByAiRequest.getChartType();</span><br><span class="line">    <span class="type">String</span> <span class="variable">goal</span> <span class="operator">=</span> genChartByAiRequest.getGoal();</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> genChartByAiRequest.getName();</span><br><span class="line">    <span class="comment">// 一旦目标为空，就直接抛出异常。无法根据空目标产生内容</span></span><br><span class="line">    ThrowUtils.throwIf(StringUtils.isBlank(goal),ErrorCode.PARAMS_ERROR,<span class="string">&quot;目标为空&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果名称不为空，并且名称长度大于100，就抛出异常，并给出提示</span></span><br><span class="line">    ThrowUtils.throwIf(StringUtils.isNotBlank(name) &amp;&amp; name.length() &gt; <span class="number">100</span>, ErrorCode.PARAMS_ERROR, <span class="string">&quot;名称过长&quot;</span>);</span><br><span class="line">    <span class="comment">// 设计 message，将用户发送的信息向 ai 提问</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">userInput</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    userInput.append(<span class="string">&quot;分析需求:&quot;</span>).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">userGoal</span> <span class="operator">=</span> goal;</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotBlank(chartType))&#123;</span><br><span class="line">        userGoal += <span class="string">&quot;，请使用&quot;</span> + chartType;</span><br><span class="line">    &#125;</span><br><span class="line">    userInput.append(userGoal).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    userInput.append(<span class="string">&quot;原始数据:&quot;</span>).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">csvData</span> <span class="operator">=</span> ExcelUtils.excelToCsv(multipartFile);</span><br><span class="line">    ThrowUtils.throwIf(StringUtils.isBlank(csvData),ErrorCode.SYSTEM_ERROR,<span class="string">&quot;数据压缩失败&quot;</span>);</span><br><span class="line">    userInput.append(csvData).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 调用 Ai 接口,得到返回结果</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> aiManager.doChat(AiModelIdEnum.BI_MODEL_ID.getModelId(), userInput.toString());</span><br><span class="line">    <span class="comment">// 将返回结果进行分割赋值</span></span><br><span class="line">    String[] splits = result.split(<span class="string">&quot;【【【【【&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(splits.length &lt; <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.SYSTEM_ERROR,<span class="string">&quot;AI 生成错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">genChart</span> <span class="operator">=</span> splits[<span class="number">1</span>].trim();</span><br><span class="line">    <span class="type">String</span> <span class="variable">genResult</span> <span class="operator">=</span> splits[<span class="number">2</span>].trim();</span><br><span class="line">    <span class="comment">// 插入到数据库</span></span><br><span class="line">    <span class="type">Chart</span> <span class="variable">chart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chart</span>();</span><br><span class="line">    chart.setName(name);</span><br><span class="line">    chart.setGoal(goal);</span><br><span class="line">    chart.setChartData(csvData);</span><br><span class="line">    chart.setChartType(chartType);</span><br><span class="line">    chart.setGenChart(genChart);</span><br><span class="line">    chart.setGenResult(genResult);</span><br><span class="line">    chart.setUserId(loginUser.getId());</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">saveResult</span> <span class="operator">=</span> chartService.save(chart);</span><br><span class="line">    <span class="comment">// 校验插入是否成功</span></span><br><span class="line">    ThrowUtils.throwIf(!saveResult,ErrorCode.SYSTEM_ERROR, <span class="string">&quot;图表保存失败&quot;</span>);</span><br><span class="line">    <span class="comment">// 将生成的结果返回给前端</span></span><br><span class="line">    <span class="type">BiResponse</span> <span class="variable">biResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BiResponse</span>();</span><br><span class="line">    biResponse.setGenChart(genChart);</span><br><span class="line">    biResponse.setGenResult(genResult);</span><br><span class="line">    <span class="keyword">return</span> ResultUtils.success(biResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>利用 Swagger 发送请求得到返回结果：</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240214184050115.png" alt="image-20240214184050115"></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;genChart&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;\n  xAxis: &#123;\n    type: &#x27;category&#x27;,\n    data: [&#x27;1号&#x27;, &#x27;2号&#x27;, &#x27;3号&#x27;]\n  &#125;,\n  yAxis: &#123;\n    type: &#x27;value&#x27;\n  &#125;,\n  series: [&#123;\n    data: [10, 20, 30],\n    type: &#x27;bar&#x27;\n  &#125;]\n&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;genResult&quot;</span><span class="punctuation">:</span> <span class="string">&quot;根据提供的数据，可以看出网站的用户数在过去三天呈现逐渐增长的趋势。具体分析如下：\n- 1号当天，网站的用户数为10人。\n- 2号当天，网站的用户数较前一天增加了10人，达到20人。\n- 3号当天，网站的用户数较前一天增加了10人，达到30人。\n因此，可以看出网站的用户数在过去三天内保持了一个较为稳定的增长趋势。&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;chartId&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ok&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<p>前端只需要将其中的 genChart 放到 echarts 的代码块中，并把 genResult 给展示出来即可。</p>
<h2 id="前端智能生成页面开发"><a href="#前端智能生成页面开发" class="headerlink" title="前端智能生成页面开发"></a>前端智能生成页面开发</h2><ol>
<li>通过表单组件来实现用户数据填写和发送请求（调用 oneAPI 接口，注意封装的文件上传请求体，要找到最原始的文件上传内容。）</li>
<li>展示 AI 生成结果页面，通过接收 AI 生成的返回代码和生成的描述内容，代码将其转成 Json 显示： Json.parse(chartCode);</li>
</ol>
<h4 id="前端发送请求时的展开语法…"><a href="#前端发送请求时的展开语法…" class="headerlink" title="前端发送请求时的展开语法…"></a>前端发送请求时的展开语法…</h4><p>在鱼皮哥的前端代码中，传值时常会直接使用 … 变量的形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const params = &#123;</span><br><span class="line">      ...values,</span><br><span class="line">      file:undefined</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这是 JS 的一个展开运算符，可以将一个可迭代对象（如数组，对象）拆分成单独的值。让它可以方便地在其他地方引用这些值。</p>
<p>对于对象，<code>...values</code> 操作符会将对象 <code>values</code> 中的所有属性展开，以便可以将这些属性直接插入到另一个对象中。这样做可以简化代码，避免重复编写属性。</p>
<p>例如，假设有一个对象 <code>values</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVASCRIPT复制const values = &#123;   name: &#x27;Alice&#x27;,  age: 30 &#125;; </span><br></pre></td></tr></table></figure>

<p>如果我们需要创建另一个对象，并将 <code>values</code> 对象中的属性复制到这个新对象中，可以使用展开语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVASCRIPT复制const newObject = &#123;  ...values,  address: &#x27;123 Main St&#x27; &#125;; </span><br></pre></td></tr></table></figure>

<p>在这里，<code>...values</code> 将会将 <code>values</code> 对象中的 <code>name</code> 和 <code>age</code> 属性展开，然后将其复制到 <code>newObject</code> 中。最终，<code>newObject</code> 将包含 <code>name</code>、<code>age</code> 和 <code>address</code> 三个属性。</p>
<p>这就回答了为什么我们调用 ai 生成接口时，对于 body 的参数，可以直接将 …values 传入了。</p>
<h3 id="前端-onFinish-实现"><a href="#前端-onFinish-实现" class="headerlink" title="前端 onFinish 实现"></a>前端 onFinish 实现</h3><p>前端代码中，核心的实现就是这个 onFinish，它调用了后端的 gen 接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">const onFinish = async (values: any) =&gt; &#123;</span><br><span class="line">    // 如果已经是提交中的状态，直接返回，避免重复提交</span><br><span class="line">    if(submitting)&#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    setSubmitting(true);</span><br><span class="line">    // 第一个参数需要一个完整对象</span><br><span class="line">    const params = &#123;</span><br><span class="line">      ...values,</span><br><span class="line">      file:undefined</span><br><span class="line">    &#125;</span><br><span class="line">    // 将请求发送包裹在一个 try - catch 块中，当请求发生异常时，给用户一个默认的响应</span><br><span class="line">    try&#123;</span><br><span class="line">      // 发送请求</span><br><span class="line">      const res = await</span><br><span class="line">        genChartByAiUsingPost(params,&#123;&#125;,values.file.file.originFileObj);</span><br><span class="line">      if(!res?.data)&#123;</span><br><span class="line">        message.error(&quot;分析失败&quot;);</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        message.success(&quot;分析成功&quot;);</span><br><span class="line">        // 将返回的 genChart 转成 JSON 类型</span><br><span class="line">        console.log(res.data.genChart);</span><br><span class="line">        const chartOption = JSON.parse(res.data.genChart ?? &#x27;&#x27;);</span><br><span class="line">        // 如果为空，则抛出异常，并提示:&quot;图表代码解析错误&quot;</span><br><span class="line">        if(!chartOption)&#123;</span><br><span class="line">          throw new Error(&quot;图表代码解析错误&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">          setChart(res.data);</span><br><span class="line">          setOption(chartOption);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (e: any)&#123;</span><br><span class="line">      message.error(&quot;分析失败&quot; + e.message);</span><br><span class="line">    &#125;</span><br><span class="line">    setSubmitting(false);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>该 onFinish 调用时，有一个容易出现的 bug：<br>我们返回的代码并不是 json 格式的，而调用</p>
<p> <code>JSON.parse(res.data.genChart ?? &#39;&#39;);</code></p>
<p>时，会出现 JSON 转换错误。</p>
<p>我们需要给 AI 充足的预设，保证让它能够返回 JSON 格式的字符串，这样才能被方法解析。</p>
<p>当然，这种调试 AI 的方法不够稳定，需要反复测试直到确保稳定才能供于直接使用。</p>
<h2 id="本章思考"><a href="#本章思考" class="headerlink" title="本章思考"></a>本章思考</h2><ol>
<li>现在的网站足够安全吗？ （不够安全，接口没有做限制，可能会被刷量，或者大文件上传导致数据库存储过大字符串）<ol>
<li>如果用户上传一个超大的文件怎么办？ （分批次，将大文件分成多个小文件上传，在内存中去拼接字符串）</li>
<li>如果用户用科技疯狂点击生成提交，怎么办？(做限流)</li>
<li>如果 AI 的生成太慢，又有很多用户要同时生成，给系统造成了很大的压力，怎么兼顾用户体验和系统的可用性？（分布式？）</li>
</ol>
</li>
</ol>
<h1 id="第四期"><a href="#第四期" class="headerlink" title="第四期"></a>第四期</h1><h2 id="计划-1"><a href="#计划-1" class="headerlink" title="计划"></a>计划</h2><ol>
<li>开发图表管理功能</li>
<li><strong>优化系统</strong></li>
</ol>
<p>开发图表管理功能(CRUD)</p>
<p>后端：复用之前写好的 增删改查 代码。核心：获取个人创建的图表列表 listMyChartByPage</p>
<p>前端：</p>
<ol>
<li>开发一个列表页</li>
<li>支持按照图表名称搜索</li>
</ol>
<p>步骤：</p>
<ol>
<li>创建路由和页面</li>
<li>获取需要的数据，定义 state 变量来存储数据，用于给页面展示</li>
<li>先用最简单的格式显示数据，再去慢慢调样式</li>
<li>引入 Ant Design 的 list 组件，复制示例代码，调整数据。</li>
<li>针对样式，对数据做一些处理，比如统一图表自身的 title</li>
<li>增加分页</li>
<li>增加搜索框</li>
<li>其他优化： 比如 loading 效果</li>
</ol>
<p>小知识：</p>
<ol>
<li><p>原子化 CSS</p>
</li>
<li><p>利用 F12 控制台进行弱网测试</p>
</li>
</ol>
<p>拓展：</p>
<ol>
<li>支持查看原始数据</li>
<li>支持跳转到图表编辑页，去编辑图表</li>
</ol>
<h2 id="前端部分表示"><a href="#前端部分表示" class="headerlink" title="前端部分表示"></a>前端部分表示</h2><p><strong>取出登录用户信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const &#123; setInitialState &#125; = useModel(&#x27;@@initialState&#x27;);</span><br><span class="line">const &#123; currentUser &#125; = initialState ?? &#123;&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="系统优化（重点，分库分表思想、限流思路）"><a href="#系统优化（重点，分库分表思想、限流思路）" class="headerlink" title="系统优化（重点，分库分表思想、限流思路）"></a>系统优化（重点，分库分表思想、限流思路）</h2><p>现在的网站足够安全吗？ （不够安全，接口没有做限制，可能会被刷量，或者大文件上传导致数据库存储过大字符串）</p>
<ol>
<li>如果用户上传一个超大的文件怎么办？ （分批次，将大文件分成多个小文件上传，在内存中去拼接字符串）</li>
<li>如果用户用科技疯狂点击生成提交，怎么办？(做限流)</li>
<li>如果 AI 的生成太慢，又有很多用户要同时生成，给系统造成了很大的压力，怎么兼顾用户体验和系统的可用性？（分布式？）</li>
</ol>
<p><strong>只要涉及到用户自主上传的操作，一定要校验文件</strong></p>
<ul>
<li>文件的大小</li>
<li>文件的后缀</li>
<li>文件的内容</li>
<li>文件的合规性 （比如敏感内容）</li>
</ul>
<p><strong>文件的大小限制</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multipartFile.getSize();</span><br></pre></td></tr></table></figure>

<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240215091801590.png" alt="image-20240215091801590"></p>
<p><strong>文件的后缀限制</strong></p>
<p>获取文件名，利用 hutool 工具去对后缀做判断。</p>
<p>扩展点：接入腾讯云的图片万象数据审核（COS 对象存储的审核功能）</p>
<h3 id="todo-自主拓展"><a href="#todo-自主拓展" class="headerlink" title="todo 自主拓展"></a>todo 自主拓展</h3><p><strong>数据存储</strong></p>
<p>问题：</p>
<ol>
<li>我们把每个图表的原始数据全部存放在了同一个数据表（chart 表） 的字段里，如果用户上传的原始数据量很大、图标数日益增多，查询 Chart 表就会很慢。</li>
<li>对于一个 BI 平台，用户对于原始数据有一些简单查询的需求。现在如果把所有数据存放在一个字段中，查询时，只能把整个字段查出来然后通过代码去做过滤。</li>
</ol>
<p>解决方案：</p>
<p><strong>分开存储：</strong></p>
<p>把每个图表对应的原始数据单独保存为一个新的数据表 ：</p>
<p>比如 id &#x3D; 1 的图表，将其属性单独保存一个新的表：</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240215094248584.png" alt="image-20240215093432519"></p>
<p>通过这种方式，可以让用户在查询自己的数据（查的是数据，因为只查自己的数据，所以只需要走 chart 表的 id 和 userId,不需要走chartData）时，<strong>不会被其他用户上传的大文件所影响。</strong></p>
<p>我们利用查询到的图表 id ，再去查询相应 chart_ id 表中数据，即可给用户返回原始数据。而且也避免了 chartData 数据量大的问题，在 chart 表中就不需要这个字段了。</p>
<blockquote>
<p>在数据库查询时，如果只查询某一行的某列，而其他列的数据量非常大（比如 100GB），一般情况下不会直接影响到查询效率。数据库系统通常会优化查询，只返回您需要的列数据，而不会在内存中加载其他列数据。</p>
<p>数据库系统通常会使用索引来快速定位到需要查询的行，然后只检索您指定的列数据，而不会加载整行的所有列数据。这种优化可以有效地减少查询时间和内存消耗。</p>
</blockquote>
<p>优点：</p>
<ol>
<li>将原始数据和图表信息分离开，避免部分用户上传大文件造成整个数据库查询效率降低</li>
<li>原始数据单独存储，对于用户需要查询原始数据的需求，可以更轻松地满足，无需在代码层面上对原始数据字符串做分割。也更方便实现对用户查询条件。</li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>分开存储：</strong></p>
<p>存储图表信息时，不把数据存储为 chart 表的字段，而是新建一个 chart_{图表 id} 的数据表（利用动态 SQL 实现）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> chart_&#123;id&#125;</span><br><span class="line">&#123;</span><br><span class="line">	日期 <span class="type">varchar</span> <span class="keyword">null</span>,</span><br><span class="line">    用户数 <span class="type">int</span> <span class="keyword">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的日期和用户数，我的思路是获取表头之后，通过字符串分割的方式获取（每个字段的类型可以通过 apache POI 的类型判断实现），然后通过循环的方式传入 。</p>
<p><strong>分开查询：</strong></p>
<ol>
<li>以前直接查询图表，取 chartData 字段，现在改为读取 chart_{图表 id} 的数据表：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> chart_&#123;id&#125;</span><br></pre></td></tr></table></figure>



<p>由于用户的原始数据互不相同，创建的数据表也各不相同，因此不能写死 SQL 语句查询。需要使用 Mybatis 的动态 SQL。</p>
<p>如果要实现最自由的动态 SQL ，可以按照下面的思路实现：</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240215102507502.png" alt="image-20240215102507502"></p>
<p>但是太过自由也会有问题，这个实现要防止造成 SQL 注入问题。</p>
<p>解决 SQL 注入的方案：</p>
<ol>
<li><p><strong>在业务层写逻辑代码校验</strong></p>
</li>
<li><p>通过完善上述的 SQL 语句，限制用户使用 SQL 的自由度。</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  </span></span><br><span class="line"><span class="comment">queryChartData唯一标识符;parameterType查询语句的参数类型,类型为字符串;</span></span><br><span class="line"><span class="comment">resultType查询结果的返回类型,类型为map类型;</span></span><br><span class="line"><span class="comment">$&#123;querySql&#125;是SQL查询语句的占位符;</span></span><br><span class="line"><span class="comment">select * from chart_#&#123;chartId&#125; 不够灵活,$&#123;querySql&#125;是最灵活的方式，</span></span><br><span class="line"><span class="comment">就是把sql语句完全交给程序去传递，有一定的风险;</span></span><br><span class="line"><span class="comment">一旦使用$符号，就有sql注入的风险。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryChartData&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">  $&#123;querySql&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">可以在程序里面去做校验。只要保证这个SQL是通过你的后端生成的，</span></span><br><span class="line"><span class="comment">在生成的过程中做了校验，就不会有这种漏洞的风险。 </span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChartMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Chart&gt; &#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 方法的返回类型是 List&lt;Map&lt;String, Object&gt;&gt;,</span></span><br><span class="line"><span class="comment">    * 表示返回的是一个由多个 map 组成的集合,每个map代表了一行查询结果，</span></span><br><span class="line"><span class="comment">    * 并将其封装成了一组键值对形式的对象。其中,String类型代表了键的类型为字符串，</span></span><br><span class="line"><span class="comment">    * Object 类型代表了值的类型为任意对象,使得这个方法可以适应不同类型的数据查询。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">queryChartData</span><span class="params">(String querySql)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>水平分表：将同一个表中的不同行分到不同的表中，例如每一万行分一张表。</p>
<p>垂直分表：将同一个表中的某列分到不同的表中，就如我们上面的项目的思路。可以考虑用在某一列存储的数据可以再分，或者存储量过大的情况。</p>
<p>垂直分库：将同一个表中的不同列分到不同的数据库中。</p>
<p>水平分库：相当于把数据库水平切割，原来一个表中的数据可能会分配到不同的数据库中，这就是水平分库。</p>
<blockquote>
<p>咋们的项目上面的思路叫做<strong>垂直分表</strong></p>
</blockquote>
<p><strong>水平分表的优点：</strong></p>
<ul>
<li>单个表的数据量减少，查询效率提高。</li>
<li>可以通过增加节点，提高系统的扩展性和容错性。</li>
</ul>
<p><strong>水平分表的缺点：</strong></p>
<ul>
<li>事务并发处理复杂度增加，需要增加分布式事务的管理，性能和复杂度都有所牺牲。</li>
<li>跨节点查询困难，需要设计跨节点的查询模块。</li>
</ul>
<p>2 <strong>垂直分库</strong>（Vertical Partitioning） 垂直分库，指的是根据业务模块的不同，将不同的字段或表分到不同的数据库中。垂直分库基于数</p>
<p>据库内核支持，对应用透明，无需额外的开发代码，易于维护升级。</p>
<p><strong>垂直分库的优点：</strong></p>
<ul>
<li>减少单个数据库的数据量，提高系统的查询效率。</li>
<li>增加了系统的可扩展性，比水平分表更容易实现。</li>
</ul>
<p><strong>垂直分库的缺点：</strong></p>
<ul>
<li>不同数据库之间的维护和同步成本较高。</li>
<li>现有系统的改造存在一定的难度。</li>
<li>系统的性能会受到数据库之间互相影响的影响。</li>
</ul>
<h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p><strong>涉及到收费，销量的服务，一定要做限流！！！</strong></p>
<p>现在的问题：使用系统是需要消耗成本的，所以<strong>用户有可能疯狂刷量，让你破产</strong></p>
<p>解决问题：</p>
<ol>
<li>限制用户调用总次数，控制成本</li>
<li>用户在短时间内疯狂使用，导致服务器资源被占满，其他用户无法使用 &#x3D;&#x3D; 》 限流</li>
</ol>
<p>思考限流阈值多大合适？比如限制单个用户在每秒只能使用 1 次。</p>
<h3 id="限流的几种算法"><a href="#限流的几种算法" class="headerlink" title="限流的几种算法"></a>限流的几种算法</h3><p>参考文章：</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7209504489010430010">面试必备：四种经典限流算法讲解 - 掘金 (juejin.cn)</a></p>
<p><strong>1）固定窗口限流</strong></p>
<p>单位时间内允许部分操作：</p>
<p>比如 1 小时只允许 10 个用户操作</p>
<p>优点：实现最简单</p>
<p>缺点：可能出现流量突刺</p>
<p>比如：前 59 分钟没有一个操作，第 59 分钟来了 10 个操作， 第 1 小时 01 分钟又来了 10 个操作。相当于两分钟内执行了 20 个操作，服务器仍然有高峰危险。</p>
<p><strong>2）滑动窗口限流</strong></p>
<p>单位时间内允许部分操作，但是这个单位时间是滑动的，需要指定一个滑动单位</p>
<p>滑动单位 1 min</p>
<p>0s 1h 2h</p>
<p>一分钟后：</p>
<p>1 min 1h1min 2h2min</p>
<blockquote>
<p>啥意思呢？</p>
</blockquote>
<p> 就是解决上面固定窗口的问题的，我们将原本固定每 1 h 允许做 10 次操作，变成了每 1h 时间段允许做 10 次操作。 原本 59 分做的 10 个操作，下次只允许 59 分后 1h 才能在做 10 次操作。而不是固定的刷新。它是做完操作之后才开始计时 1h ，达到 1h 的时间了才会去让用户做操作。</p>
<p>优点：</p>
<p>解决上述流量突刺的问题，因为第 59 分时，限流窗口是 59 分 ~ 1 小时 59 分，这个时间段内只能接收 10 次请求，只要还在这个窗口内，更多的操作就会被拒绝。</p>
<p>缺点： 实现相对复杂，限流效果和你的滑动单位有关，滑动单位越小，限流效果越好，但往往很难选取到一个特别合适的滑动单位。</p>
<p><strong>3）漏桶限流</strong></p>
<p>以固定的速率处理请求，当请求桶满了后，拒绝请求。</p>
<p>比如：每秒处理 10 个请求，每 0.1 秒固定处理一次请求，如果 1 秒内来了 10 个请求，都可以处理，但如果 1 秒内来了 11 个请求，最后那个请求会被溢出桶，被拒绝。</p>
<p>优点：能够一定程度上应对流量突刺</p>
<p>缺点：没有办法迅速处理一批请求，只能一个一个按顺序处理。（固定速率的缺点，不支持并发）</p>
<p>4）令牌桶限流</p>
<p>管理员先生成一批令牌，每秒生成 10 个令牌；当用户要操作前，先去拿到一个令牌，有令牌的人就有资格执行操作、能够同时执行操作。拿不到令牌就等着</p>
<p>优点：能够并发处理同时的请求，并发性能会更高</p>
<p>需要考虑的问题：拿不到令牌的用户需要等到下次生成令牌时才能执行操作，存在时间单位选取的问题。（令牌的再次生成时间）</p>
<h3 id="限流的实现"><a href="#限流的实现" class="headerlink" title="限流的实现"></a>限流的实现</h3><ol>
<li><p>本地限流（单机限流）</p>
<p>每个服务器单独的限流，一般适用于单体项目</p>
<p><strong>Google Guava RateLimiter 库</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimiterDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 每秒最多允许2个请求通过</span></span><br><span class="line">        <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟多个请求</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rateLimiter.tryAcquire()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Request &quot;</span> + i + <span class="string">&quot; allowed at &quot;</span> + System.currentTimeMillis());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Request &quot;</span> + i + <span class="string">&quot; blocked at &quot;</span> + System.currentTimeMillis());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分布式限流（多机限流）</p>
</li>
</ol>
<p>如果项目有多个服务器，比如微服务，建议使用分布式限流。</p>
<p><strong>gateWay 实现限流</strong>（来源 GPT ）：</p>
<p>在 Spring Cloud 中，Spring Cloud Gateway 是一个基于 Spring Framework 5、Project Reactor 和 Spring Boot 2 的网关服务，提供了路由、过滤和限流等功能。Spring Cloud Gateway 可以方便地实现请求的路由、转发和过滤，同时也支持限流功能。</p>
<p>在 Spring Cloud Gateway 中，可以通过配置限流过滤器来实现限流功能。下面是一个简单的示例，演示如何在 Spring Cloud Gateway 中实现请求限流：</p>
<ol>
<li>首先，添加 Spring Cloud Gateway 的依赖到你的项目中。在 Maven 项目中，可以添加以下依赖：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 Spring Boot 应用的配置文件中，配置 Spring Cloud Gateway 的路由和限流规则。例如，下面是一个简单的配置示例：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">my_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://example.com</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/myroute</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">RequestRateLimiter</span></span><br><span class="line">              <span class="attr">args:</span></span><br><span class="line">                <span class="attr">key-resolver:</span> <span class="string">&quot;#&#123;@ipAddressKeyResolver&#125;&quot;</span></span><br><span class="line">                <span class="attr">redis-rate-limiter.replenishRate:</span> <span class="number">10</span></span><br><span class="line">                <span class="attr">redis-rate-limiter.burstCapacity:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>在上面的配置中，我们定义了一个名为 <code>my_route</code> 的路由，当请求路径为 <code>/myroute</code> 时，会应用限流过滤器 <code>RequestRateLimiter</code>。这个过滤器会使用 Redis 进行限流，限制请求每秒不超过 10 个，突发容量不超过 20 个。</p>
<ol start="3">
<li>创建限流 KeyResolver，用于从请求中提取限流的 key。例如，下面是一个提取 IP 地址作为 key 的 KeyResolver 实现：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.ratelimit.KeyResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IpAddressKeyResolver</span> <span class="keyword">implements</span> <span class="title class_">KeyResolver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;String&gt; <span class="title function_">resolve</span><span class="params">(ServerWebExchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Mono.just(exchange.getRequest().getRemoteAddress().getAddress().getHostAddress());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 Spring Boot 应用的配置类中注册 KeyResolver：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.ratelimit.KeyResolver;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimitConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> KeyResolver <span class="title function_">ipAddressKeyResolver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IpAddressKeyResolver</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上步骤，你就可以在 Spring Cloud Gateway 中实现基于 Redis 的请求限流功能。当用户请求 <code>/myroute</code> 路径时，限流过滤器会根据 IP 地址对请求进行限流。</p>
<h3 id="Redisson-限流实现"><a href="#Redisson-限流实现" class="headerlink" title="Redisson 限流实现"></a>Redisson 限流实现</h3><p>Redisson 内置了一个限流工具类，可以帮助你利用 Redis 实现限流功能。</p>
<blockquote>
<p>Redisson 限流操作是项目的一个通用能力，可以将其抽象出来作为一个能够在不同项目中复用的功能。</p>
</blockquote>
<p>可以在 Redisson 配置中读取原来 Redis 的配置，直接在上面加上 @ConfigurationProperties 标注 yml 的配置前缀即可。</p>
<p>但是这种方式不够规范，最好还是自己再写一个 Redisson 配置，然后引用。</p>
<p><strong>Redisson 配置</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;spring.redis&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer database;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// redisson 配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="comment">// 使用单机配置</span></span><br><span class="line">        config.useSingleServer()</span><br><span class="line">                <span class="comment">// 设置地址</span></span><br><span class="line">                .setAddress(<span class="string">&quot;redis://&quot;</span> + host + <span class="string">&quot;:&quot;</span> + port)</span><br><span class="line">                <span class="comment">// 设置密码</span></span><br><span class="line">                .setPassword(password)</span><br><span class="line">                <span class="comment">// 设置数据库</span></span><br><span class="line">                .setDatabase(database);</span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redissonClient</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line">        <span class="keyword">return</span> redissonClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Redisson 的代码参数被压缩过了，没有显示完整的参数名称：</p>
<p>没办法看懂参数含义，怎么办？</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240215151655363.png" alt="image-20240215151655363"></p>
<ol>
<li>看官方文档</li>
<li>下载源码（点击任意一个包里的代码，点击右上角的下载源码。）</li>
</ol>
<p>实现步骤：</p>
<ol>
<li>创建一个名称为 *** 的限流器（可以选择用 userId 来作为名称，这样就可以针对不同的用户做独立的限流。），每秒最多访问 2（实际情况自己选择） 次</li>
<li>每当一个操作来了后，请求一个令牌</li>
<li>一旦令牌为空，就抛出异常</li>
<li>如果获取到令牌，那么就正常执行后续逻辑</li>
</ol>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240215153435648.png" alt="image-20240215153435648"></p>
<p><strong>限流管理器实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redis 限流管理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisLimiterManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doRateLimit</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个名称为 key 的限流器，初始化时设置最大访问速率是 2 次/秒</span></span><br><span class="line">        <span class="type">RRateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> redissonClient.getRateLimiter(key);</span><br><span class="line">        rateLimiter.trySetRate(RateType.OVERALL, <span class="number">2</span>, <span class="number">1</span>, RateIntervalUnit.SECONDS);</span><br><span class="line">        <span class="comment">// 每当一个操作来了，就请求一个令牌</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">canOp</span> <span class="operator">=</span> rateLimiter.tryAcquire(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 如果拿不到令牌，就抛出异常</span></span><br><span class="line">        <span class="keyword">if</span>(!canOp)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.TOO_MANY_REQUEST);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>测试调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisLimiterManagerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisLimiterManager redisLimiterManager;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doRateLimit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">2</span> ;i++)&#123;</span><br><span class="line">            redisLimiterManager.doRateLimit(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">5</span> ;i++)&#123;</span><br><span class="line">            redisLimiterManager.doRateLimit(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="限流粒度"><a href="#限流粒度" class="headerlink" title="限流粒度"></a>限流粒度</h3><ol>
<li>针对某个方法限流，即单位时间内最多允许同时 XX 个操作使用这个方法</li>
<li>针对某个用户限流，即单位时间内最多允许用户使用 XX 个操作</li>
<li>针对某个用户的某个方法限流。比如单个用户单位时间内最多执行 X 个方法</li>
</ol>
<h1 id="第五期"><a href="#第五期" class="headerlink" title="第五期"></a>第五期</h1><h2 id="计划-2"><a href="#计划-2" class="headerlink" title="计划"></a>计划</h2><ol>
<li>系统优化 - 异步化</li>
<li>异步化思路</li>
<li>线程池理论和实战</li>
<li>前端后端的异步化改造</li>
</ol>
<h2 id="系统问题分析"><a href="#系统问题分析" class="headerlink" title="系统问题分析"></a>系统问题分析</h2><ol>
<li>用户等待时间有点长（要等 AI 生成）</li>
<li>业务服务器可能会有很多请求在处理，导致系统图资源紧张，严重时导致服务器宕机或者无法处理新的请求</li>
<li>调用第三方服务时（AI 服务） 的处理能力是有限的，比如每 3 秒只能处理 1 哥请求，如果请求很多，会导致 AI 处理不过来，严重时， AI 可能会对咋们的后台系统拒绝服务</li>
</ol>
<h2 id="异步化"><a href="#异步化" class="headerlink" title="异步化"></a>异步化</h2><p><strong>概念介绍</strong></p>
<p>同步：一件事情做完，再做另外一件事。</p>
<p>异步：不用等一件事做完，就可以做另外一件事情，等第一件事完成时，可以收到一个通知，告诉你这件事做好了，你可以再进行后续处理。</p>
<h3 id="业务流程分析"><a href="#业务流程分析" class="headerlink" title="业务流程分析"></a>业务流程分析</h3><p><strong>标准异步化的业务流程</strong></p>
<ol>
<li><p>当用户要进行耗时很长的操作时，点击提交后，不需要在界面傻等。而是应该把这个任务保存到数据库中记录下来</p>
</li>
<li><p>把用户执行的操作（任务）放到一个<strong>任务队列</strong>中，让程序（线程）从任务队列中取出任务去执行。</p>
<p><strong>任务队列没有满的情况：</strong></p>
<ol>
<li>如果我们的程序还有多余的空闲线程，可以立刻去做这个任务</li>
<li>如果我们的程序的线程都在繁忙，无法继续处理，那就放到等待队列里。</li>
</ol>
<p><strong>我们的所有线程都在忙，任务队列满了</strong>：</p>
<ol>
<li>拒绝掉这个任务，再也不去执行</li>
<li>通过保存到数据库中的记录来看到提交失败的任务，并且在程序闲的时候，可以把任务从数据库中捞到程序里，再去执行。</li>
</ol>
</li>
<li><p>我们的程序（线程） 从任务队列中取出任务依次执行，每完成一件事情就要修改一下任务的状态。</p>
</li>
<li><p>用户可以查询任务的执行状态，或者在任务执行成功或失败时能得到通知（发邮件、系统消息提示、短信），从而优化体验。</p>
</li>
<li><p>如果我们要执行的任务非常复杂，包含很多环节，在每一个小人物完成时，要在程序记录一下任务的执行状态。 （因为异步化是一个非常复杂的过程，容易出现问题，需要准确把握任务的执行情况。）</p>
</li>
</ol>
<h4 id="标准异步化的业务流程"><a href="#标准异步化的业务流程" class="headerlink" title="标准异步化的业务流程"></a>标准异步化的业务流程</h4><ol>
<li>用户点击智能分析页的提交按钮时，先把图表立即保存到数据库中（作为一个任务）</li>
<li>用户可以在图表管理页面查看所有图表（已生成的、生成中的、生成失败）的信息和状态。</li>
</ol>
<p>问题：</p>
<p>1.任务队列的最大容量应该设置成多少？</p>
<p>程序怎么从任务队列中取出任务去执行？这个任务的流程怎么实现？怎么保证程序最多同时执行多少个任务？</p>
<p>相当于有多个线程，同时去一个任务队列中去取出任务，然后执行。</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240216085257554.png" alt="image-20240216085257554"></p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>为什么需要线程池？</p>
<ol>
<li>线程的管理比较复杂（比如什么时候新增线程，什么时候减少空闲线程）</li>
<li>任务存取比较复杂（什么时候接受任务、什么时候拒绝任务）</li>
</ol>
<p><strong>线程池的实现</strong></p>
<ol>
<li>不用自己写，如果是 Spring 中，可以用 ThreadPoolTaskExecutor 配合 @Async 注解实现。（不太建议）</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zzhongcy/article/details/120487060">springboot之线程池ThreadPoolTaskExecutor以及@Async异步注解_springboot threadpooltaskexecutor-CSDN博客</a></p>
<ol start="2">
<li>如果是在 java 中，可以使用 JUC 并发变成包中的 ThreadPoolExecutor 来自由地实现线程池。</li>
</ol>
<h4 id="怎么确定线程池参数呢？"><a href="#怎么确定线程池参数呢？" class="headerlink" title="怎么确定线程池参数呢？"></a>怎么确定线程池参数呢？</h4><p><strong>结合实际情况（实际业务场景和系统资源）来测试调整，不断优化。</strong></p>
<p><strong>要考虑系统最脆弱的环节（系统的瓶颈） 在哪里？</strong></p>
<p>现有条件 ：比如 AI 生成能力的并发是只允许 4  个线程同时去执行。AI 能力允许 20 个任务排队。</p>
<p>corePoolSize （核心线程数 &#x3D;&gt; 正式员工数）：正常情况下，我们的系统应该能工作的线程数。</p>
<p>maximumPoolSize 设置为极限情况。（最大线程数 &#x3D; &gt; 哪怕任务再多，你也最多招这些人） ： 极限情况下，我们的线程池最多有多少个线程？</p>
<p>keepAliveTime（空闲线程存活时间）：非核心线程在没有任务的情况下，过多久要删除（理解为开除临时工）从而释放无用的线程资源。</p>
<p>TimeUnit （空现场存活时间的单位）：分钟、秒</p>
<p>workQueue（工作队列）：用于存放给线程执行的任务，存在一个队列的长度（一定要设置，不要说队列长度无限，因为也会占用资源） （结合实际情况去设置）</p>
<p>threadFactory（线程工厂）：控制每个线程的生成。</p>
<h4 id="线程池分配策略："><a href="#线程池分配策略：" class="headerlink" title="线程池分配策略："></a>线程池分配策略：</h4><p>一般情况下，任务分为 IO 密集型和计算密集型两种。</p>
<p><strong>计算密集型</strong>：吃 CPU， 比如音视频处理、图像处理、数学计算等，一般是设置 corePoolSize 为 CPU 的核心数 + 1 （空余线程），可以让每个线程都能利用好 CPU 的每个核，而且线程之间不用频繁切换（减少开销）</p>
<p><strong>IO 密集型：</strong> 吃宽带&#x2F;内存&#x2F;硬盘的读写资源，corePoolSize 可以设置大一点，一般是 2n 左右，但是建议以 IO 的能力为主。</p>
<h4 id="todo自主实现"><a href="#todo自主实现" class="headerlink" title="todo自主实现"></a>todo自主实现</h4><blockquote>
<p>资源隔离策略：比如重要的任务（VIP 任务）一个任务队列，普通任务一个任务队列，保证这两个队列互不干扰</p>
</blockquote>
<h3 id="线程池执行任务流程"><a href="#线程池执行任务流程" class="headerlink" title="线程池执行任务流程"></a>线程池执行任务流程</h3><p>开始时，一个任务和线程都没有。一旦来了一个任务，发现此时繁忙的线程还没有达到核心线程数目（ Threadnum &lt; corePoolSize ） ，直接让一个线程处理这个任务。</p>
<p>此时又来了一个任务，就再让一个线程去处理这个任务。后来又来了一个任务，但是此时当前线程数已经达到 corePoolSize ，此时任务放到队列里等待，而不是再加新线程。任务放到队列中等待。</p>
<p>一旦任务多到导致任务队列也满了，那么就突破 corePoolSize 限制，<strong>新增线程来处理新的任务（不是丢弃任务）</strong>，<strong>这些新增的线程执行的是新来的任务，而不是任务队列中的任务</strong>。直到线程数达到 maxmumPoolSize 。</p>
<p>线程数达到 maxmumPoolSize ，同时任务队列也满了，那么这个新任务就无法执行，那么就会调用拒绝策略来处理多余任务：RejectedExecutionHandler</p>
<p>如果当前线程数超过 corePoolSize (正式员工数) 有没有新的任务给它，那么等 keepAliveTime 时间达到后，就可以把这个线程释放。</p>
<p> 4.3 线程池的工作机制(时间点 01:14:42-01:25:26) </p>
<p>刚开始，没有任何的线程和任务：</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/1686143173765-d7c5a389-502e-4ab1-8f65-215ebf603a17.png" alt="img"></p>
<p>当有新任务进来，发现当前员工数量还未达到设定的正式员工数(corePoolSize &#x3D; 2)，则会直接增聘一名新员工来处理这个任务：</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/1686143402613-f0ecb859-fb26-423b-b47f-a3598c597419.png" alt="img"></p>
<p>又来一个新任务，发现当前员工数量还未达到设定的正式员工数(corePoolSize &#x3D; 2)，则会再次增聘一名新员工来处理这个任务：</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/1686143443206-1c6371ac-a334-4177-9049-64b13226c279.png" alt="img"></p>
<p>又来了一个新任务，但是正式员工数已经达到上限(当前线程数 &#x3D; corePoolSize &#x3D; 2)，这个新任务将被放到等待队列中(最大长度 workQueue.size 是 2) ，而不是立即增聘新员工：</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/1686143701965-02167f12-e7e0-4a86-99c9-a3dc575967af.png" alt="img"></p>
<p>又来了一个新任务，但是我们的任务队列已经满了(当前线程数 &gt; corePoolSize &#x3D; 2，已有任务数 &#x3D; 最大长度 workQueue.size &#x3D; 2)，我们将增设新线程(最大线程数 maximumPoolSize &#x3D; 4)来处理任务，而不是选择丢弃这个任务：</p>
<p>任务2</p>
<p>任务1</p>
<p>线程小李</p>
<p>任务4</p>
<p>大</p>
<p>任务3</p>
<p>任务队列(备忘录)</p>
<p>临时工小皮</p>
<p>线程小王</p>
<p>任务5</p>
<p>线程池(公司)</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/1686580374546-1930c16e-644c-41a6-ad89-bae7b1ebd8be.png" alt="image.png"></p>
<p>当达到七个任务时，由于我们的任务队列已经满了、临时工也招满了(当前线程数 &#x3D; maximumPoolSize &#x3D; 4，已有任务数 &#x3D; 最大长度 workQueue.size &#x3D; 2)，此时我们会采用 RejectedExecutionHandler(拒绝策略)来处理多余的任务：</p>
<p>任务1</p>
<p>任务2</p>
<p>临时工小A</p>
<p>任务7</p>
<p>线程小李</p>
<p>任务4</p>
<p>任务3</p>
<p>(拒绝)</p>
<p>任务队列(备忘录)</p>
<p>临时工小皮</p>
<p>线程小王</p>
<p>任务5</p>
<p>任务6</p>
<p>线程池(公司)</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/1686580389962-16ca277b-d6a9-4df8-93ec-8e7f23b7ec2d.png" alt="image.png"></p>
<p>如果当前线程数超过 corePoolSize (正式员工数)，并且这些额外的线程没有新的任务可执行，那么在 keepAliveTime 时间达到后，这些额外的线程将会被释放。</p>
<h3 id="线程池实现"><a href="#线程池实现" class="headerlink" title="线程池实现"></a>线程池实现</h3><ol>
<li>写一个线程池配置，放入到 IOC 容器中</li>
<li>在业务中使用 IOC 容器的线程池</li>
<li>编写测试接口调用线程执行任务（注意：<strong>这些接口不能暴露到生产环境，所以要加上 @Profile 注解，标注 dev 和 local 才生效</strong>）</li>
</ol>
<h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><p><strong>实现工作流程</strong></p>
<ol>
<li>给 chart 表新增任务状态字段（比如排队中、执行中、已完成、失败），任务执行信息字段（用于记录任务执行中、或者失败的一些信息）（因为 chart 表是通过 AI 调用之后才会完整填充一行，所以这里可以预先填写信息）</li>
<li>用户点击智能分析页的提交按钮时，先把图表立刻保存到数据库中，然后提交任务</li>
<li>任务：先修改图表任务状态为：“执行中”，等执行成功后，修改为 “已完成”、保存执行结果；执行筛败后，状态修改为 “失败”，记录任务失败信息。</li>
<li>用户可以在图表管理页面查看所有图表（已生成的、生产中的、生成失败）的信息和状态</li>
<li>用户可以修改生成失败的图表信息，点击重新生成。</li>
</ol>
<h3 id="编写和复用错误处理"><a href="#编写和复用错误处理" class="headerlink" title="编写和复用错误处理"></a>编写和复用错误处理</h3><p>对于很多个类似的处理异常情况：  </p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240216113539007.png" alt="image-20240216113539007"></p>
<p>可以编写一个通用的错误处理：</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240216113624315.png" alt="image-20240216113624315"></p>
<p>然后直接改成调用这个方法，而不是直接抛出异常。</p>
<p>这里的话就选择执行相应方法之后直接 return 返回。</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240216122317774.png" alt="image-20240216122317774"></p>
<p><strong>todo</strong></p>
<p>然后我们可以将错误的图表，通过重试机制再去生成图表，在限定重试次数内重试成功返回给用户，否则抛出异常。</p>
<h4 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h4><ol>
<li><p><strong>guava Retrying 重试机制</strong> 解决 AI 生成多余、错误内容时，重新生成</p>
</li>
<li><p>**如果说任务根本没提交到队列中（或者队列满了），是不是可以用个定时任务把它放到队列中 **(补偿机制)</p>
</li>
<li><p>建议给任务的执行添加一个<strong>超时时间，超时自动标记为失败</strong></p>
</li>
<li><p>提前考虑 AI 生成错误的情况，在后端进行异常处理</p>
</li>
<li><p>反向压力<a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1300384793457553408">编程干货 - 知乎 (zhihu.com)</a> 通过调用的服务状态来选择当前系统的策略（比如根据 AI 服务的当前任务队列数来控制咋们系统的核心线程数），<strong>从而最大化利用系统资源</strong></p>
</li>
<li><p>我的图表页面增加一个刷新、定时自动刷新的按钮，保证获取到图表的最新状态（前端轮询）</p>
</li>
<li><p>任务执行成功或失败，给用户发送实时消息通知（websocket、 server size event）</p>
</li>
</ol>
<h3 id="给用户发送发送实时消息的一个可行实现："><a href="#给用户发送发送实时消息的一个可行实现：" class="headerlink" title="给用户发送发送实时消息的一个可行实现："></a>给用户发送发送实时消息的一个可行实现：</h3><p>前端接收消息并提示给用户可以通过 WebSocket 实时通信来实现。以下是一个简单的示例代码，演示如何使用 JavaScript 和 WebSocket 接收来自后端的消息并在页面上展示给用户。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Real-time Notification<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;notification&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://localhost:8080/notification&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        socket.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket connection opened&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        socket.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> message = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(event.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">displayNotification</span>(message);</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">displayNotification</span>(<span class="params">message</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> notificationDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;notification&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> notificationMessage = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            notificationMessage.<span class="property">textContent</span> = message;</span></span><br><span class="line"><span class="language-javascript">            notificationDiv.<span class="title function_">appendChild</span>(notificationMessage);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，前端页面通过 WebSocket 连接到后端的 WebSocket 服务器（假设后端已经实现了 WebSocket 服务器的逻辑）。当后端发送消息给前端时，前端通过监听 <code>socket.onmessage</code> 事件来接收消息，并调用 <code>displayNotification</code> 方法将消息展示在页面上。</p>
<p>需要注意的是，实际生产环境中，需要根据具体的业务需求和消息格式来解析和展示消息。前端页面也可以根据业务需求定制更丰富的消息提示样式和交互效果。</p>
<h3 id="异步化生成图表的结果"><a href="#异步化生成图表的结果" class="headerlink" title="异步化生成图表的结果"></a>异步化生成图表的结果</h3><ol>
<li><strong>提高安全性，避免大量调用 AI 接口：</strong></li>
</ol>
<p>我们通过图表生成的异步化操作，利用线程池，可以保证系统的安全性，避免大量请求进入导致 AI 调用系统崩溃。</p>
<ol start="2">
<li><strong>提高单个用户生成图表的效率：</strong></li>
</ol>
<p>之前调用生成图表接口，需要等待图表生成完毕后才能再次调用接口。需要花费挺多时间。</p>
<p>利用异步化操作，可以让<strong>调用图表生成过程和 AI 调用过程分离开</strong>，开辟新的线程去调用 AI ，而调用图表生成的接口 gen 可以更快返回结果，这个结果是一个临时结果，可以表示此时 AI 生成的状态（待完成、正在执行、已完成、失败的），而这个 gen 接口的调用已经结束了，用户可以立即再次调用接口去生成新的图表，无需等待之前的图表生成完毕才能调用。</p>
<ol start="3">
<li>用户调用接口后，<strong>可以去我的图表下查看生成的图表</strong></li>
</ol>
<h1 id="第六期"><a href="#第六期" class="headerlink" title="第六期"></a>第六期</h1><ol>
<li>分析系统现在的不足</li>
<li>分布式消息队列</li>
<li>分布式消息队列 RabbitMQ 入门实战</li>
<li>项目拓展</li>
</ol>
<h2 id="分析系统现状不足"><a href="#分析系统现状不足" class="headerlink" title="分析系统现状不足"></a>分析系统现状不足</h2><p>已经经过了同步到异步的改造？</p>
<p>现状：目前的异步是通过 <strong>本地</strong> 的线程池实现的</p>
<ol>
<li><strong>无法集中限制，只能单机限制</strong></li>
</ol>
<p>假如 AI 服务限制只能有两个用户同时使用，单个线程池可以限制最大核心线程数为 2 来实现。</p>
<p>假设系统用量增大，改为分布式、多台服务器，每个服务器都要有两个线程，就可能有 2N 哥线程，超过了 AI 服务的限制</p>
<p>解决方案：在一个集中的地方去管理下发任务（比如集中存储当前正在执行的任务数）</p>
<ol start="2">
<li>任务由于是放在内存中执行的，可能会丢失</li>
</ol>
<blockquote>
<p>虽然可以人工从数据库捞出来再重试，但是其实需要额外开发（比如定时任务），这种重试的场景是非常典型的，其实是不需要我们开发者过于关心、或者自己实现的。</p>
</blockquote>
<p>解决方案：把任务放在一个可以持久化存储的硬盘</p>
<ol start="3">
<li>优化：如果你的系统功能越来越多，长耗时任务越来越多，系统会越来越复杂（比如要开多个线程池、资源可能会出现项目抢占） ，其实我们可以把长耗时，消耗很多的任务把它单独抽成一个程序，不要影响主业务。</li>
</ol>
<p>解决方案：可以有一个中间人，让中间人帮我们去连接两个系统（比如核心系统和智能生成业务）</p>
<h2 id="分布式消息队列（学习方式：完整地去看官方文档的教程，讲的很详细，也很好理解，英文看不懂就先用浏览器翻译，如果还是看不懂就用-GPT-翻译）"><a href="#分布式消息队列（学习方式：完整地去看官方文档的教程，讲的很详细，也很好理解，英文看不懂就先用浏览器翻译，如果还是看不懂就用-GPT-翻译）" class="headerlink" title="分布式消息队列（学习方式：完整地去看官方文档的教程，讲的很详细，也很好理解，英文看不懂就先用浏览器翻译，如果还是看不懂就用 GPT 翻译）"></a>分布式消息队列（学习方式：完整地去看官方文档的教程，讲的很详细，也很好理解，英文看不懂就先用浏览器翻译，如果还是看不懂就用 GPT 翻译）</h2><p>中间件：</p>
<p>Redis、消息队列、分布式存储 Etcd</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217093650439.png" alt="image-20240217093650439"></p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>存放消息的队列。</p>
<p>队列特点：先进先出</p>
<p>消息：某种数据结构，比如字符串、对象、二进制数据、 json 等等</p>
<p>存储：存数据</p>
<p>消息队列相较于 Feign 接口的区别：</p>
<p>消息队列可以存储数据，而 Feign 接口就相当于一个 HTTP 请求，发送完就消失了。</p>
<p>应用场景：在多个不同的系统、应用之间进行数据的传输。</p>
<h4 id="消息队列的模型"><a href="#消息队列的模型" class="headerlink" title="消息队列的模型"></a>消息队列的模型</h4><p>生产者： Producer</p>
<p>消费者： Consumer</p>
<p>消息： Message</p>
<p>消息队列： Queue</p>
<p><strong>为什么要用消息队列？</strong></p>
<ol>
<li><p>异步处理</p>
<p>生产者发送完消息之后，可以继续去忙别的，消费者想什么时候消费都可以，不会产生阻塞。</p>
</li>
<li><p>削峰填谷</p>
<p>先把用户的请求放到消息队列中，消费者可以按照自己的需求，慢慢去取。</p>
</li>
</ol>
<p><strong>分布式消息队列的优势</strong></p>
<ol>
<li>数据持久化：它可以把消息集中存储到硬盘里，服务器重启就不会丢失</li>
<li>可拓展性：可以根据需求，随时增加或减少节点，继续保持稳定的服务</li>
<li>应用解耦：可以连接各个不同语言、框架开发的系统，让这些系统能够灵活传输读取数据</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/769883">超详细的RabbitMQ入门，看这篇就够了！-阿里云开发者社区 (aliyun.com)</a></p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217100111155.png" alt="image-20240217100111155"></p>
<ol start="4">
<li><p>发布订阅</p>
<p>如果一个非常大的系统要给其他子系统发送通知，最简单直接的方式是大系统直接依次调用小系统。</p>
</li>
</ol>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217101137550.png" alt="image-20240217101137550"></p>
<h4 id="消息队列的应用场景"><a href="#消息队列的应用场景" class="headerlink" title="消息队列的应用场景"></a>消息队列的应用场景</h4><ol>
<li>耗时的场景（异步）</li>
<li>高并发场景（异步、削峰填谷）</li>
<li>分布式系统协作（尤其是跨团队、跨业务协作、应用解耦）</li>
<li>强稳定性的场景（比如金融业务、持久化、可靠性、削峰填谷）</li>
</ol>
<h4 id="消息队列的缺点"><a href="#消息队列的缺点" class="headerlink" title="消息队列的缺点"></a>消息队列的缺点</h4><p>要给系统引入额外的中间件，系统会更复杂、额外维护中间件、额外的费用成本</p>
<p>消息队列：消息丢失、顺序性、重复消息、数据的一致性（分布式系统就要考虑）</p>
<blockquote>
<p>也可以教分布式场景需要考虑的问题</p>
</blockquote>
<h3 id="主流分布式消息队列选型"><a href="#主流分布式消息队列选型" class="headerlink" title="主流分布式消息队列选型"></a>主流分布式消息队列选型</h3><ol>
<li>activemq</li>
<li>rabbitmq</li>
<li>kafka</li>
<li>rocketmq</li>
<li>zeromq</li>
<li>pulsar</li>
<li>Tube（Apache InLong）</li>
</ol>
<p><strong>技术对比</strong></p>
<p>技术选型指标：</p>
<ul>
<li>吞吐量： IO 、并发</li>
<li>时效性：类似延迟、消息的发送、到达时间</li>
<li>可用性：系统可用的比率（比如一年 365 天宕机 1s）</li>
<li>可靠性：消息不丢失（比如不丢失订单）</li>
</ul>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217103217497.png" alt="image-20240217103217497"></p>
<h3 id="RabbitMQ-入门实战"><a href="#RabbitMQ-入门实战" class="headerlink" title="RabbitMQ 入门实战"></a>RabbitMQ 入门实战</h3><p>特点：生态好，好学习，易于理解，时效性强，支持多种不同语言的客户端。</p>
<p>生产者：发消息的</p>
<p>消费者：收消息的</p>
<p>交换机（Exchange） ：负责把消息转发到对应的队列</p>
<p>队列 （Queue）：存储消息的</p>
<p>路由 (Routes) ：转发，就是把消息从一个地方转到领域给地方，比如从生产者转发到某个队列。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/install-windows.html">在 Windows 上安装 — 兔子MQ (rabbitmq.com)</a></p>
<p>安装 erlang（必须先安装好了，才能安装 rabbitMQ）</p>
<p> [Otp 25.3.2 - Erlang&#x2F;OTP</p>
<p><a target="_blank" rel="noopener" href="https://www.erlang.org/patches/otp-25.3.2"></a></p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217202213399.png" alt="image-20240217202213399"></p>
<p>安装 rabbitmq</p>
<p>[在 Windows 上安装 — 兔子MQ (rabbitmq.com)</p>
<p><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/install-windows.html"></a></p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217202226668.png" alt="image-20240217202226668"></p>
<p>安装完成后，它会自动启动 rabbitMQ，我们可以通过服务管理器来查看：</p>
<p>直接在搜索框搜索服务即可找到：</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217203052055.png" alt="image-20240217203052055"></p>
<p>安装rabbitmq 监控面板：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>



<p>管理页面的默认的账号密码是 guest</p>
<p>如果想要在远程服务安装访问 rabbitmq 的管理面板，需要自己创建一个管理员账号，不能用默认的 guest ，否则会被拦截。（官方出于安全考虑）</p>
<p>如果被拦截，可以添加一个用户 User</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217110125109.png" alt="image-20240217110125109"></p>
<p><strong>Java 客户端</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.rabbitmq/amqp-client --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.17.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>





<p>标准端口：</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217113532455.png" alt="image-20240217113532455"></p>
<p>使用教程：</p>
<p><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/tutorials/tutorial-one-java.html">RabbitMQ 教程 - “Hello World！” — 兔子MQ</a></p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217211813567.png" alt="image-20240217211813567"></p>
<h5 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h5><p>发送消息的教程十分简单，只需要创建一个连接，设置消息队列的 Host</p>
<p>创建频道，声明队列，发送消息即可。</p>
<p>详细看官方文档：</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217112806177.png" alt="image-20240217112806177"></p>
<p>声明队列的四个参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 参数介绍</span></span><br><span class="line"><span class="comment">  * 1.队列名称 QueueName</span></span><br><span class="line"><span class="comment">  * 2.是否持久化 durable</span></span><br><span class="line"><span class="comment">  * 3.是否是排他性队列 (只允许首次声明它的连接 (Connection) 可见，其他用户都不可访问) exclusive</span></span><br><span class="line"><span class="comment">  * 4.是否自动删除 (当没有生产者或者消费者使用此队列，该队列会自动删除) autoDelete</span></span><br><span class="line"><span class="comment">  * 5.队列的其他参数 arguments</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleProducer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 创建连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 设置 rabbitMQ 的服务地址</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取连接对象</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">// 创建通道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数介绍</span></span><br><span class="line"><span class="comment">         * 1.队列名称</span></span><br><span class="line"><span class="comment">         * 2.是否持久化</span></span><br><span class="line"><span class="comment">         * 3.是否是排他性队列 (只允许首次声明它的连接 (Connection) 可见，其他用户都不可访问)</span></span><br><span class="line"><span class="comment">         * 4.是否自动删除 (当没有生产者或者消费者使用此队列，该队列会自动删除)</span></span><br><span class="line"><span class="comment">         * 5.队列的其他参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 任意字符串作为 message</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">        <span class="comment">// 发布消息</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>启动该 main 方法后，可以在管理界面看到队列的生产和相应的消息：</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217210145799.png" alt="image-20240217210145799"></p>
<p>接收消息：</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217112651892.png" alt="image-20240217112651892"></p>
<p>接收消息的实现也非常简单，参照官方文档即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleConsumer</span> &#123;</span><br><span class="line">    <span class="comment">// 队列名称和要接收的队列名称一致</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 设置 RabbitMQ 的 Host</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">// 创建通道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列,要和发布者的队列声明一致。</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 接收消息</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Received &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数表示</span></span><br><span class="line"><span class="comment">         * 1. 队列名称</span></span><br><span class="line"><span class="comment">         * 2. 是否自动 ACK</span></span><br><span class="line"><span class="comment">         * 3. 消息回调参数，指定了接收到的消息的具体执行方案</span></span><br><span class="line"><span class="comment">         * 4， 空的一个 Lambda 表达式</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, deliverCallback,  consumerTag -&gt; &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>其中比较重要的一个点：</p>
<p>让消费者被阻塞（线程不会结束），这样能够持续地消费消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br></pre></td></tr></table></figure>

<p>一旦又接收到消息，就再去调用 deliverCallback 消息回调。</p>
<h4 id="消息队列的一些配置"><a href="#消息队列的一些配置" class="headerlink" title="消息队列的一些配置"></a>消息队列的一些配置</h4><p><strong>队列持久化</strong></p>
<p>durable 参数设置为 true ，服务器重启后队列不丢失：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(TASK_QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>



<p><strong>消息持久化</strong></p>
<p>指定  MessageProperties.PERSISTENT_TEXT_PLAIN,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, TASK_QUEUE_NAME,</span><br><span class="line">        MessageProperties.PERSISTENT_TEXT_PLAIN,</span><br><span class="line">        message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="WorkQueue"><a href="#WorkQueue" class="headerlink" title="WorkQueue"></a>WorkQueue</h3><p>上面的演示是一对一的模式，现在来看一下一对多：</p>
<p><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/tutorials/tutorial-two-java.html">RabbitMQ 教程 - 工作队列 — 兔子MQ</a></p>
<h4 id="多消费者"><a href="#多消费者" class="headerlink" title="多消费者"></a>多消费者</h4><p>若单个消费者处理速度慢，会导致消息积压在消息队列中，我们要如何处理？</p>
<p><strong>可以通过加入更多的消费者</strong></p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217211722274.png" alt="image-20240217211722274"></p>
<p> 控制单个消费者的处理任务积压数：</p>
<p>下述代码表示每个 channel 最多同时处理 1 个任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicQos(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<p>可以通过 for 循环，定义多个 channel ，实现对同一个队列的消费。</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217165418974.png" alt="image-20240217165418974"></p>
<p>这里的 Thread.sleep 会让每个消费者在执行回调时，睡 20s ，但是这并不影响 for 循环的运行，因为这相当于开了一个新线程，让新线程去睡 20s 而原来的主线程仍然在运行。</p>
<p>仍然运行的主线程会创建新的channel，并声明相同的队列，就可以同时消费同一个队列。</p>
<p><strong>多消费者代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mulConsumer</span> &#123;</span><br><span class="line">    <span class="comment">// 队列名称和要接收的队列名称一致</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 设置 RabbitMQ 的 Host</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">// 创建通道</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">            <span class="comment">// 让消费者消费完一个消息后才能消费下一个</span></span><br><span class="line">            channel.basicQos(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 声明队列,要和发布者的队列声明一致。</span></span><br><span class="line">            channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 接收消息，这其实相当于开辟了新线程去执行 deliverCallback 的处理</span></span><br><span class="line">            <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">                <span class="comment">// 测试多消费者情况，加入休眠,模拟消费任务繁忙的情况</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot; [x] Received &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">20000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// ack 消息</span></span><br><span class="line">                channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 参数表示</span></span><br><span class="line"><span class="comment">             * 1. 队列名称</span></span><br><span class="line"><span class="comment">             * 2. 是否自动 ACK</span></span><br><span class="line"><span class="comment">             * 3. 消息回调参数，指定了接收到的消息的具体执行方案</span></span><br><span class="line"><span class="comment">             * 4， 空的一个 Lambda 表达式</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicConsume(QUEUE_NAME, <span class="literal">false</span>, deliverCallback,  consumerTag -&gt; &#123; &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以通过向消费者快速发送 2 个消息，可以看到两个消息都被成功接收并执行回调，而后续在 20s 内再发送的消息就无法立刻被接收了，说明两个消费者都现在都在 Thread.sleep(20000) 的状态，无法处理新的消息。</p>
<h5 id="消息确认机制"><a href="#消息确认机制" class="headerlink" title="消息确认机制"></a>消息确认机制</h5><p>为了保证消息成功被消费（快递成功被取走），rabbitmq 提供了消息确认机制，当消费者接收到消息后，比如要给一个反馈：</p>
<ol>
<li>ack：消费成功</li>
<li>nack：消费失败</li>
<li>reject：拒绝</li>
</ol>
<p>如果告诉 rabbitmq 服务器消费成功，服务器才会放心地移除消息</p>
<p>支持配置 autoack，会自动执行 ack 命令，即一旦接收到消息就立刻 ack ，一般不建议设置为 true， 因为虽然消息接收成功了，也可能在其他业务流程中会出现失败，可能需要重试消息。</p>
<p>channel.basicConsume(TASK_QUEUE_NAME, false, deliverCallback, consumerTag -&gt;{}) </p>
<p>建议 autoack 为 false， 根据实际情况再去做手动确认。</p>
<p>指定确认某条消息：</p>
<p>第二个参数 multiple 是指是否要一次性确认所有的历史消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>



<p>指定拒绝某条消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicReject(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>





<p>两个小技巧：</p>
<ol>
<li>使用 Scanner 接收用户输入，便于快速发送消息</li>
<li>使用 for 循环实现多个消费者，便于快速验证队列模型工作机制</li>
</ol>
<h3 id="交换机-Exchanges"><a href="#交换机-Exchanges" class="headerlink" title="交换机 Exchanges"></a>交换机 Exchanges</h3><p>一个生产者给 **多个 ** 队列发消息， 1 个生产者对多个队列。</p>
<p>交换机的作用：类似于网络路由器，提供转发功能。</p>
<p>解决问题：怎么把消息转发到不同的队列上，好让消费者从不同的队列消费。</p>
<p>交换机有多种类别：</p>
<ol>
<li>fanout</li>
<li>direct</li>
<li>topic</li>
<li>headers</li>
</ol>
<h4 id="发布订阅场景"><a href="#发布订阅场景" class="headerlink" title="发布订阅场景"></a>发布订阅场景</h4><p><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/tutorials/tutorial-three-java.html">RabbitMQ 教程 - 发布&#x2F;订阅 — 兔子MQ</a></p>
<p>顾名思义，就如我们平时在视频网站上关注 up 主的情况类似， up 主发布了视频（相当于发布消息），所有关注了这个 up 主的用户都会接收到视频推送（消费者接收消息）。</p>
<p><strong>fanout</strong></p>
<p>扇出、广播</p>
<p>特点：消息会被发送到每个绑定了这个交换机的队列</p>
<p>场景：很适用于发布订阅的场景，比如发布日志。 </p>
<p>场景示例：</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217172803517.png" alt="image-20240217172803517"></p>
<p><strong>生产消息：</strong></p>
<p>现在生产者只需要向交换机发送消息，交换机会自动将消息发送到所有绑定了这个交换机的队列：</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217172657926.png" alt="image-20240217172657926"></p>
<p>上图代码可以看出来，就是对着交换机发送消息的。</p>
<p><strong>fanout 生产者的代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutProducer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;fanout_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 创建连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 设置 RabbitMQ 的 Host</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="comment">// 生成连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">// 创建通道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 创建 扇出 fanout 交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            <span class="comment">// 发送消息到交换机</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 参数介绍</span></span><br><span class="line"><span class="comment">             * 1，交换机名称</span></span><br><span class="line"><span class="comment">             * 2.routingKey，只有绑定了相同的 routingKey 的队列才能接收到该消息，不设置就表明任何的队列都可以接收到消息</span></span><br><span class="line"><span class="comment">             * 3.props，消息的属性</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;&quot;</span>, <span class="literal">null</span>, message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>消费消息：</strong></p>
<p>让消费者绑定同一个交换机</p>
<p>注意，下述代码缺失了创建队列的内容，<strong>要提前先声明队列</strong></p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240217172823596.png" alt="image-20240217172823596"> </p>
<p>基于命名的队列和随机命名的队列的 Java 代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConsumer</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;fanout_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME , <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">// 随机生成队列名称并声明队列,fanout 的发布订阅模式对于具体的某一个消费者情况是可以不在乎的，因此随机的名称也是可以的</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 绑定交换机</span></span><br><span class="line"><span class="comment">         * 参数介绍</span></span><br><span class="line"><span class="comment">         * 1.队列名称</span></span><br><span class="line"><span class="comment">         * 2.交换机名称</span></span><br><span class="line"><span class="comment">         * 3.routingKey，路由键,如果设置为空字符串，则任何发送到该交换机的消息都会被路由到该队列</span></span><br><span class="line"><span class="comment">         * 如果设置成其他的字符串，那么发送到该交换机的消息，只有routingKey与该字符串相匹配的消息才会被路由到该队列</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// 当然，你也可以指定一个队列名称，便于生产者和消费者进行管理</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;小方的专属消息队列&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 绑定第二个队列到相同的交换机-</span></span><br><span class="line">        channel.queueBind(<span class="string">&quot;小方的专属消息队列&quot;</span>, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消息回调1</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback1</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; [随机名称队列] Received &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 消息回调2</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback2</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; [小方队列] Received &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback1, consumerTag -&gt; &#123;&#125;);</span><br><span class="line">        channel.basicConsume(<span class="string">&quot;小方的专属消息队列&quot;</span>, <span class="literal">true</span>, deliverCallback2, consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以执行上述两个代码，从消费者控制台中看到，所有绑定了相同交换机的队列都会接收到消息</p>
<h1 id="第七期"><a href="#第七期" class="headerlink" title="第七期"></a>第七期</h1><blockquote>
<p>鱼哥这一期讲的 rabbitMQ 的 demo 部分并没有阅读完整 官方文档，要再看一遍。</p>
</blockquote>
<h3 id="路由绑定"><a href="#路由绑定" class="headerlink" title="路由绑定"></a>路由绑定</h3><p><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/tutorials/tutorial-four-java.html">RabbitMQ 教程 - 路由 — 兔子MQ</a></p>
<h4 id="Direct-交换机"><a href="#Direct-交换机" class="headerlink" title="Direct 交换机"></a>Direct 交换机</h4><p>绑定：可以让交换机和队列进行关联，可以指定让交换机把什么样的消息发送机给哪个队列。</p>
<p>routingKey ： 路由键，控制消息要转发给哪个队列的（IP 地址）</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240219085131288.png" alt="image-20240219085131288"></p>
<p>也就是说，咋们通过利用 Direct 交换机，并且在发布消息时，指定相应的 routingKey，就可以让只订阅了相同 routingKey 的队列的消费者收到消息。</p>
<p><strong>这个路由键是可以绑定多个队列的</strong></p>
<p>即：一个路由键，可以绑定多个绑定了同样路由键的队列。</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240219090659270.png" alt="image-20240219090659270"></p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240219090846330.png" alt="image-20240219090846330"></p>
<p>可以看的出来，只要指定相应的 routingKey，相应的队列就只会接受这个 routingKey 的消息。</p>
<h5 id="小尝试："><a href="#小尝试：" class="headerlink" title="小尝试："></a>小尝试：</h5><ol>
<li>试试看让消费者的 routingKey 设置为 “” ，然后生产者指定一个 routingKey 来发送消息，看看结果如何？</li>
</ol>
<h4 id="Direct-交换机-Demo-实现"><a href="#Direct-交换机-Demo-实现" class="headerlink" title="Direct 交换机 Demo 实现"></a>Direct 交换机 Demo 实现</h4><p><strong>生产者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">    <span class="comment">// 从工厂创建连接</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">         <span class="comment">// 创建通道</span></span><br><span class="line">         <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel()) &#123;</span><br><span class="line">        <span class="comment">// 声明交换机类型为 direct</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;xiaofang&quot;</span>, <span class="literal">null</span>,</span><br><span class="line">                    message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] 发送给小方的消息&quot;</span> + message + <span class="string">&quot;:&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>消费者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">    <span class="comment">// 声明交换机</span></span><br><span class="line">    channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">    <span class="comment">// 随机声明队列名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">    <span class="comment">// 队列绑定交换机,第三个参数声明 routingKey，确定路由</span></span><br><span class="line">    channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;xiaofang&quot;</span>);</span><br><span class="line">    <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; [x] 小方收到了 &#x27;&quot;</span> +</span><br><span class="line">            delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;&#x27;:&#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Topic-交换机"><a href="#Topic-交换机" class="headerlink" title="Topic 交换机"></a>Topic 交换机</h3><blockquote>
<p>需求引入：我们之前给消费者的消息的 routingKey 是不可再分的，但是对于一类消息，消费者可能有更细致的需求，比如买东西，有的人需要买家电，有的人需要买果蔬，在情况少的时候，我们可以指定更多的 routingKey 来囊括所有的情况，但是倘若类别太多了，就无法一一地创建 routingKey 了，那么我们就希望有一个能够只固定父级类别，但能区分更多细分情况的消息发送机制。</p>
</blockquote>
<p>以路由键集合的方式发送消息。</p>
<p>特点：消息会根据一个 <strong>模糊的</strong> 路由键转发到指定的队列</p>
<p>场景：特定的一类消息可以交给特定的一类系统（程序）来处理</p>
<p>绑定关系：可以模糊匹配多个绑定</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240219092838467.png" alt="image-20240219092838467"></p>
<p>图表标识含义：</p>
<ol>
<li><code>*</code> (星号) ：可以任意匹配一个单词， 不如 *. orange , 那么 a.orange ， b.roange 都能匹配</li>
<li><code>#</code> （井号）：可以匹配任意长度的字符。</li>
</ol>
<p><strong>点号是用来分割字符的，比如上面的 orange ，它就只能包含两个任意单词和固定单词orange，不能出现四个单词以上的组合。</strong></p>
<p>参考官方文档的说明：<img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240219222803795.png" alt="image-20240219222803795"></p>
<p>注意：上面的图的示例中都带了一个 <code>.</code>  （点），这是用来分割字符的，是消息队列用来区分通配符还是固定字符的。所以我们在使用 #通配符的时候，要注意加上 <code>.</code> （点），<strong>不能用别的符号来区分字符。</strong> （不能直接用 #lazy，而要用 lazy.#）</p>
<h4 id="Topic-Demo-实现"><a href="#Topic-Demo-实现" class="headerlink" title="Topic Demo 实现"></a>Topic Demo 实现</h4><p><strong>生产者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopicProducer</span> &#123;</span><br><span class="line">    <span class="comment">// 定义交换机名称为&quot;direct-exchange&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic-exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建连接工厂对象</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 设置消息队列的主机地址为本地主机</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建连接和通道，并确保资源自动关闭</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">             <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel()) &#123;</span><br><span class="line">            <span class="comment">// 声明使用主题交换机，并指定交换机名称和类型</span></span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line">            <span class="comment">// 创建一个扫描器对象，从控制台读取用户输入</span></span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">                <span class="comment">// 读取用户输入的一行文本</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">userInput</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                <span class="comment">// 使用空格分隔用户输入的文本</span></span><br><span class="line">                String[] strings = userInput.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="comment">// 如果分隔后的文本长度小于2，则跳过当前循环</span></span><br><span class="line">                <span class="keyword">if</span> (strings.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 获取用户输入的消息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> strings[<span class="number">0</span>];</span><br><span class="line">                <span class="comment">// 获取用户输入的路由键</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> strings[<span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 发布消息到指定的交换机和路由键</span></span><br><span class="line">                channel.basicPublish(EXCHANGE_NAME, routingKey, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                <span class="comment">// 打印消息发送的提示信息，包含消息内容和路由键</span></span><br><span class="line">                System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot; with routing:&quot;</span> + routingKey + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>消费者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopicConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic-exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;frontend_queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;#.frontend.#&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;收到前端消息&quot;</span> + message);</span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">false</span>, deliverCallback, consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h5 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h5><p>支持用消息队列来模拟 RPC 的调用。但是一般没必要，用 Dubbo、GRPC 等 RPC 框架就好。</p>
<h3 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h3><p><strong>消息过期机制</strong></p>
<p>可以给每条消息指定一个有效期，一段时间内未被消费者处理，就过期了。</p>
<p>示例场景：用户下单后，长时间未付款，消息自动取消。</p>
<p>适用场景：清理过期数据、模拟延迟队列的实现。</p>
<p>不过有一些细节：</p>
<p>消息队列的发送的过期消息如果已经被消费者接收，但是消费者在执行过程中长时间未 ACK ，这种情况消息是不会受到过期时间影响而继续计时的。直到消息真正被消费者 ACK 为止。</p>
<p>但是，需要注意的是，如果消息处于待消费状态（即未被消费者消费中），并且过期时间到达后，消息将被标记为过期。</p>
<h3 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h3><p>为了保证消息的可靠性，比如每条消息都成功消费，需要提供一个容错机制，即：失败的消息怎么处理？</p>
<p>死信：过期的消息、拒收的消息，消息队列满了，处理失败的消息的统称。</p>
<p>死信队列：专门处理死信的队列（注意：它就是一个普通队列，只不过是专门用来处理死信的，你可以理解成这个队列的名称叫做 “死信队列”）</p>
<p>死信交换机：专门给死信队列转发消息的交换机（它也是一个普通交换机，但是它是给） 死信交换机可以根据情况将消息发送到不同的死信队列。</p>
<p>对于一些消费者无法处理的消息，它拒绝之后不需要把这个消息丢到垃圾桶不要了，可以拿一个死信队列来装这些消息。<img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240219103354336.png" alt="image-20240219103354336"></p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><ol>
<li><p>创建死信交换机和死信队列</p>
</li>
<li><p>给失败之后需要容错处理的队列绑定死信交换机</p>
</li>
<li><p>可以给要容错的队列指定死信之后的转发规则，死信应该再转发到哪个死信队列？</p>
</li>
<li><p>可以通过程序来读取死信队列中的信息，来做一些后续的容错处理。（即同样采取和消费普通队列的方式来消费在死信队列中的消息。）</p>
</li>
</ol>
<h3 id="RabbitMQ-的重要特性"><a href="#RabbitMQ-的重要特性" class="headerlink" title="RabbitMQ 的重要特性"></a>RabbitMQ 的重要特性</h3><blockquote>
<p>面试考点</p>
</blockquote>
<ol>
<li><p>消息队列的概念、模型、应用场景</p>
</li>
<li><p>交换机的类别、路由绑定的关系</p>
</li>
<li><p><strong>消息可靠性</strong></p>
<ol>
<li>消息确认机制 （ack，nack，reject）</li>
<li>消息持久化（durable）</li>
<li>消息过期机制</li>
<li>死信队列</li>
</ol>
</li>
<li><p>延迟队列（类似死信队列）</p>
</li>
<li><p>顺序消费、消费幂等性</p>
</li>
<li><p>可拓展性 （仅做了解）</p>
<ol>
<li>集群</li>
<li>故障的恢复机制</li>
<li>镜像</li>
</ol>
</li>
<li><p>运维监控告警（仅做了解）</p>
</li>
</ol>
<h2 id="RabbitMQ-小测试"><a href="#RabbitMQ-小测试" class="headerlink" title="RabbitMQ 小测试"></a>RabbitMQ 小测试</h2><ol>
<li>在百万级数据量的情况下向交换机发送消息，消息队列的每秒处理平均速度为 25000 条消息，可以据此情况来设定单轮向 MQ 发送的消息数目，来控制并发量。</li>
</ol>
<h3 id="RPC-实现"><a href="#RPC-实现" class="headerlink" title="RPC 实现"></a>RPC 实现</h3><p>requestQueueName ：提供服务调用者发送参数的队列，是调用服务的初始使用队列</p>
<p>回调队列：由服务调用者生成，供服务提供者返回服务调用结果给服务调用者的队列</p>
<p>CorrId ：用来判断是哪个服务调用者消息。将其发送到对应的回调队列</p>
<p>生产者和消费者不再固定，而是变化的，服务的调用者先发送消息（相当于将请求参数传递给远程方法），服务的提供者接收到消息，在回调中调用服务方法，然后在作为生产者发送消息 (方法调用的结果)  给服务调用者。</p>
<p><strong>关键代码</strong></p>
<p>回调队列的生成</p>
<ol>
<li>回调队列名称。（可以唯一 ，也就是让同一个客户端的所有的 RPC 请求都使用同一个回调队列 ）</li>
<li>生成随机的 corrId ，用来判断 RPC 请求是否匹配当前的请求(因为一个客户端可能在短时间内发送多条 RPC 请求，如果都是发送到同一个回调队列，那么就需要有一个唯一值来判断请求的归属)，如果匹配，那么就接收调用结果。</li>
</ol>
<p>corrId 的设置可以让客户端只使用单独的回调队列实现 RPC，不必为每个请求都创建 RPC ，可以提高客户端调用请求的效率。</p>
<p><strong>生产者代码（服务提供者）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RPC 实现原理</span></span><br><span class="line"><span class="comment"> * 没有完全固定的消费者和生产者，服务提供者既是消费者又是生产者</span></span><br><span class="line"><span class="comment"> * 生产者发送请求消息，消费者接收请求消息并处理，然后将结果返回给请求方</span></span><br><span class="line"><span class="comment"> * 请求方等待接收结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RPCServer</span> &#123;</span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RPC_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;rpc_queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 定义斐波那契函数，提供服务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        channel.queueDeclare(RPC_QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        channel.queuePurge(RPC_QUEUE_NAME);</span><br><span class="line"></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot; [x] Awaiting RPC requests&quot;</span>);</span><br><span class="line">        <span class="comment">// 从客户端(消费者)处收到调用方法的消息，编写回调函数，处理消费者请求，目标是调用斐波那契函数返回结果</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 回调参数,从客户端设置好的回调参数中取出响应的 corrId(是唯一的，因为客户端调用的每个方法都统一使用同一个回调队列)</span></span><br><span class="line">            AMQP.<span class="type">BasicProperties</span> <span class="variable">replyProps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties</span><br><span class="line">                    .Builder()</span><br><span class="line">                    .correlationId(delivery.getProperties().getCorrelationId())</span><br><span class="line">                    .build();</span><br><span class="line">            <span class="comment">// 响应结果</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取客户端的消息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(message);</span><br><span class="line">                <span class="comment">// 调用函数</span></span><br><span class="line">                System.out.println(<span class="string">&quot; [.] fib(&quot;</span> + message + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">                response += fib(n);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot; [.] &quot;</span> + e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 发送消息到回调队列,这个 routingKey 参数实际上是队列名称参数</span></span><br><span class="line">                channel.basicPublish(<span class="string">&quot;&quot;</span>, delivery.getProperties().getReplyTo(), replyProps, response.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        channel.basicConsume(RPC_QUEUE_NAME, <span class="literal">false</span>, deliverCallback, (consumerTag -&gt; &#123;&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>消费者代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RPCClient</span> <span class="keyword">implements</span> <span class="title class_">AutoCloseable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Connection connection;</span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">requestQueueName</span> <span class="operator">=</span> <span class="string">&quot;rpc_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RPCClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line"></span><br><span class="line">        connection = factory.newConnection();</span><br><span class="line">        channel = connection.createChannel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">RPCClient</span> <span class="variable">fibonacciRpc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RPCClient</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">i_str</span> <span class="operator">=</span> Integer.toString(i);</span><br><span class="line">                System.out.println(<span class="string">&quot; [x] Requesting fib(&quot;</span> + i_str + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> fibonacciRpc.call(i_str);</span><br><span class="line">                System.out.println(<span class="string">&quot; [.] Got &#x27;&quot;</span> + response + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | TimeoutException | InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">(String message)</span> <span class="keyword">throws</span> IOException, InterruptedException, ExecutionException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">corrId</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">replyQueueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">        AMQP.<span class="type">BasicProperties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties</span><br><span class="line">                .Builder()</span><br><span class="line">                .correlationId(corrId)</span><br><span class="line">                .replyTo(replyQueueName)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, requestQueueName, props, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> CompletableFuture&lt;String&gt; response = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (delivery.getProperties().getCorrelationId().equals(corrId)) &#123;</span><br><span class="line">                response.complete(<span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">ctag</span> <span class="operator">=</span> channel.basicConsume(replyQueueName, <span class="literal">true</span>, deliverCallback , consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> response.get();</span><br><span class="line">        channel.basicCancel(ctag);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其他的 RabbitMQ 的特性可以看官方文档：</p>
<blockquote>
<p>说实话，我感觉 RabbitMQ 的官方文档是真的比别的文档好读多了。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/documentation.html">Documentation: Table of Contents — RabbitMQ</a></p>
<p>这个部分值得一看，更多的特性，比如死信、惰性队列等。</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240220104510159.png" alt="image-20240220104510159"></p>
<h3 id="RabbitMQ-项目实战"><a href="#RabbitMQ-项目实战" class="headerlink" title="RabbitMQ 项目实战"></a>RabbitMQ 项目实战</h3><p>怎么在项目中使用 RabbitMQ </p>
<ol>
<li><strong>使用官方的客户端。</strong>（推荐）</li>
</ol>
<p>优点：兼容性好，换语言成本低，比较灵活</p>
<p>缺点：太灵活，要自己去处理一些事情，比如要自己维护管理链接，很麻烦。</p>
<ol start="2">
<li><strong>使用封装好的客户端，比如 Spring Boot RabbitMQ Starter</strong></li>
</ol>
<p>优点：简单易用，直接配置直接用</p>
<p>缺点：封装的太好了，不去学习不知道怎么使用</p>
<p><strong>引用的注意点</strong></p>
<p>引用的依赖版本要和 Spring Boot 版本对应。 非常重要！！！ 比如 Spring Boot 是 2.7.12 ，那么依赖也要是  2.7.12 或者是接近的。或者查看官方的版本依赖参照。</p>
<p>文档在此，没错，我的英语水平很高😭：</p>
<p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/messaging-rabbitmq">入门 |使用 RabbitMQ 进行消息传递 (spring.io)</a></p>
<p>官方文档里的发送消息的测试方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.messagingrabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.CommandLineRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runner</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Runner</span><span class="params">(Receiver receiver, RabbitTemplate rabbitTemplate)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line">    <span class="built_in">this</span>.rabbitTemplate = rabbitTemplate;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Sending message...&quot;</span>);</span><br><span class="line">   <span class="comment">// 关键点在下一行，这是发送消息的主要代码:</span></span><br><span class="line">    rabbitTemplate.convertAndSend(MessagingRabbitmqApplication.topicExchangeName, <span class="string">&quot;foo.bar.baz&quot;</span>, <span class="string">&quot;Hello from RabbitMQ!&quot;</span>);</span><br><span class="line">    receiver.getLatch().await(<span class="number">10000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="基础使用（先使用-SpringBoot-的客户端写一个测试方法）"><a href="#基础使用（先使用-SpringBoot-的客户端写一个测试方法）" class="headerlink" title="基础使用（先使用 SpringBoot 的客户端写一个测试方法）"></a>基础使用（先使用 SpringBoot 的客户端写一个测试方法）</h4><ol>
<li>引入依赖 （ SpringBoot 的配置）</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!--  Spring 的消息队列启动器   --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-amqp --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ol start="2">
<li>编写配置</li>
</ol>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置 rabbitmq</span></span><br><span class="line"> <span class="attr">rabbitmq:</span></span><br><span class="line">   <span class="attr">port:</span>  <span class="number">5672</span></span><br><span class="line">   <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">   <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">   <span class="attr">host:</span> <span class="string">localhost</span></span><br></pre></td></tr></table></figure>



<ol start="3">
<li>编写生产者代码</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMessageProducer</span> &#123;</span><br><span class="line">    <span class="comment">// 使用启动器自带的 rabbitTemplate，进行消息发送</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息，指定交换机，路由key，消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange 交换机名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> routingKey 路由键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 具体发送的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String exchange, String routingKey, String message)</span> &#123;</span><br><span class="line">        <span class="comment">// 外部做参数校验</span></span><br><span class="line">        rabbitTemplate.convertAndSend(exchange, routingKey, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>编写消费者代码</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">// 使用@Slf4j注解生成日志记录器</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMessageConsumer</span> &#123;</span><br><span class="line">    <span class="comment">// @SneakThrows 注解简化异常处理，</span></span><br><span class="line">    <span class="comment">// 底层实际上是给需要抛出检查型异常的方法加上了 try-catch，使用这个注解可以让代码更加简洁</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// rabbitMQ 消息监听注解，可以用来接收消息</span></span><br><span class="line">    <span class="comment">// 设置队列名称和消息确认模式为手动确认</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;code_queue&quot;&#125;, ackMode = &quot;MANUAL&quot;)</span></span><br><span class="line">    <span class="comment">// 在RabbitMQ中,每条消息都会被分配一个唯一的投递标签，用于标识该消息在通道中的投递状态和顺序。</span></span><br><span class="line">    <span class="comment">// 通过使用@Header(AmqpHeaders.DELIVERY_TAG)注解,</span></span><br><span class="line">    <span class="comment">// 可以从消息头中提取出该投递标签,并将其赋值给long deliveryTag参数。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMessage</span><span class="params">(String message, Channel channel, <span class="meta">@Header(AmqpHeaders.DELIVERY_TAG)</span> <span class="type">long</span> deliveryTag)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;receiveMessage message = &#123;&#125;&quot;</span>, message);</span><br><span class="line">        channel.basicAck(deliveryTag, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>要调用上面的方法，还需要提前先把队列创建好：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化 MQ ，创建相应的测试队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqInitMain</span> &#123;</span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">            factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">            <span class="comment">// 队列名称</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;code_exchange&quot;</span>;</span><br><span class="line">            <span class="comment">// 声明交换机,指定交换机名称和类型</span></span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;code_queue&quot;</span>;</span><br><span class="line">            <span class="comment">// 声明队列</span></span><br><span class="line">            channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 绑定交换机</span></span><br><span class="line">            channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;my_routingKey&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;初始化 MQ 失败:&#123;&#125;&quot;</span> , e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>写一个测试方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMessageProducerTest</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MyMessageProducer myMessageProducer;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">exchange</span> <span class="operator">=</span> <span class="string">&quot;code_exchange&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> <span class="string">&quot;my_routingKey&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;你好呀！&quot;</span>;</span><br><span class="line">        myMessageProducer.sendMessage(exchange, routingKey, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>启动 Spring Boot 项目后，会显示连接到 RabbitMQ 的连接：</p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240220115116513.png" alt="image-20240220115116513"></p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240220115157736.png" alt="image-20240220115157736"></p>
<h2 id="BI-项目改造"><a href="#BI-项目改造" class="headerlink" title="BI 项目改造"></a>BI 项目改造</h2><p>以前是把任务提交到线程池，然后再线程池提交中编写处理程序的代码，线程池内排队。</p>
<p>如果程序中断了，任务就没了，就丢了。</p>
<p>改造后的流程：</p>
<ol>
<li>把任务提交改为向队列发送消息</li>
<li>写一个专门的接受消息的程序，处理任务</li>
<li>如果程序中断了，消息未被确认，还会重发吗？</li>
</ol>
<p>验证发现：如果程序中断了，没有 ack、也没有 nack ，那么这条消息会被重新放到消息队列中，从而实现了每个任务都会执行。</p>
<h1 id="Bug-汇总和解决"><a href="#Bug-汇总和解决" class="headerlink" title="Bug 汇总和解决"></a>Bug 汇总和解决</h1><h2 id="修改前端布局导致项目无法正常启动："><a href="#修改前端布局导致项目无法正常启动：" class="headerlink" title="修改前端布局导致项目无法正常启动："></a>修改前端布局导致项目无法正常启动：</h2><ol>
<li>在调整管理界面的布局时，将修改好后的布局代码复制到 defaultSettings ，要先复制到空白区域，然后对原来的配置一一修改。不能直接去把原来的内容全部替换：</li>
</ol>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240210162954276.png" alt="image-20240210162954276"></p>
<ol start="2">
<li><p><strong>跨域</strong></p>
<p>在相应的 Controller 加上注解：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin(origins = &quot;http://localhost:8000&quot;, allowCredentials = &quot;true&quot;)</span></span><br></pre></td></tr></table></figure>

<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240210194817986.png" alt="image-20240210194817986"></p>
<ol start="3">
<li>设置 @EnableWebMvc 后出现 swagger 接口文档显示 404 问题</li>
</ol>
<p>由于定义了这个注解，导致接管了整个 Mvc 的环境，因此导致自动配置失效，进而导致静态页面无法访问。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46411355/article/details/128888427">@EnableWebMvc注解让swagger-ui.html无法打开404报错问题及其解决方案（史上最全最详细）-CSDN博客</a></p>
<h2 id="编写线程池测试接口时，-get-请求得到的响应返回问号："><a href="#编写线程池测试接口时，-get-请求得到的响应返回问号：" class="headerlink" title="编写线程池测试接口时， get 请求得到的响应返回问号："></a>编写线程池测试接口时， get 请求得到的响应返回问号：</h2><p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240216201629687.png" alt="image-20240216201629687"></p>
<p>解决方案：</p>
<p>在 RequestMapping 处加上 produces &#x3D; “application&#x2F;json”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/queue&quot;,produces = &quot;application/json&quot; )</span></span><br></pre></td></tr></table></figure>





<h1 id="小工具"><a href="#小工具" class="headerlink" title="小工具"></a>小工具</h1><p>注解 @SneakyThrows</p>
<p>可以为检查型异常（需要抛出的异常） 在底层加上 try-catch ，让代码更加简介。</p>
<p>未加注解的情况：<strong>出现异常爆红</strong></p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240220111643723.png" alt="image-20240220111643723"></p>
<p>加了注解的情况：<strong>异常不爆红：</strong></p>
<p><img src="/Shirly.github.io/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE.assets/image-20240220111714991.png" alt="image-20240220111714991"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://fangmoyu.github.io/Shirly.github.io/">老方</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://fangmoyu.github.io/2024/03/04/%E5%B0%8F%E6%96%B9%E7%9A%84%E9%A1%B9%E7%9B%AE/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE/">https://fangmoyu.github.io/2024/03/04/%E5%B0%8F%E6%96%B9%E7%9A%84%E9%A1%B9%E7%9B%AE/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://fangmoyu.github.io" target="_blank">摸鱼的老方</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/Shirly.github.io/./image/4.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/Shirly.github.io/2024/03/04/%E5%B0%8F%E6%96%B9%E7%9A%84%E9%A1%B9%E7%9B%AE/%E6%8E%A5%E5%8F%A3API%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0/" title="接口 API 开放平台笔记"><img class="cover" src="/Shirly.github.io/./image/22.png" onerror="onerror=null;src='/Shirly.github.io/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">接口 API 开放平台笔记</div></div></a></div><div class="next-post pull-right"><a href="/Shirly.github.io/2024/03/04/%E9%80%9A%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/" title="常见限流算法"><img class="cover" src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/IMG_2988.PNG" onerror="onerror=null;src='/Shirly.github.io/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">常见限流算法</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/Shirly.github.io/./image/MyAvatar.png" onerror="this.onerror=null;this.src='/Shirly.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">老方</div><div class="author-info__description">你好，欢迎访问我的博客，目前各项功能还在施工完善中，敬请期待</div></div><div class="card-info-data site-data is-center"><a href="/Shirly.github.io/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/Shirly.github.io/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/Shirly.github.io/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/FangMoyu"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/FangMoyu" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://map.baidu.com" target="_blank" title="地图"><i class="fa-solid fa-location-dot"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎访问我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%99%BA%E8%83%BD-BI-%E9%A1%B9%E7%9B%AE"><span class="toc-text">智能 BI 项目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D"><span class="toc-text">项目介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BI-%E5%B9%B3%E5%8F%B0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">BI 平台是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-text">需求分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E5%9B%BE"><span class="toc-text">架构图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E6%A0%88"><span class="toc-text">技术栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF"><span class="toc-text">前端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E7%AB%AF"><span class="toc-text">后端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E8%AE%A1%E5%88%92"><span class="toc-text">项目计划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">前端项目初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%84%9A%E6%89%8B%E6%9E%B6%E9%A1%B9%E7%9B%AE-bug-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">脚手架项目 bug 解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">后端项目初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bug-%E8%A7%A3%E5%86%B3"><span class="toc-text">bug 解决</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E8%A1%A8%E8%AE%BE%E8%AE%A1"><span class="toc-text">库表设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E8%B0%83%E7%94%A8%E5%90%8E%E7%AB%AF"><span class="toc-text">前端调用后端</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%9C%9F"><span class="toc-text">第二期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E5%88%92"><span class="toc-text">计划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E7%BB%AD%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE"><span class="toc-text">继续初始化项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E7%AB%AF%E5%90%AF%E5%8A%A8%E9%A1%B9%E7%9B%AE%E7%AB%AF%E5%8F%A3%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%EF%BC%9A"><span class="toc-text">后端启动项目端口冲突问题解决：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="toc-text">前端项目初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E9%A1%B5%E9%9D%A2"><span class="toc-text">开发登录注册页面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91"><span class="toc-text">智能分析业务开发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B"><span class="toc-text">业务流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E6%8E%A5%E5%8F%A3"><span class="toc-text">开发接口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AI-%E6%8F%90%E8%AF%8D%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="toc-text">AI 提词小技巧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%AF%B7%E6%B1%82"><span class="toc-text">文件上传请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EasyExcel-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E5%B9%B6%E6%8C%89%E7%85%A7%E9%A1%BA%E5%BA%8F%E8%BF%94%E5%9B%9E"><span class="toc-text">EasyExcel 读取数据并按照顺序返回</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8-AI"><span class="toc-text">调用 AI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%90%8E%E7%AB%AF%E6%A8%A1%E6%9D%BF"><span class="toc-text">启动后端模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF%E5%AD%A6%E4%B9%A0"><span class="toc-text">后端项目模板学习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Excel-%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-text">Excel 实现读取数据</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%9C%9F"><span class="toc-text">第三期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%9B%BE%E8%A1%A8"><span class="toc-text">生成图表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%99-AI-%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="toc-text">给 AI 添加新的描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E9%A2%84%E8%AE%BE%E5%AE%9E%E7%8E%B0%E6%9B%B4%E5%8A%A0%E7%BB%86%E8%87%B4%E7%9A%84%E5%9B%9E%E7%AD%94"><span class="toc-text">通过预设实现更加细致的回答</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AI-%E6%8F%90%E9%97%AE%E6%8A%80%E5%B7%A7"><span class="toc-text">AI 提问技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E4%B8%89%E7%A7%8D%E8%B0%83%E7%94%A8-AI-%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">Java三种调用 AI 的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%91%E9%80%81-HTTP-%E8%AF%B7%E6%B1%82%E8%B0%83%E7%94%A8"><span class="toc-text">通过发送 HTTP 请求调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%95%86%E6%8F%90%E4%BE%9B%E7%9A%84%E3%80%81%E5%B0%81%E8%A3%85%E5%90%8E%E7%9A%84-AI-%E6%8E%A5%E5%8F%A3"><span class="toc-text">2. 使用云服务商提供的、封装后的 AI 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%A9%E7%94%A8%E9%B1%BC%E8%81%AA%E6%98%8E-AI-%E6%8F%90%E4%BE%9B%E7%9A%84%E5%BC%80%E5%8F%91-SDK"><span class="toc-text">3. 利用鱼聪明 AI 提供的开发 SDK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%9E%84%E9%80%A0%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0"><span class="toc-text">3、构造请求参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E8%8E%B7%E5%8F%96%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9C"><span class="toc-text">4、获取响应结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8-AI-1"><span class="toc-text">调用 AI</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E6%8F%92%E6%9B%B2%EF%BC%9A%E7%A0%94%E7%A9%B6%E9%B1%BC%E7%9A%AE%E7%9A%84%E9%B1%BC%E8%81%AA%E6%98%8E-SDK"><span class="toc-text">小插曲：研究鱼皮的鱼聪明 SDK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#doChat-%E6%96%B9%E6%B3%95%E7%9A%84%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94"><span class="toc-text">doChat 方法的请求和响应</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="toc-text">智能接口实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E6%99%BA%E8%83%BD%E7%94%9F%E6%88%90%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91"><span class="toc-text">前端智能生成页面开发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E6%97%B6%E7%9A%84%E5%B1%95%E5%BC%80%E8%AF%AD%E6%B3%95%E2%80%A6"><span class="toc-text">前端发送请求时的展开语法…</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF-onFinish-%E5%AE%9E%E7%8E%B0"><span class="toc-text">前端 onFinish 实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E6%80%9D%E8%80%83"><span class="toc-text">本章思考</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E6%9C%9F"><span class="toc-text">第四期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E5%88%92-1"><span class="toc-text">计划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E9%83%A8%E5%88%86%E8%A1%A8%E7%A4%BA"><span class="toc-text">前端部分表示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%8C%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%80%9D%E6%83%B3%E3%80%81%E9%99%90%E6%B5%81%E6%80%9D%E8%B7%AF%EF%BC%89"><span class="toc-text">系统优化（重点，分库分表思想、限流思路）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#todo-%E8%87%AA%E4%B8%BB%E6%8B%93%E5%B1%95"><span class="toc-text">todo 自主拓展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-text">分库分表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%90%E6%B5%81"><span class="toc-text">限流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E6%B5%81%E7%9A%84%E5%87%A0%E7%A7%8D%E7%AE%97%E6%B3%95"><span class="toc-text">限流的几种算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E6%B5%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">限流的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redisson-%E9%99%90%E6%B5%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">Redisson 限流实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E6%B5%81%E7%B2%92%E5%BA%A6"><span class="toc-text">限流粒度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E6%9C%9F"><span class="toc-text">第五期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E5%88%92-2"><span class="toc-text">计划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-text">系统问题分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%8C%96"><span class="toc-text">异步化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-text">业务流程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BC%82%E6%AD%A5%E5%8C%96%E7%9A%84%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B"><span class="toc-text">标准异步化的业务流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%A1%AE%E5%AE%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0%E5%91%A2%EF%BC%9F"><span class="toc-text">怎么确定线程池参数呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%EF%BC%9A"><span class="toc-text">线程池分配策略：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#todo%E8%87%AA%E4%B8%BB%E5%AE%9E%E7%8E%B0"><span class="toc-text">todo自主实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E6%B5%81%E7%A8%8B"><span class="toc-text">线程池执行任务流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0"><span class="toc-text">线程池实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%8F%91"><span class="toc-text">开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E5%92%8C%E5%A4%8D%E7%94%A8%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-text">编写和复用错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E7%82%B9"><span class="toc-text">优化点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%99%E7%94%A8%E6%88%B7%E5%8F%91%E9%80%81%E5%8F%91%E9%80%81%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E7%9A%84%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%A1%8C%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-text">给用户发送发送实时消息的一个可行实现：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%8C%96%E7%94%9F%E6%88%90%E5%9B%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="toc-text">异步化生成图表的结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E6%9C%9F"><span class="toc-text">第六期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F%E7%8E%B0%E7%8A%B6%E4%B8%8D%E8%B6%B3"><span class="toc-text">分析系统现状不足</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88%E5%AD%A6%E4%B9%A0%E6%96%B9%E5%BC%8F%EF%BC%9A%E5%AE%8C%E6%95%B4%E5%9C%B0%E5%8E%BB%E7%9C%8B%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%9A%84%E6%95%99%E7%A8%8B%EF%BC%8C%E8%AE%B2%E7%9A%84%E5%BE%88%E8%AF%A6%E7%BB%86%EF%BC%8C%E4%B9%9F%E5%BE%88%E5%A5%BD%E7%90%86%E8%A7%A3%EF%BC%8C%E8%8B%B1%E6%96%87%E7%9C%8B%E4%B8%8D%E6%87%82%E5%B0%B1%E5%85%88%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BF%BB%E8%AF%91%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%BF%98%E6%98%AF%E7%9C%8B%E4%B8%8D%E6%87%82%E5%B0%B1%E7%94%A8-GPT-%E7%BF%BB%E8%AF%91%EF%BC%89"><span class="toc-text">分布式消息队列（学习方式：完整地去看官方文档的教程，讲的很详细，也很好理解，英文看不懂就先用浏览器翻译，如果还是看不懂就用 GPT 翻译）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%A8%A1%E5%9E%8B"><span class="toc-text">消息队列的模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">消息队列的应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-text">消息队列的缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E6%B5%81%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%80%89%E5%9E%8B"><span class="toc-text">主流分布式消息队列选型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ-%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98"><span class="toc-text">RabbitMQ 入门实战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-text">安装</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-text">发送消息</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE"><span class="toc-text">消息队列的一些配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WorkQueue"><span class="toc-text">WorkQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-text">多消费者</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6"><span class="toc-text">消息确认机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA-Exchanges"><span class="toc-text">交换机 Exchanges</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E5%9C%BA%E6%99%AF"><span class="toc-text">发布订阅场景</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E6%9C%9F"><span class="toc-text">第七期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%BB%91%E5%AE%9A"><span class="toc-text">路由绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Direct-%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-text">Direct 交换机</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E5%B0%9D%E8%AF%95%EF%BC%9A"><span class="toc-text">小尝试：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Direct-%E4%BA%A4%E6%8D%A2%E6%9C%BA-Demo-%E5%AE%9E%E7%8E%B0"><span class="toc-text">Direct 交换机 Demo 实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Topic-%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-text">Topic 交换机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Topic-Demo-%E5%AE%9E%E7%8E%B0"><span class="toc-text">Topic Demo 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#RPC"><span class="toc-text">RPC</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="toc-text">死信队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ-%E7%9A%84%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7"><span class="toc-text">RabbitMQ 的重要特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ-%E5%B0%8F%E6%B5%8B%E8%AF%95"><span class="toc-text">RabbitMQ 小测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RPC-%E5%AE%9E%E7%8E%B0"><span class="toc-text">RPC 实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98"><span class="toc-text">RabbitMQ 项目实战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%EF%BC%88%E5%85%88%E4%BD%BF%E7%94%A8-SpringBoot-%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%86%99%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-text">基础使用（先使用 SpringBoot 的客户端写一个测试方法）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BI-%E9%A1%B9%E7%9B%AE%E6%94%B9%E9%80%A0"><span class="toc-text">BI 项目改造</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Bug-%E6%B1%87%E6%80%BB%E5%92%8C%E8%A7%A3%E5%86%B3"><span class="toc-text">Bug 汇总和解决</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%89%8D%E7%AB%AF%E5%B8%83%E5%B1%80%E5%AF%BC%E8%87%B4%E9%A1%B9%E7%9B%AE%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%90%AF%E5%8A%A8%EF%BC%9A"><span class="toc-text">修改前端布局导致项目无法正常启动：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%B5%8B%E8%AF%95%E6%8E%A5%E5%8F%A3%E6%97%B6%EF%BC%8C-get-%E8%AF%B7%E6%B1%82%E5%BE%97%E5%88%B0%E7%9A%84%E5%93%8D%E5%BA%94%E8%BF%94%E5%9B%9E%E9%97%AE%E5%8F%B7%EF%BC%9A"><span class="toc-text">编写线程池测试接口时， get 请求得到的响应返回问号：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%8F%E5%B7%A5%E5%85%B7"><span class="toc-text">小工具</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/Shirly.github.io/2024/03/04/%E5%B0%8F%E6%96%B9%E7%9A%84%E9%A1%B9%E7%9B%AE/%E5%9F%BA%E4%BA%8EHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" title="Hexo 搭建博客教程"><img src="/Shirly.github.io/./image/3.png" onerror="this.onerror=null;this.src='/Shirly.github.io/img/404.jpg'" alt="Hexo 搭建博客教程"/></a><div class="content"><a class="title" href="/Shirly.github.io/2024/03/04/%E5%B0%8F%E6%96%B9%E7%9A%84%E9%A1%B9%E7%9B%AE/%E5%9F%BA%E4%BA%8EHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" title="Hexo 搭建博客教程">Hexo 搭建博客教程</a><time datetime="2024-03-04T01:12:48.012Z" title="发表于 2024-03-04 09:12:48">2024-03-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Shirly.github.io/2024/03/04/%E5%B0%8F%E6%96%B9%E7%9A%84%E9%A1%B9%E7%9B%AE/%E6%8E%A5%E5%8F%A3API%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0/" title="接口 API 开放平台笔记"><img src="/Shirly.github.io/./image/22.png" onerror="this.onerror=null;this.src='/Shirly.github.io/img/404.jpg'" alt="接口 API 开放平台笔记"/></a><div class="content"><a class="title" href="/Shirly.github.io/2024/03/04/%E5%B0%8F%E6%96%B9%E7%9A%84%E9%A1%B9%E7%9B%AE/%E6%8E%A5%E5%8F%A3API%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0/" title="接口 API 开放平台笔记">接口 API 开放平台笔记</a><time datetime="2024-03-04T01:12:43.006Z" title="发表于 2024-03-04 09:12:43">2024-03-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Shirly.github.io/2024/03/04/%E5%B0%8F%E6%96%B9%E7%9A%84%E9%A1%B9%E7%9B%AE/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE/" title="智能 BI 项目实现记录"><img src="/Shirly.github.io/./image/4.png" onerror="this.onerror=null;this.src='/Shirly.github.io/img/404.jpg'" alt="智能 BI 项目实现记录"/></a><div class="content"><a class="title" href="/Shirly.github.io/2024/03/04/%E5%B0%8F%E6%96%B9%E7%9A%84%E9%A1%B9%E7%9B%AE/%E6%99%BA%E8%83%BD%20BI%20%E9%A1%B9%E7%9B%AE/" title="智能 BI 项目实现记录">智能 BI 项目实现记录</a><time datetime="2024-03-04T01:12:31.966Z" title="发表于 2024-03-04 09:12:31">2024-03-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Shirly.github.io/2024/03/04/%E9%80%9A%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/" title="常见限流算法"><img src="https://fang-images.oss-cn-fuzhou.aliyuncs.com/images/IMG_2988.PNG" onerror="this.onerror=null;this.src='/Shirly.github.io/img/404.jpg'" alt="常见限流算法"/></a><div class="content"><a class="title" href="/Shirly.github.io/2024/03/04/%E9%80%9A%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/" title="常见限流算法">常见限流算法</a><time datetime="2024-03-04T00:50:54.113Z" title="发表于 2024-03-04 08:50:54">2024-03-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Shirly.github.io/2024/02/16/%E6%97%A5%E5%B8%B8%E5%B0%8F%E8%AE%B0/%E6%B8%B8%E6%88%8F%E7%94%BB%E9%9D%A2%E5%8D%A1%E6%AD%BB%20Nvddmkm%200%20%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="缓解游戏画面卡死，显卡掉驱动问题"><img src="/Shirly.github.io/./image/animaImage/7.png" onerror="this.onerror=null;this.src='/Shirly.github.io/img/404.jpg'" alt="缓解游戏画面卡死，显卡掉驱动问题"/></a><div class="content"><a class="title" href="/Shirly.github.io/2024/02/16/%E6%97%A5%E5%B8%B8%E5%B0%8F%E8%AE%B0/%E6%B8%B8%E6%88%8F%E7%94%BB%E9%9D%A2%E5%8D%A1%E6%AD%BB%20Nvddmkm%200%20%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="缓解游戏画面卡死，显卡掉驱动问题">缓解游戏画面卡死，显卡掉驱动问题</a><time datetime="2024-02-16T13:49:27.000Z" title="发表于 2024-02-16 21:49:27">2024-02-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/Shirly.github.io/./image/4.png')"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">你好，欢迎来到我的博客😊!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/Shirly.github.io/js/utils.js"></script><script src="/Shirly.github.io/js/main.js"></script><script src="/Shirly.github.io/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/Shirly.github.io/js/search/local-search.js"></script></div></body></html>